% \CheckSum{1607}
% \iffalse^^A meta-comment
% ======================================================================
% scrlayer-notecolumn.dtx
% Copyright (c) Markus Kohm, 2013-2016
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX
% version 2005/12/01 and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrlayer-notecolumn.dtx
% Copyright (c) Markus Kohm, 2013-2016
%
% Diese Datei ist Teil der LaTeX2e KOMA-Script-Sammlung.
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3c.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3c ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
%
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
% \fi^^A meta-comment
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \iffalse^^A meta-comment
%<identify>%%% From File: $Id: scrlayer-notecolumn.dtx 2398 2016-03-25 10:22:23Z kohm $ (identify)
%<init>%%% From File: $Id: scrlayer-notecolumn.dtx 2398 2016-03-25 10:22:23Z kohm $ (init)
%<options>%%% From File: $Id: scrlayer-notecolumn.dtx 2398 2016-03-25 10:22:23Z kohm $ (options)
%<body>%%% From File: $Id: scrlayer-notecolumn.dtx 2398 2016-03-25 10:22:23Z kohm $ (body)
%<*dtx>
\ifx\ProvidesFile\undefined\def\ProvidesFile#1[#2]{}\fi
\begingroup
  \def\filedate$#1: #2-#3-#4 #5${\gdef\filedate{#2/#3/#4}}
  \filedate$Date: 2016-03-25 11:22:23 +0100 (Fri, 25 Mar 2016) $
  \def\filerevision$#1: #2 ${\gdef\filerevision{v0.1.#2}}
  \filerevision$Revision: 2398 $
\endgroup
\ProvidesFile{scrlayer-notecolumn.dtx}[\filedate\space\filerevision\space
%</dtx>
%<*identify|doc>
%<interface>\NeedsTeXFormat{LaTeX2e}[1995/12/01]
%<interface>\ProvidesPackage{scrlayer-notecolumn}[%
%<doc>\ProvidesFile{scrlayer-notecolumn.tex}[%
% Sometimes following will be replaced by !KOMASCRIPTVERSION:
%!SCRLAYERVERSION
%<interface>  package
%</identify|doc>
%<*dtx|identify|doc>
  (end user interface for scrlayer)]
%</dtx|identify|doc>
%<*dtx>
\ifx\documentclass\undefined
  \input scrdocstrip.tex
  \@@input scrkernel-version.dtx
  \@@input scrstrip.inc
  \KOMAdefVariable{COPYRIGHTFROM}{2013}
  \KOMAdefVariable{SCRLAYERVERSION}{%
    \space\space\filedate\space\filerevision\space KOMA-Script
  }%
  \expandafter\let\csname ifbetawas\expandafter\endcsname
  \csname ifbeta\endcsname
  \expandafter\let\csname ifbeta\expandafter\endcsname
  \csname iftrue\endcsname
  \generate{\usepreamble\defaultpreamble
    \file{scrlayer-notecolumn.sty}{%
      \from{scrlayer-notecolumn.dtx}{interface,trace,notecolumn,identify}%
      \from{scrlayer.dtx}{interface,trace,notecolumn,init}%
      \from{scrlayer-notecolumn.dtx}{interface,trace,notecolumn,init}%
      \from{scrlayer.dtx}{interface,trace,notecolumn,options}%
      \from{scrlayer-notecolumn.dtx}{interface,trace,notecolumn,options}%
      \from{scrlayer.dtx}{interface,trace,notecolumn,body}%
      \from{scrlayer-notecolumn.dtx}{interface,trace,notecolumn,body}%
      \from{scrlayer-notecolumn.dtx}{interface,trace,notecolumn,final}%
      \from{scrlogo.dtx}{logo}%
    }%
  }
  \expandafter\let\csname ifbeta\expandafter\endcsname
  \csname ifbetawas\endcsname
  \@@input scrstrop.inc
\else
  \let\endbatchfile\relax
\fi
\endbatchfile
%</dtx>
%<*driver>
  \documentclass{scrdoc}
  \addtolength{\textwidth}{-1em}
  \addtolength{\marginparwidth}{2em}
  \addtolength{\oddsidemargin}{2em}
  \usepackage[ngerman,english]{babel}
  \usepackage{url,babelbib}\bibliographystyle{babalpha-fl}
  \usepackage{listings}
  \usepackage{scrhack}
  \usepackage{etoolbox}
  \pretocmd\DescribeMacro{\ifhmode\else\bigskip\noindent\fi}{}{}
  \pretocmd\DescribeEnv{\ifhmode\else\bigskip\noindent\fi}{}{}
  \pretocmd\DescribeOption{\ifhmode\else\bigskip\noindent\fi}{}{}

  \CodelineIndex
  \RecordChanges
  \GetFileInfo{scrlayer-notecolumn.dtx}
  \title{The \texttt{scrlayer} interface \texttt{scrlayer-notecolumn}%
    \footnote{This is version \fileversion\ of file \texttt{\filename}.}}
  \date{\filedate}
  \author{Markus Kohm}

  \newenvironment{Explain}{\par}{\par}
  \newcommand*{\length}{}
  \let\length\Length
  \let\endlength\endLength
  \let\Macro\cs
  \let\Length\Macro
  \let\Package\textsf
  \let\Class\Package
  \let\File\texttt
  \let\Option\texttt
  \newcommand*{\KOption}[1]{\Option{#1}\texttt{=}}
  \newcommand*{\OptionValue}[2]{\Option{#1}\texttt{=}\PValue{#2}}
  \let\Counter\texttt
  \let\Environment\texttt
  \let\ShowOutput\quote
  \let\endShowOutput\endquote
  \let\Pagestyle\texttt
  \newcommand*{\Parameter}[1]{\texttt{\marg{#1}}\linebreak[1]}
  \newcommand*{\OParameter}[1]{\texttt{\oarg{#1}}\linebreak[1]}
  \newcommand*{\MParameter}[2]{\texttt{(\meta{#1},\meta{#2})}\linebreak[1]}
  \providecommand\PParameter[1]{\mbox{\texttt{\{#1\}}}\linebreak[1]}
  \let\PName\meta
  \let\PValue\texttt
  \providecommand*{\autoref}[1]{\expandafter\AUTOREF#1:}
  \providecommand*{\AUTOREF}{}
  \makeatletter
  \def\AUTOREF#1:#2:{%
    \edef\@tempa{#1}%
    \edef\@tempb{tab}\ifx\@tempa\@tempb table~\fi
    \edef\@tempb{sec}\ifx\@tempa\@tempb section~\fi
    \ref{#1:#2}%
  }
  \providecommand*{\IndexCmd}[2][]{}
  \providecommand*{\textnote}[2][]{}
  \providecommand*\eTeX{\leavevmode\hbox{$\varepsilon$}-\TeX}
  \providecommand*\NTS{%
    \leavevmode\hbox{$\cal N\kern-0.35em\lower0.5ex\hbox{$\cal T$}%
      \kern-0.2emS$}}

  \lstnewenvironment{lstcode}{\lstset{language=[LaTeX]TeX}}{}
  \makeatother
  \sloppy% YOU SHOULD NOT DO THIS!!!

  \begin{document}
  \maketitle
  \begin{abstract}
    This is only the implementation documentation of package
    \Package{scrlayer-notecolumn}. See the English or German \KOMAScript{}
    manual for more information about usage of the package!
  \end{abstract}
  \tableofcontents
  \DocInput{\filename}
  \PrintChanges
  \PrintIndex
  \end{document}
%</driver>
% \fi^^A meta-comment
%
% \selectlanguage{english}
%
% \changes{v0.0}{2013/04/26}{start of interface}
%
% \StopEventually{}
%
%
% \iffalse
%<*interface>
%<*identify>
% \fi
%
%\iffalse
%</identify>
%\fi
%
%
% \section{Initialising some Values before the Options}
%
% \iffalse^^A meta-comment
%<*init>
% \fi^^A meta-comment
%
% Initialisation before all options (even the options from
% \File{scrlayer.dtx}).
%
% Here we test the used pdf\TeX{} primitives.
% \changes{v0.1}{2015/10/07}{ready for renaming \cs{pdfsavepos} and
%   \cs{pdflastypos} in luaTeX}^^A
%    \begin{macrocode}
\@tempswatrue
\scr@ifundefinedorrelax{pdfsavepos}{%
  \scr@ifundefinedorrelax{savepos}{%
    \expandafter\@tempswafalse
  }{%
    \let\scr@savepos\savepos
  }%
}{%
  \let\scr@savepos\pdfsavepos
  \scr@ifundefinedorrelax{pdflastypos}{%
    \scr@ifundefinedorrelax{lastypos}{%
      \expandafter\@tempswafalse
    }{%
      \let\scr@lastypos\lastypos
    }%
  }{%
    \let\scr@lastypos\pdflastypos
  }%
}
\if@tempswa\else
  \PackageError{scrlayer-notecolumn}{missing pdfTeX/luaTeX features}{%
    This package needs \string\pdfsavepos\space or \string\savepos\space
    and\MessageBreak
    \string\pdflastypos\space or \string\lastypos.\MessageBreak
    This error is fatal, because usage of the package without these
    features\MessageBreak
    cannot work!\MessageBreak
    You shouldn't continue, but if you'd try, I'll try to abort the LaTeX run
  }%
  \batchmode\csname @@end\endcsname\end
\fi
%    \end{macrocode}
%
% \iffalse^^A meta-comment
%</init>
% \fi^^A meta-comment
%
% \section{Making a Note Column}
%
% The package supports a various number of note columns. Each is referenced by
% a unique name.
%
% \begin{macro}{\DeclareNoteColumn}
%   \begin{description}
%   \item[\OParameter{option list}:] a comma-separated list of
%     \texttt{\meta{key}=\meta{value}} pairs.
%   \item[\Parameter{string}:] the name of the note column (must be fully
%     expandable and expand to a string only).
%   \end{description}
% That's the primary command for note columns. It defines everything, the note
% column needs.
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\DeclareNoteColumn{%
  \newcommand*{\DeclareNoteColumn}[2][]{%
%    \end{macrocode}
% First of all we need a box register. The contents of the note column will be
% build inside of this register. Since \eTeX{} registers shouldn't be a
% problem. User should use package \Package{etex}, if he or she runs out of
% registers. Note, that the registers will stay allocated, if the interface
% will be removed! Nevertheless, the name will be destroyed!
%    \begin{macrocode}
    \@ifundefined{slnc@#2@box}{%
      \expandafter\newsavebox\csname slnc@#2@box\endcsname
      \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
        \expandafter\let\csname slnc@#2@box\endcsname\relax
      }%
    }{}%
%    \end{macrocode}
% There's also a kind of item stack of unprocessed notes for each note column.
%    \begin{macrocode}
    \@ifundefined{slnc@#2@unprocessed}{%
      \@namedef{slnc@#2@unprocessed}{}%
      \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
        \expandafter\let\csname slnc@#2@unprocessed\endcsname\relax
      }%
    }{}%
%    \end{macrocode}
% Next we need a horizontal positions and a width for the note column. Neither
% the horizontal position nor the width are stretchable or shrinkable. The
% position should be variable depending on the page. So it's better to use a
% macro instead of a length. The width isn't more variable than, e.g., the
% text width. So we can use a macro too. Both will be initialised to the
% normal marginal note column.
%    \begin{macrocode}
    \@ifundefined{slnc@#2@pos}{%
      \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
        \expandafter\let\csname slnc@#2@pos\endcsname\relax
      }%
    }{}%
    \@ifundefined{slnc@#2@width}{%
      \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
        \expandafter\let\csname slnc@#2@width\endcsname\relax
      }%
    }{}%
%    \end{macrocode}
% If there isn't a font element for the (new) note column, we define a new one
% and add it to the auto-remove code:
%    \begin{macrocode}
    \@ifundefined{scr@fnt@notecolumn.#2}{%
      \@ifundefined{@notecolumn.#2font}{%
        \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
          \expandafter\let\csname @notecolumn.#2font\endcsname\relax
        }%
      }{%
        \PackageInfo{scrlayer-notecolumn}{using already defined
          macro\MessageBreak
          `\expandafter\string\csname @notecolumn.#2font\endcsname' for font
          element\MessageBreak
          `notecolumn.#2'%
        }%
      }%
      \newkomafont{notecolumn.#2}{}%
      \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
        \expandafter\let\csname scr@fnt@notecolumn.#2\endcsname\relax
      }%
    }{%
      \PackageInfo{scrlayer-notecolumn}{using already defined font
        element\MessageBreak
        `notecolumn.#2'%
      }%
    }%
%    \end{macrocode}
% After the initialisation we process the options, that may change the initial
% values.
%    \begin{macrocode}
    \newcommand*{\slnc@name}{}%
    \edef\slnc@name{#2}%
    \FamilyExecuteOptions[.definenotecolumn]{KOMAarg}{marginpar,#1}%
    \let\slnc@name\relax
%    \end{macrocode}
% The values are set up, so they may be used to declare a layer.
%    \begin{macrocode}
    \DeclareLayer[%
      foreground,%
      align=tl,%
      voffset=1in+\topmargin+\headheight+\headsep,%
      height=\dimexpr\textheight+\topskip\relax,%
      hoffset=\csname slnc@#2@pos\endcsname,%
      width=\csname slnc@#2@width\endcsname,%
      contents=\slnc@processnotes{#2}%
    ]{notecolumn.#2}
%    \end{macrocode}
% We need to add the layer to every page style. The easiest way to do this is
% to add it to the pseudo layer page style \Pagestyle{@everystyle@}.
% \changes{v0.1.1681}{2014/02/05}{add the layer only once}
%    \begin{macrocode}
    \IfLayerAtPageStyle{@everystyle@}{notecolumn.#2}{}{%
      \AddLayersToPageStyle{@everystyle@}{notecolumn.#2}%
%    \end{macrocode}
% On auto-removing the interface, the layer should be removed from
% \Pagestyle{@everystyle@} and should be destroyed.
%    \begin{macrocode}
    }%
    \scrlayerOnAutoRemoveInterface[scrlayer-notecolumn.sty]{%
      \RemoveLayersFromPageStyle{@everystyle@}{notecolumn.#2}%
      \DestroyLayer{notecolumn.#2}%
    }%
%    \end{macrocode}
% Last but not least, we add the new note column to the note column procession
% list.
%    \begin{macrocode}
    \@cons\slnc@processnotecolumns{{#2}}%
  }%
}
%    \end{macrocode}
% \begin{macro}{\slnc@processnotecolumns}
% This is a list of all declared note columns in \LaTeX{} syntax (using
% \Macro{@cons} and \Macro{@elt} etc.).
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@processnotecolumns{%
  \newcommand*{\slnc@processnotecolumns}{}%
}
%    \end{macrocode}
% \end{macro}^^A \slnc@processnotecolumns
%    \begin{macrocode}
%</body>
%    \end{macrocode}
% One note column will be declared by default:
%    \begin{macrocode}
%<*final>
\DeclareNoteColumn{marginpar}
%</final>
%<*body>
%    \end{macrocode}
% \begin{macro}{\slnc@testforpagestylewarning}
% Not all page styles are layer page styles, but only layer page styles can be
% extended by the note column layers. So we warn, if another page style has
% been selected.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@testforpagestylewarning{%
  \newcommand*{\slnc@testforpagestylewarning}{%
    \IfLayerPageStyleExists{\currentpagestyle}{}{%
      \PackageWarning{scrlayer-notecolumn}{%
        output of note columns delayed,\MessageBreak
        because with `\currentpagestyle'\MessageBreak
        a page style has been selected, that\MessageBreak
        isn't a layer page style,%
      }%
    }%
  }%
}
\AfterSelectAnyPageStyle{\slnc@testforpagestylewarning}
%    \end{macrocode}
% \end{macro}%^^A \slnc@testforpagestylewarning
% \begin{option}{position}
% \begin{option}{width}
% \begin{option}{font}
% \begin{option}{marginpar}
% \begin{option}{normalmarginpar}
% \begin{option}{reversemarginpar}
% Last but not least we have to define the options for the \PName{option
% list}.
%    \begin{macrocode}
\DefineFamilyMember[.definenotecolumn]{KOMAarg}
\DefineFamilyKey[.definenotecolumn]{KOMAarg}{position}{%
  \@namedef{slnc@\slnc@name @pos}{\dimexpr #1\relax}%
  \FamilyKeyStateProcessed
}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@position}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@position@default}
\DefineFamilyKey[.definenotecolumn]{KOMAarg}{width}{%
  \@namedef{slnc@\slnc@name @width}{\dimexpr #1\relax}%
  \FamilyKeyStateProcessed
}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@width}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@width@default}
\DefineFamilyKey[.definenotecolumn]{KOMAarg}{font}{%
  \setkomafont{notecolumn.\slnc@name}{#1}%
  \FamilyKeyStateProcessed
}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@font}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@font@default}
\DefineFamilyKey[.definenotecolumn]{KOMAarg}{marginpar}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{marginpar}{#1}%
  \edef\reserved@a{\noexpand\slnc@defpos{\slnc@name}}\reserved@a
  \@namedef{slnc@\slnc@name @width}{\marginparwidth}%
}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@marginpar}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@marginpar@default}
%    \end{macrocode}
% \begin{macro}{\slnc@defpos}
% Little helper for option \Option{marginpar}. The argument is the expanded
% name of the note column.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@defpos{%
  \newcommand*\slnc@defpos[1]{%
    \@namedef{slnc@#1@pos}{%
      \ifodd\value{page}
        \if@reversemargin
%    \end{macrocode}
% The reverse marginal note column on odd pages is at the left margin.
%    \begin{macrocode}
          \dimexpr \oddsidemargin+1in
                  -\marginparsep-\csname slnc@#1@width\endcsname\relax
        \else
%    \end{macrocode}
% The normal marginal note column on odd pages is the right margin.
%    \begin{macrocode}
          \dimexpr \oddsidemargin+1in
                  +\textwidth+\marginparsep\relax
        \fi
      \else
        \if@twoside
          \if@reversemargin
%    \end{macrocode}
% The reverse marginal note column on even pages is the right margin.
%    \begin{macrocode}
            \dimexpr \evensidemargin+1in
                    +\textwidth+\marginparsep\relax
          \else
%    \end{macrocode}
% The normal marginal note column on even pages is at the left margin.
%    \begin{macrocode}
            \dimexpr \evensidemargin+1in
                    -\marginparsep-\csname slnc@#1@width\endcsname\relax
          \fi
        \else
%    \end{macrocode}
%    \begin{macrocode}
% If not in two-side mode, do the same already done for odd pages.
          \if@reversemargin
            \dimexpr \oddsidemargin+1in
                    -\marginparsep-\csname slnc@#1@width\endcsname\relax
          \else
            \dimexpr \oddsidemargin+1in
                    +\textwidth+\marginparsep\relax
          \fi
        \fi
      \fi
    }%
  }%
}%
%    \end{macrocode}
% \end{macro}%^^A \slnc@defpos
%    \begin{macrocode}
\DefineFamilyKey[.definenotecolumn]{KOMAarg}{normalmarginpar}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{normalmarginpar}{#1}%
  \edef\reserved@a{\noexpand\slnc@defnormalpos{\slnc@name}}\reserved@a
  \@namedef{slnc@\slnc@name @width}{\marginparwidth}%
}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@normalmarginpar}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@normalmarginpar@default}
%    \end{macrocode}
% \begin{macro}{\slnc@defnormalpos}
% Little helper for option \Option{normalmarginpar}. The argument is the
% expanded name of the note column.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@defnormalpos{%
  \newcommand*\slnc@defnormalpos[1]{%
    \@namedef{slnc@#1@pos}{%
      \ifodd\value{page}
%    \end{macrocode}
% The normal marginal note column on odd pages is the right margin.
%    \begin{macrocode}
        \dimexpr \oddsidemargin+1in
                +\textwidth+\marginparsep\relax
      \else
        \if@twoside
%    \end{macrocode}
% The normal marginal note column on even pages is at the left margin.
%    \begin{macrocode}
          \dimexpr \evensidemargin+1in
                  -\marginparsep-\csname slnc@#1@width\endcsname\relax
        \else
%    \end{macrocode}
%    \begin{macrocode}
% If not in two-side mode, do the same already done for odd pages.
          \dimexpr \oddsidemargin+1in
                  +\textwidth+\marginparsep\relax
        \fi
      \fi
    }%
  }%
}%
%    \end{macrocode}
% \end{macro}%^^A \slnc@defnormalpos
%    \begin{macrocode}
\DefineFamilyKey[.definenotecolumn]{KOMAarg}{reversemarginpar}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{reversemarginpar}{#1}%
  \edef\reserved@a{\noexpand\slnc@defreversepos{\slnc@name}}\reserved@a
  \@namedef{slnc@\slnc@name @width}{\marginparwidth}%
}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@reversemarginpar}
\scrlayer@AddCsToInterface{KV@KOMAarg.definenotecolumn@reversemarginpar@default}
%    \end{macrocode}
% \begin{macro}{\slnc@defreversepos}
% Little helper for option \Option{reversemarginpar}. The argument is the
% expanded name of the note column.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@defreversepos{%
  \newcommand*\slnc@defreversepos[1]{%
    \@namedef{slnc@#1@pos}{%
      \ifodd\value{page}
%    \end{macrocode}
% The reverse marginal note column on odd pages is at the left margin.
%    \begin{macrocode}
        \dimexpr \oddsidemargin+1in
                -\marginparsep-\csname slnc@#1@width\endcsname\relax
      \else
        \if@twoside
%    \end{macrocode}
% The reverse marginal note column on even pages is the right margin.
%    \begin{macrocode}
          \dimexpr \evensidemargin+1in
                  +\textwidth+\marginparsep\relax
        \else
%    \end{macrocode}
%    \begin{macrocode}
% If not in two-side mode, do the same already done for odd pages.
          \dimexpr \oddsidemargin+1in
                  -\marginparsep-\csname slnc@#1@width\endcsname\relax
        \fi
      \fi
    }%
  }%
}%
%    \end{macrocode}
% \end{macro}%^^A \slnc@defreversepos
%    \begin{macrocode}
%</body>
%    \end{macrocode}
% \end{option}%^^A reversemarginpar
% \end{option}%^^A normalmarginpar
% \end{option}%^^A marginpar
% \end{option}%^^A font
% \end{option}%^^A width
% \end{option}%^^A position
% \end{macro}%^^A \DeclareNoteColumn
%
% \begin{macro}{\DeclareNewNoteColumn}
% \begin{macro}{\ProvideNoteColumn}
% \begin{macro}{\RedeclareNoteColumn}
% Like \Macro{DeclareNoteColumn} but with restrictions, if the note column has
% (not) been declared already.
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\DeclareNewNoteColumn{%
  \newcommand*{\DeclareNewNoteColumn}[2][]{%
    \scr@ifundefinedorrelax{slnc@#2@box}{}{%
      \PackageError{scrlayer-notecolumn}{note column `#2' already defined}{%
        You may declare only note columns, that haven't been declared
        previously using\MessageBreak
        \string\DeclareNewNoteColumn. See also the alternatives
        \string\RedeclareNoteColumn,\MessageBreak
        \string\ProvideNoteColumn, and \string\DeclareNoteColumn.\MessageBreak
        Nevertheless, if you'll continue, declaration will be done.%
      }%
    }%
    \DeclareNoteColumn[{#1}]{#2}%
  }%
}
\scrlayerAddToInterface\ProvideNoteColumn{%
  \newcommand*{\ProvideNoteColumn}[2][]{%
    \scr@ifundefinedorrelax{slnc@#2@box}{}{%
      \PackageInfo{scrlayer-notecolumn}{\string\ProvideNoteColumn{#2}
        ignored,\MessageBreak
        because of already defined\MessageBreak
        not column}%
    }{%
      \DeclareNoteColumn[{#1}]{#2}%
    }%
  }%
}
\scrlayerAddToInterface\RedeclareNoteColumn{%
  \newcommand*{\RedeclareNoteColumn}[2][]{%
    \scr@ifundefinedorrelax{slnc@#2@box}{%
      \PackageError{scrlayer-notecolumn}{note column `#2' undefined}{%
        You may declare only note columns, that have been declared
        previously using\MessageBreak
        \string\RedeclareNoteColumn. See also the alternatives
        \string\DeclareNewNoteColumn,\MessageBreak
        \string\ProvideNoteColumn, and \string\DeclareNoteColumn.\MessageBreak
        Nevertheless, if you'll continue, declaration will be done.%
      }%
    }{}%
    \DeclareNoteColumn[{#1}]{#2}%
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \section{Setting a Note Column}
%
% We already have commands to declare note columns. But we also need a command
% to put contents into the note columns and to output the note columns.
%
% \begin{macro}{\tf@slnc}
%   \changes{v0.1.2395}{2016/03/25}{write to \texttt{aux}-file with
%     \cs{if@filesw}}^^A
% \begin{macro}{\slnc@initwrite}
% \begin{macro}{\slnc@openwrite}
% First of all we need a file to write the notes to. We use the
% \File{aux}-file to write into the file, because we need to read the file
% while the document will be typeset and the same time we need to write into
% the file. Note, that the file will be still reserved on auto-removing the
% interface!
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\tf@slnc{%
  \newwrite\tf@slnc
  \AtBeginDocument{%
    \if@filesw
      \immediate\write\@auxout{%
        \noexpand\csname slnc@initwrite\noexpand\endcsname
      }%
    \fi
  }%
  \AtEndDocument{\let\slnc@initwrite\slnc@openwrite}%
}
\scrlayerAddToInterface\slnc@initwrite{}%
\scrlayerAddToInterface\slnc@openwrite{%
  \newcommand*{\slnc@openwrite}{%
    \immediate\closeout\slnc@file
%<*trace>
    \PackageInfo{scrlayer-notecolumn}{%
      Opening `\jobname.slnc'\MessageBreak
      for writing}%
%</trace>
    \immediate\openout\tf@slnc\jobname.slnc
  }%
}
\AfterReadingMainAux{%
  \immediate\closeout\tf@slnc
  \scr@ifundefinedorrelax{pdfmdfivesum}{%
    \PackageWarningNoLine{scrlayer-notecolumn}{%
      \string\pdfmdfivesum\space unavailable.\MessageBreak
      The package needs \string\pdfmdfivesum\space to test\MessageBreak
      whether or not one more LaTeX run will\MessageBreak
      be needed to make the note columns\MessageBreak
      right. If this command is unavailable\MessageBreak
      you have to do the decision without\MessageBreak
      this help of the package.%
    }%
  }{%
    \begingroup
      \edef\reserved@a{\pdfmdfivesum file {\jobname.slnc}}%
      \ifx \slnc@mdfivesum\reserved@a
%<*trace>
        \PackageInfo{scrlayer-notecolumn}{%
          MD5 of current `\jobname.slnc':\MessageBreak 
          \reserved@a}%
%</trace>
      \else
%<*trace>
        \PackageWarningNoLine{scrlayer-notecolumn}{%
          MD5 of slnc-file changed.\MessageBreak
          Last: \slnc@mdfivesum\MessageBreak
          New: \space \reserved@a\MessageBreak
          At least one more LaTeX rerun need to\MessageBreak
          make note columns right%
        }%
%</trace>
        \aftergroup\@tempswatrue
      \fi
    \endgroup
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \slnc@openwrite
% \end{macro}^^A \slnc@initwrite
% \end{macro}^^A \tf@slnc
%
% \begin{macro}{\makenote}
%   \begin{description}
%   \item[\OParameter{string}:] the name of the note column the note should be
%     added to (must be fully expandable and expand to a string only). The
%     default value is \PValue{marginpar}.
%   \item[\Parameter{code}:] the code, that should become par of the note
%     column. Note, that this will be written protected to a file. So you have
%     to use \Macro{protect} if a macro shouldn't be expanded while writing or
%     may break while writing.
%   \end{description}
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\makenote{%
  \newcommand{\makenote}[2][marginpar]{%
    \@bsphack
    \scr@savepos
    \addtocontents{slnc}{%
      \string\slnc@note{#1}%
                       {\noexpand\number\value{slncpage}}%
                       {\noexpand\number\scr@lastypos}%
                       {#2}%
    }%
    \@esphack
  }%
}
%    \end{macrocode}
%^^A \begin{counter}{slncpage}
% This counter should be increased once per page with note column. This may
% be done simply at a once per page executed hook of
% \Pagestyle{@everystyle@}. You should note, that auto-remove wouldn't
% remove the counter.
%    \begin{macrocode}
\@ifundefined{c@slncpage}{%
  \newcounter{slncpage}%
  \AddToLayerPageStyleOptions{@everystyle@}{%
    onbackground=\stepcounter{slncpage}%
  }%
}{}
%</body>
%    \end{macrocode}
%^^A \end{counter}^^A slncpage
% \end{macro}^^A \makenote
%
% \begin{macro}{\slnc@processnotes}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the note column (must be fully
%     expandable an expand to a string only).
%   \end{description}
% Each note column typesets the notes with this command. It works in following
% steps:
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\slnc@processnotes{%
  \newcommand*{\slnc@processnotes}[1]{%
%    \end{macrocode}
% Read as long notes from the notes file until the number at \#2 of
% \Macro{slnc@note} in the file is greater than \Counter{slncpage}. Put all
% these to the corresponding unprocessed list.
%    \begin{macrocode}
    \begingroup
      \slnc@readnotes{\value{slncpage}}%
%    \end{macrocode}
% Process the unprocessed list of the current note column
%    \begin{macrocode}
      \expandafter\let\expandafter\reserved@a
      \csname slnc@#1@unprocessed\endcsname
      \expandafter\global
      \expandafter\let\csname slnc@#1@unprocessed\endcsname\@empty
      \def\slnc@notesyncfonttest##1{%
        \ifhmode
          \PackageError{scrlayer-notecolumn}{%
            illegal font setting for `notecolumn.##1'%
          }{%
            Current setting of font for `notecolumn.##1' switches
            from\MessageBreak
            vertical mode to horizontal mode. This is
            illegal!\MessageBreak
            You have to change the font setting to fix
            this.\MessageBreak
            If you'll continue vertical alignment of notes may fail%
          }%
          \par\vskip-\dimexpr \baselineskip+\parskip\relax
        \fi
      }%
      \long\def\slnc@note##1##2##3##4{%
        \let\PackageInfo\PackageWarning
        \ifnum ##2>\value{slncpage}\relax
          \expandafter\g@addto@macro\csname slnc@#1@unprocessed\endcsname{%
            \slnc@note{##1}{##2}{##3}{##4}%
          }%
        \else
          \ifnum ##2<\value{slncpage}\relax
            \PackageWarning{scrlayer-notecolumn}{note of type `#1' delayed.}%
          \fi
          \boxmaxdepth\maxdepth
          \expandafter\setbox\csname slnc@#1@box\endcsname\vbox{%
            \expandafter\hsize\csname slnc@#1@width\endcsname
            \normalfont\normalsize
            {%
%    \end{macrocode}
% Question: Why is it not allowed to set a colour here?
%    \begin{macrocode}
              \let\color\@gobble
              \usekomafont{notecolumn.#1}{%
                \slnc@notesyncfonttest{#1}%
                \expandafter\ifvoid\csname slnc@#1@box\endcsname
                  \expandafter\setbox\csname slnc@#1@box\endcsname\vbox{%
                    \kern\dimexpr\topskip-\baselineskip\relax
                  }%
                \fi
%    \end{macrocode}
% \changes{v0.1}{2015/10/07}{ready for renaming \cs{pdfpageheight} in
%   luaTeX}^^A
% From lua\TeX~0.80.1 \cs{pdfpageheight} will be renamed into
% \cs{pageheight}. So we have to do an extra test for the new primitive.
%    \begin{macrocode}
                \scr@ifundefinedorrelax{pdfpageheight}{%
                  \scr@ifundefinedorrelax{pageheight}{%
                    \@tempdima=\paperheight
                  }{%
                    \@tempdima=\pageheight
                  }%
                }{%
                  \@tempdima=\pdfpageheight
                }%
                \@tempdima=\dimexpr \@tempdima-##3sp
                                    -1in-\topmargin
                                    -\headheight-\headsep
                                    -\baselineskip
                           \relax
                \@tempdimb=\dimexpr \expandafter\ht\csname slnc@#1@box\endcsname
                                   +\expandafter\dp\csname slnc@#1@box\endcsname
                           \relax
                \typeout{Soll: \the\@tempdima^^JIst: \space\the\@tempdimb}%
                \ifdim\@tempdima<\@tempdimb
%<*trace>
                  \PackageInfo{scrlayer-notecolumn}{%
                    Note moved down from\MessageBreak
                    \the\@tempdima\space to \the\@tempdimb\MessageBreak
                    at note box `#1'
                  }%
%</trace>
                \else
                  \ifdim\@tempdima>\@tempdimb
%<*trace>
                    \PackageInfo{scrlayer-notecolumn}{%
                      Adding vertical white space from\MessageBreak
                      \the\@tempdimb\space to \the\@tempdima\MessageBreak
                      into note box `#1'
                    }%
%</trace> 
                    \expandafter\setbox\csname slnc@#1@box\endcsname
                    \vbox {%
                      \expandafter\unvbox\csname slnc@#1@box\endcsname
                      \kern\dimexpr\@tempdima-\@tempdimb\relax
                    }%
                  \fi
                \fi
                \expandafter\ifvoid\expandafter\csname slnc@#1@box\endcsname
                \else
                  \@tempdima\dimexpr
                              \dp\strutbox
                              -\dp\csname slnc@#1@box\endcsname
                            \relax
                  \expandafter\unvbox\csname slnc@#1@box\endcsname
                  \ifdim\@tempdima>\z@ \kern\@tempdima\fi
                \fi
                \strut\ignorespaces ##4\par
              }%
            }%
          }%
        \fi
      }%
      \def\slnc@sync##1##2##3##4{%
        \ifnum ##2>\value{slncpage}\relax
          \expandafter\g@addto@macro\csname slnc@#1@unprocessed\endcsname{%
            \slnc@sync{##1}{##2}{##3}{}%
          }%
        \else
          \if@filesw
            \expandafter\setbox\csname slnc@#1@box\endcsname\vbox{%
              \expandafter\unvbox\csname slnc@#1@box\endcsname
              \scr@savepos
              \protected@write\@auxout{}{%
                \string\newlabel{notecolumn.##1.##3.syncnote.label}{%
                  {%
                    \noexpand\number\scr@lastypos
                  }{\thepage}%
                }%
              }%
            }%
          \fi
        \fi
      }%
      \reserved@a
      \expandafter\ifvoid\csname slnc@#1@box\endcsname
%<*trace>
        \PackageInfo{scrlayer-notecolumn}{Note box `#1' empty}%
%</trace>
      \else
        \ifdim \dimexpr \expandafter\ht\csname slnc@#1@box\endcsname
                       +\expandafter\dp\csname slnc@#1@box\endcsname
               \relax >\textheight\relax
%<*trace>
          \PackageInfo{scrlayer-notecolumn}{Split note box `#1'}%
%</trace>
          \splittopskip\topskip
          \splitmaxdepth\baselineskip
%    \end{macrocode}
% Bring back the colours:
%    \begin{macrocode}
          \usekomafont{notecolumn.#1}{%
            \expandafter\vsplit\csname slnc@#1@box\endcsname to
            \textheight\relax
          }%
          \expandafter\ifvoid\csname slnc@#1@box\endcsname
          \else
            \expandafter\setbox\csname slnc@#1@box\endcsname\vbox{%
                  \expandafter\unvbox\csname slnc@#1@box\endcsname
            }%
          \fi
        \else
%<*trace>
          \PackageInfo{scrlayer-notecolumn}{Flush note box `#1'}%
%</trace>
%    \end{macrocode}
% Bring back the colours:
%    \begin{macrocode}
          \usekomafont{notecolumn.#1}{%
            \expandafter\box\csname slnc@#1@box\endcsname%
          }%
        \fi
      \fi
      \expandafter\global
      \expandafter\setbox\csname slnc@#1@box\expandafter\endcsname
      \expandafter\box\csname slnc@#1@box\endcsname
    \endgroup
  }
}
%    \end{macrocode}
% \begin{macro}{\slnc@readnotes}
% Read as long notes from the notes file until the number at \#2 of
% \Macro{slnc@note} or \Macro{slnc@sync} in the file is greater than
% \Counter{slncpage}. Put all these to the corresponding unprocessed list.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@readnotes{%
  \newcommand*\slnc@readnotes[1]{%
    \ifeof\slnc@file\else
      \ifnum \number #1<\slnc@unprocessed\relax
        \@tempswafalse
      \else
        \@tempswatrue
      \fi
      \@whilesw\if@tempswa\fi{%
        \edef\reserved@a{%
          \noexpand\makeatletter
          \endlinechar\m@ne
          \read\noexpand\slnc@file to\noexpand\reserved@a
          \endlinechar\the\endlinechar\relax
          \catcode`\noexpand\@=\the\catcode`\@\relax
        }%
        \reserved@a
        \expandafter\slnc@iofv\expandafter\reserved@b\reserved@a
        \@empty\@empty\@empty\@empty\@empty
        \@tempswafalse
        \@for\reserved@c :={\slnc@note },{\slnc@sync }\do{%
          \ifx\reserved@b\reserved@c \@tempswatrue\fi
        }%
        \if@tempswa
          \@tempswafalse
          \expandafter\slnc@iiiofv\expandafter\reserved@b\reserved@a
          \@empty\@empty\@empty\@empty\@empty
          \ifx\reserved@b\@empty
            \PackageError{scrlayer-notecolumn}{internal syntax error}{%
              Unexpected syntax of file `\jobname.slnc'.\MessageBreak
              Second argument should be a number.\MessageBreak
              I don't know what to do with\MessageBreak
              \expandafter\detokenize\expandafter{\reserved@a}%
            }%
            \@tempswatrue
          \else
            \global\let\slnc@unprocessed\reserved@b
            \expandafter\slnc@iiofv\expandafter\reserved@b\reserved@a
            \@empty\@empty\@empty\@empty\@empty
            \@ifundefined{slnc@\reserved@b @unprocessed}{%
              \PackageWarning{scrlayer-notecolumn}{%
                column `\reserved@b' undefined.\MessageBreak
                You should declare the column before the usage.\MessageBreak
                Notes will be lost
              }%
            }{%
              \expandafter\g@addto@macro
              \csname slnc@\reserved@b @unprocessed\expandafter\endcsname
              \expandafter{%
                \reserved@a
              }%
            }%
            \ifnum \number #1<\slnc@unprocessed\relax
              \@tempswafalse
            \else
              \@tempswatrue
            \fi
          \fi
        \else
%<*trace>
          \PackageInfo{scrlayer-notecolumn}{%
            Ignoring `\expandafter\detokenize\expandafter{\reserved@a}'}%
%</trace>
          \@tempswatrue
        \fi
        \ifeof\slnc@file\@tempswafalse\fi
      }%
    \fi
  }%
}
%    \end{macrocode}
% \end{macro}^^A \slnc@readnotes
% \begin{macro}{\slnc@iofv}
% \begin{macro}{\slnc@iiofv}
% \begin{macro}{\slnc@iiiofv}
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@iofv{%
  \newcommand\slnc@iofv[6]{\def#1{#2}}%
}
\scrlayerAddToInterface\slnc@iiofiv{%
  \newcommand\slnc@iiofv[6]{\def#1{#3}}%
}
\scrlayerAddToInterface\slnc@iiiofiv{%
  \newcommand\slnc@iiiofv[6]{\def#1{#4}}%
}
%    \end{macrocode}
% \end{macro}^^A \slnc@iiiofv
% \end{macro}^^A \slnc@iiofv
% \end{macro}^^A \slnc@iofv
% \begin{macro}{\slnc@unprocessed}
% The \#2 of the last read note column from notes file.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@unprocessed{%
  \newcommand*{\slnc@unprocessed}{0}%
}
%</body>
%    \end{macrocode}
% \begin{macro}{\slnc@file}
% The input file with the unprocessed notes.
% \begin{macro}{\slnc@mdfivesum}
% The MD5 sum of the file before opening it for reading.
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\slnc@mdfivesum{%
  \let\slnc@mdfivesum\@empty
}
\scrlayerAddToInterface\slnc@file{%
  \scr@ifundefinedorrelax{pdfmdfivesum}{}{%
    \xdef\slnc@mdfivesum{\pdfmdfivesum file {\jobname.slnc}}%
%<*trace>
    \PackageInfo{scrlayer-notecolumn}{%
      MD5 of last `\jobname.slnc':\MessageBreak
      \slnc@mdfivesum}%
%</trace>
  }%
  \newread\slnc@file
  \immediate\openin\slnc@file \jobname.slnc
  \scrlayerOnAutoRemoveInterface{\immediate\closeout\slnc@file}%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \slnc@mdfivesum
% \end{macro}^^A \slnc@file
% \end{macro}^^A \slnc@unprocessed
% \end{macro}^^A \slnc@processnotes
%
% \begin{option}{autoclearnotecolumns}
%    \begin{macrocode}
%<*options>
\KOMA@ifkey{autoclearnotecolumns}{slnc@autoclearnotecolumns}\slnc@autoclearnotecolumnstrue
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @autoclearnotecolumns}
\scrlayer@AddCsToInterface{KV@KOMA.\@currname.\@currext @autoclearnotecolumns@default}
%</options>
%<*final>
\let\reserved@a\clearpage
\def\clearpage{%
  \ifslnc@autoclearnotecolumns\clearnotecolumns\relax\fi
}%
\expandafter\g@addto@macro\expandafter\clearpage\expandafter{\reserved@a}
%</final>
%    \end{macrocode}
% \end{option}
%
% \begin{macro}{\clearnotecolumn}
%   \begin{description}
%   \item[\OParameter{string}:] the name of the note column (must be fully
%     expandable and expand to a string only). Default is \PValue{marginpar}.
%   \end{description}
% Output as many (empty) pages as needed to output all unprocessed notes of
% one note column. Note, that the output of the first page may result in more
% unprocessed notes. But the output of the following (empty) pages shouldn't.
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\c@slnc@clearnote@label{%
  \newcounter{slnc@clearnote@label}%
}
\scrlayerAddToInterface\clearnotecolumn{%
  \newcommand*\clearnotecolumn[1][marginpar]{%
    \begingroup
      \slnc@autoclearnotecolumnsfalse
%    \end{macrocode}
% First of all we need to know the note column page of this page.
%    \begin{macrocode}
      \stepcounter{slnc@clearnote@label}%
      \if@filesw
        \protected@write\@auxout{%
          \let\theslncpage\relax
          \let\slnc@voidtest\relax
        }{%
          \string\newlabel{notecolumn.\theslnc@clearnote@label}%
          {{\theslncpage}{\slnc@voidtest{#1}}}%
        }%
      \fi
      \scr@ifundefinedorrelax{r@notecolumn.\theslnc@clearnote@label}{%
        \PackageInfo{scrlayer-notecolumn}{%
          Using estimated to low value for clearing\MessageBreak
          note colum `#1'%
        }
        \edef\slnc@cmp@value{\the\value{slncpage}}%
        \let\reserved@a\z@
      }{%
        \edef\reserved@a{%
          \@nameuse{r@notecolumn.\theslnc@clearnote@label}\@empty\@empty
        }%
        \edef\slnc@cmp@value{\expandafter\slnc@firstof\reserved@a\@nil}%
        \edef\reserved@a{\expandafter\slnc@secondof\reserved@a\@nil}%
      }%
      \ifnum \reserved@a=\z@
%    \end{macrocode}
% Next we read all notes until the end of the current page, but only
% if a \Macro{clearpage} wouldn't result in a new page.
%    \begin{macrocode}
        \ifvmode
          \ifdim \pagetotal<\topskip
          \else
            \slnc@readnotes{\slnc@cmp@value}%
          \fi
        \else
          \slnc@readnotes{\slnc@cmp@value}%
        \fi
        \begingroup
          \aftergroup\@tempswafalse
          \long\def\slnc@note##1##2##3##4{%
            \ifnum ##2>\slnc@cmp@value\relax \else \aftergroup\@tempswatrue\fi
          }%
          \let\slnc@sync\slnc@note
          \csname slnc@#1@unprocessed\endcsname
        \endgroup
      \else
        \PackageInfo{scrlayer-notecolumn}{%
          box of note column `#1'\MessageBreak
          not empty after page of \string\clearnotecolumn}%
        \@tempswatrue
      \fi
      \if@tempswa
%    \end{macrocode}
% Yes, we have!
%    \begin{macrocode}
        \IfLayerPageStyleExists{\currentpagestyle}{}{%
          \PackageWarning{scrlayer-notecolumn}{%
            \string\clearnotecolumn\space while active non-layer page
            style.\MessageBreak
            Activate empty page style until note column\MessageBreak
            has been cleared%
          }%
          \pagestyle{empty}%
        }%
        \@tempswatrue
      \fi
      \@whilesw\if@tempswa\fi{%
%    \end{macrocode}
% Yes, we have (maybe again)!
%    \begin{macrocode}
        \clearpage
        \expandafter\ifcase \slnc@voidtest{#1}%
          \begingroup
            \aftergroup\@tempswafalse
            \long\def\slnc@note##1##2##3##4{%
              \ifnum ##2>\slnc@cmp@value\relax \else \aftergroup\@tempswatrue\fi
            }%
            \let\slnc@sync\slnc@note
            \csname slnc@#1@unprocessed\endcsname
          \endgroup
        \else
          \@tempswatrue
        \fi
        \if@tempswa
%    \end{macrocode}
% And we still have: So we have to output one more page.
%    \begin{macrocode}
          \null
        \fi
      }%
    \endgroup
  }%
}
%    \end{macrocode}
% \begin{macro}{\slnc@firstof}
% \begin{macro}{\slnc@secondof}
%   We need these little helpers, because some packages like
%   \Package{hyperref} extend the label mechanism by additional arguments.
%    \begin{macrocode}
\scrlayerAddToInterface{\slnc@firstof}{%
  \def\slnc@firstof#1#2\@nil{#1}%
}
\scrlayerAddToInterface{slnc@secondof}{%
  \def\slnc@secondof#1#2#3\@nil{#2}%
}
%    \end{macrocode}
% \end{macro}^^A \slnc@firstof
% \end{macro}^^A \slnc@secondof
% \begin{macro}{\slnc@voidtest}
%   \begin{description}
%   \item[\Parameter{string}:] the name of a note column (must be fully
%     expandable and expand to a string only).
%   \end{description}
% If the box of the note column is empty/void it returns \Macro{z@} otherwise
% \Macro{@ne}.
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@voidtest{%
  \newcommand*{\slnc@voidtest}[1]{%
    \expandafter\ifvoid \csname slnc@#1@box\endcsname \z@\else \@ne\fi
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \slnc@voidtest
% \end{macro}^^A \clearnotecolumn
% 
% \begin{macro}{\clearnotecolumns}
%   \begin{description}
%   \item[\OParameter{string list}:] comma separated list of note column names
%     (must be fully expandable and each element must expand to a string only,
%     that is the name of a note column); if omitted or empty all note columns
%     will be used.
%   \end{description}
% Output as many (empty) pages as needed to output all unprocessed notes of
% all (given) note columns. Note, that the output of the first page may
% result in more unprocessed notes. But the output of the following (empty)
% pages shouldn't.
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface\clearnotecolumns{%
  \newcommand*\clearnotecolumns[1][\relax]{%
    \begingroup
      \slnc@autoclearnotecolumnsfalse
      \ifx\relax#1\relax\else
        \let\slnc@processnotecolumns\@empty
        \edef\reserved@a{#1}%
        \expandafter\@for\expandafter\reserved@a\expandafter:\expandafter=%
        \reserved@a\do {%
          \ifx\reserved@a\@empty\else
            \expandafter\l@addto@macro\expandafter\slnc@processnotecolumns
            \expandafter{\expandafter\@elt\expandafter{\reserved@a}}%
          \fi
        }%
      \fi
%    \end{macrocode}
% First of all we need to know the note column page of this page.
%    \begin{macrocode}
      \stepcounter{slnc@clearnote@label}%
      \if@filesw
        \begingroup
          \def\@elt##1{+\slnc@voidtest{##1}}%
          \protected@write\@auxout{%
            \let\theslncpage\relax
            \let\slnc@voidtest\relax
          }{%
            \string\newlabel{notecolumn.\theslnc@clearnote@label}%
            {{\theslncpage}{\numexpr \slnc@processnotecolumns\relax}}%
          }%
        \endgroup
      \fi
      \scr@ifundefinedorrelax{r@notecolumn.\theslnc@clearnote@label}{%
        \begingroup
          \def\@elt##1{, `##1'}%
          \PackageInfo{scrlayer-notecolumn}{%
            Using estimated to low value for\MessageBreak
            clearing note colums\MessageBreak
            \expandafter\@gobble\slnc@processnotecolumns
          }%
        \endgroup
        \edef\slnc@cmp@value{\the\value{slncpage}}%
        \let\reserved@a\z@
      }{%
        \edef\reserved@a{%
          \@nameuse{r@notecolumn.\theslnc@clearnote@label}\@empty\@empty
        }%
        \edef\slnc@cmp@value{\expandafter\slnc@firstof\reserved@a\@nil}%
        \edef\reserved@a{\expandafter\slnc@secondof\reserved@a\@nil}%
      }%
      \ifcase \reserved@a\relax
%    \end{macrocode}
% Next we read all notes until the end of the current page, but only
% if a \Macro{clearpage} wouldn't result in a new page.
%    \begin{macrocode}
        \ifvmode
          \ifdim \pagetotal<\topskip
          \else
            \slnc@readnotes{\slnc@cmp@value}%
          \fi
        \else
          \slnc@readnotes{\slnc@cmp@value}%
        \fi
        \begingroup
          \aftergroup\@tempswafalse
          \long\def\slnc@note##1##2##3##4{%
            \ifnum ##2>\slnc@cmp@value\relax \else \aftergroup\@tempswatrue\fi
          }%
          \let\slnc@sync\slnc@note
          \def\@elt##1{\csname slnc@##1@unprocessed\endcsname}%
          \slnc@processnotecolumns
        \endgroup
      \else
        \PackageInfo{scrlayer-notecolumn}{%
          box of at least one note column\MessageBreak
          not empty after page of \string\clearnotecolumns}%
        \@tempswatrue
      \fi
      \if@tempswa
%    \end{macrocode}
% Yes, we have!
%    \begin{macrocode}
        \IfLayerPageStyleExists{\currentpagestyle}{}{%
          \PackageWarning{scrlayer-notecolumn}{%
            \string\clearnotecolumns\space while active non-layer page
            style.\MessageBreak
            Activate empty page style until note column\MessageBreak
            has been cleared%
          }%
          \pagestyle{empty}%
        }%
        \@tempswatrue
      \fi
      \@whilesw\if@tempswa\fi{%
%    \end{macrocode}
% Yes, we have (maybe again)!
%    \begin{macrocode}
        \clearpage
        \begingroup
          \def\@elt##1{+\slnc@voidtest{##1}}%
          \ifcase \numexpr \slnc@processnotecolumns\relax
            \aftergroup\@tempswafalse
            \long\def\slnc@note##1##2##3##4{%
              \ifnum ##2>\slnc@cmp@value\relax \else \aftergroup\@tempswatrue\fi
            }%
            \let\slnc@sync\slnc@note
            \def\@elt##1{\csname slnc@##1@unprocessed\endcsname}%
            \slnc@processnotecolumns
          \else
            \aftergroup\@tempswatrue
          \fi
        \endgroup
        \if@tempswa
%    \end{macrocode}
% And we still have: So we have to output one more page.
%    \begin{macrocode}
          \null
        \fi
      }%
    \endgroup
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \clearnotecolumns
%
%
% \section{Syncronisation of Text and Note}
% \label{sec:scrlayer-notecolumn.sync}
%
% Until yet we have the text and we have note columns. Normally note entries
% to a note column are in sync with the text position, that makes the
% note. But if there are collisions the sync may be lost. In this case the
% note may be later (but never earlier), so we need a mechanism to force
% synchronisation of the text with the note.
%
% \begin{macro}{\syncwithnotecolumn}
%   \begin{description}
%   \item[\OParameter{string}:] the name of the note column to sync with (this
%     must be fully expandable and expand to the name of a note column). By
%     default sync with note column \PValue{marginpar}.
%   \end{description}
% Add at the \LaTeX{} run after the next \LaTeX{} run as much space to the
% text (not the note column!) as needed to reach the next position at the
% note column. This is not the same like \Macro{clearnotecolumn}, because it
% doesn't need to go to the next page, but it needs at least three \LaTeX{}
% runs to terminate.
%    \begin{macrocode}
%<*body>
\scrlayerAddToInterface{\c@slnc@syncpoint}{%
  \newcounter{slnc@syncpoint}%
}
\scrlayerAddToInterface{\syncwithnotecolumn}{%
  \newcommand*{\syncwithnotecolumn}[1][marginpar]{%
    \begingroup
      \edef\reserved@a{\endgroup\noexpand\syncwithnotecolumns[{#1}]}%
    \reserved@a
  }%
}
\scrlayerAddToInterface{\syncwithnotecolumns}{%
  \newcommand*{\syncwithnotecolumns}[1][\relax]{%
    \begingroup
      \ifx\relax#1\relax\else
        \let\slnc@processnotecolumns\@empty
        \edef\reserved@a{#1}%
        \expandafter\@for\expandafter\reserved@a\expandafter:\expandafter=%
        \reserved@a\do {%
          \ifx\reserved@a\@empty\else
            \expandafter\l@addto@macro\expandafter\slnc@processnotecolumns
            \expandafter{\expandafter\@elt\expandafter{\reserved@a}}%
          \fi
        }%
      \fi
      \stepcounter{slnc@syncpoint}%
      \def\@elt##1{%
        \addtocontents{slnc}{%
          \string\slnc@sync{##1}%
                           {\noexpand\number\value{slncpage}}%
                           {\theslnc@syncpoint}%
                           {}%
        }%
      }%
      \slnc@processnotecolumns
      \ifvmode
        \let\slnc@voffset\@empty%
        \expandafter\@firstofone
      \else
        \PackageWarning{scrlayer-notecolumn}{%
          \string\syncwithnotecolumn\space in hmode.\MessageBreak
          Using \string\syncwithnotecolumn\space in horizontal\MessageBreak
          mode may result in unwanted vertical\MessageBreak
          space inside paragraphs and may lost\MessageBreak
          colours of text of notes. \space So perhaps you\MessageBreak
          should move \string\syncwithnotecolumn\space before\MessageBreak
          or after the paragraph%
        }%
        \let\slnc@voffset\@empty%\def\slnc@voffset{-\number\baselineskip}%
        \expandafter\slnc@vadjust
      \fi
      {%
        \if@filesw
          \scr@savepos
          \protected@write\@auxout{}{%
            \string\newlabel{notecolumn.\theslnc@syncpoint.synctext.label}{%
              {%
                \noexpand\number
                \numexpr \scr@lastypos\slnc@voffset\relax
              }{\thepage}%
            }%
          }%
        \fi
        \@ifundefined{r@notecolumn.\theslnc@syncpoint.synctext.label}{%
          \PackageInfo{scrlayer-notecolumn}{%
            No text label for \string\syncwithnotecolumn.\MessageBreak
            Need rerun to sync position}%
        }{%
          \edef\reserved@a{%
            \@nameuse{r@notecolumn.\theslnc@syncpoint.synctext.label}%
            \@empty\@empty
          }%
          \edef\slnc@textpos{\expandafter\slnc@firstof\reserved@a\@nil}%
          \edef\slnc@textpage{\expandafter\slnc@secondof\reserved@a\@nil}%
          \let\slnc@notepos\slnc@textpos
          \let\slnc@notepage\slnc@textpage
          \def\@elt##1{%
            \@ifundefined{r@notecolumn.##1.\theslnc@syncpoint.syncnote.label}{%
              \PackageInfo{scrlayer-notecolumn}{%
                No note label for sync with note column\MessageBreak
                `##1'.\MessageBreak
                Need rerun to sync position}%
              \G@refundefinedtrue
            }{%
              \edef\reserved@a{%
                \@nameuse{r@notecolumn.##1.\theslnc@syncpoint.syncnote.label}%
                \@empty\@empty
              }%
              \edef\reserved@b{\expandafter\slnc@firstof\reserved@a\@nil}%
              \edef\reserved@c{\expandafter\slnc@secondof\reserved@a\@nil}%
              \ifnum \slnc@notepage<\reserved@c\relax
                \let\slnc@notepos=\reserved@b
                \let\slnc@notepage=\reserved@c
              \else
                \ifnum \slnc@notepage=\reserved@c\relax
                  \ifnum \slnc@notepos>\reserved@b
                    \let\slnc@notepos=\reserved@b
                    \let\slnc@notepage=\reserved@c
                  \fi
                \fi
              \fi
            }%
          }%
          \slnc@processnotecolumns
          \ifnum\slnc@textpage>\slnc@notepage\relax
            \PackageInfo{scrlayer-notecolumn}{%
              Last note page before last text page.\MessageBreak
              Need rerun to sync position}%
          \else
            \ifnum\slnc@textpage<\slnc@notepage\relax
             \@whilenum \slnc@textpage<\slnc@notepage\do {%
               \newpage\null\vskip-\dimexpr \baselineskip+\parskip\relax
                \edef\slnc@textpage{\the\numexpr\slnc@textpage+1\relax}%
              }%
%    \end{macrocode}
% \changes{v0.1}{2015/10/07}{ready for renaming \cs{pdfpageheight} in
%   luaTeX}^^A
% From lua\TeX~0.80.1 \cs{pdfpageheight} will be renamed into
% \cs{pageheight}. So we have to do an extra test for the new primitive.
%    \begin{macrocode}
              \scr@ifundefinedorrelax{pdfpageheight}{%
                \scr@ifundefinedorrelax{pageheight}{%
                  \@tempdima=\paperheight
                }{%
                  \@tempdima=\pageheight
                }%
              }{%
                \@tempdima=\pdfpageheight
              }%
              \@tempdima=\dimexpr \@tempdima
                                 -\topmargin-1in
                                 -\headheight-\headsep
                                 -\topskip+\baselineskip
                                 \relax
              \edef\slnc@textpos{\number\@tempdima}%
%<*trace>
              \PackageInfo{scrlayer-notecolumn}{%
                Top position is \slnc@textpos%
              }%
%</trace>
            \fi
            \ifnum\slnc@notepos>\slnc@textpos\relax
              \PackageInfo{scrlayer-notecolumn}{%
                Last note position before last text\MessageBreak
                position.\MessageBreak
                Need rerun to sync position%
              }%
            \else
              \ifnum\slnc@notepos<\slnc@textpos\relax
                \@tempdima=\numexpr \slnc@textpos-\slnc@notepos\relax sp
                \PackageInfo{scrlayer-notecolumn}{%
                  skipping \the\@tempdima\space to sync%
                }%
                \vskip\@tempdima
              \fi
            \fi
          \fi
        }%
      }%
    \endgroup
  }%
}
%    \end{macrocode}
% \begin{macro}{\slnc@vadjust}
%    \begin{macrocode}
\scrlayerAddToInterface\slnc@vadjust{%
  \newcommand{\slnc@vadjust}[1]{%
    \@bsphack
    \vadjust{#1}%
    \@esphack
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \slnc@vadjust
% \end{macro}^^A \syncwithnotecolumn
% 
%
% \iffalse^^A meta-comment
%</interface>
% \fi^^A meta-comment
%
% \Finale
%
\endinput
%
% end of file `scrlayer-notecolumn.dtx'

%%% Local Variables:
%%% mode: doctex
%%% mode: flyspell
%%% ispell-local-dictionary: "en_GB"
%%% TeX-master: t
%%% End:
