% ======================================================================
% scrbase.tex
% Copyright (c) Markus Kohm, 2002-2016
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX 
% version 2005/12/01 or later and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrbase.tex
% Copyright (c) Markus Kohm, 2002-2016
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3c, verteilt und/oder veraendert werden.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3c ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 oder spaeter und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
% 
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
%
% Package scrbase for Package and Class Authors
% Maintained by Markus Kohm
%
% ----------------------------------------------------------------------
%
% Paket scrbase fuer Paket- und Klassenautoren
% Verwaltet von Markus Kohm
%
% ======================================================================

\KOMAProvidesFile{scrbase.tex}
                 [$Date: 2016-03-09 18:09:14 +0100 (Wed, 09 Mar 2016) $
                  KOMA-Script package scrbase]
\translator{Markus Kohm\and Melvin Hendrix}

% Date of the translated German file: 2016-03-09

\chapter{Basic Functions of Package \Package{scrbase}}
\labelbase{scrbase}

\BeginIndex{Package}{scrbase}%

The package \Package{scrbase} provides basic features designed and implemented
for use by authors of packages and classes. However, \Package{scrbase} cannot
only by used for wrapper classes related to \KOMAScript{} class. Authors of
classes that have nothing to do with \KOMAScript{} can benefit from
\Package{scrbase} functionality.

\section{Loading the Package}
\seclabel{loadit}

Whereas users load packages using \Macro{usepackage}, authors of packages or
classes should use \Macro{RequirePackage}\IndexCmd{RequirePackage}. Authors of
wrapper packages may also use \Macro{RequirePackageWithOptions}. Command
\Macro{RequirePackage} has the same optional argument for package options like
\Macro{usepackage}. In contrast, \Macro{RequirePackageWithOptions} does not
have an optional argument but passes all options given when loading the
wrapper package to the required package. See \cite{latex:clsguide} for more
information about these commands.

The package \Package{scrbase} needs the functionality of package
\Package{keyval}\IndexPackage{keyval} internally. This may be provided by
package \Package{xkeyval} alternatively. Package \Package{scrbase} loads
\Package{keyval} as needed.

The package \Package{keyval} provides definition of keys and assignment of
values to these keys. The options provided by \Package{scrbase} also use
\Package{keyval} syntax: \PName{key}\texttt{=}\PName{value}.

\begin{Declaration}
  \KOption{internalonly}\PName{value}
\end{Declaration}
\BeginIndex{Option}{internalonly~=\PName{value}}%
Package \Package{scrbase} provides some commands for conditional
execution. The primary names for these are builds like
\Macro{scr@\PName{name}}, which are internal commands. \KOMAScript{} only uses
these internal commands internally. Authors of packages and classes may use
these internal commands, too, but should not redefine them. Because some of
these commands are useful for users, too, they are provided as
\Macro{\PName{name}} normally. But eventually, other packages may provide
commands with the same name but different syntax or different
functionality. As this would result in an conflict, \Package{scrbase} can
suppress the definition of the user commands \Macro{\PName{name}}. Using
option \Option{internalonly} without \PName{value} will define only the
internal commands and suppress definition of all the user commands for
conditional execution. Alternatively, the user may give all the commands that
should not be defined as \PName{value}, but replaces ``\Macro{}'' by
``\texttt{/}''.

Authors of packages and classes normally should not use this option. Users may
use it with or without \PName{value} either as a global option with
\Macro{documentclass} or using \Macro{PassOptionsToPackage}.
\begin{Example}
  The user does not want \Package{scrbase} to define commands \Macro{ifVTeX}
  and \Macro{ifundefinedorrelax}. Because of this, to load the class, the user
  writes:
\begin{lstcode}
  \documentclass%
    [internalonly=/ifVTeX/ifundefinedorrelax]%
    {foo}
\end{lstcode}
  Class name \Class{foo} is, therefore, an placeholder
  for any class in this example. The meanings of commands \Macro{ifVTeX} and
  \Macro{ifundefinedorrelax} and many more commands for conditional execution
  is located in \autoref{sec:scrbase.if}.
\end{Example}
%
\EndIndex{Option}{internalonly~=\PName{value}}%


\section{Keys as Attributes of Families and their Members}
\seclabel{keyvalue}

As already mentioned in \autoref{sec:scrbase.loadit}, \Package{scrbase} uses
package \Package{keyval} for keys and values of keys. Nevertheless
\Package{scrbase} extends the functionality of \Package{keyval}. Whereas only
one family owns all keys of \Package{keyval}, \Package{scrbase} recognises
also family members. Therefore, a key may be owned by a family or by one or
more family members. Additionally, a value may be assigned to the key of a
family member, to the key of a family, or to the keys of all family members.

\begin{Declaration}
  \Macro{DefineFamily}\Parameter{family}\\
  \Macro{DefineFamilyMember}\OParameter{family member}\Parameter{family}%
\end{Declaration}
\BeginIndex{Cmd}{DefineFamily}%
\BeginIndex{Cmd}{DefineFamilyMember}%
\Package{scrbase} needs to know the members of a family for different
reasons. First, you have to define a new family using
\Macro{DefineFamily}, which produces an empty member list. If the family
has already been defined nothing would happen. Nothing also means that an
already existing member list would not be overwritten.

Next, a new member can be added to the family using
\Macro{DefineFamilyMember}. If the family does not exist, this would result in
an error message. If the member already exists, nothing happens. If the
optional \PName{family member} is omitted, the default value
``\texttt{.}\Macro{@currname}\texttt{.}\Macro{@currext}'' is used. During
class or package loading \Macro{@currname} and \Macro{@currext} together
represent the file name of the class or package.

Theoretically, it is possible, to define a member without a name using an
empty optional \PName{family member} argument. But this is the same as the
family itself. It is recommended that only letters and digits be used for
\PName{family} and the first character of \PName{family member} should not be
a letter or digit. Otherwise, it could happen that members of one family are
the same as members of another family.

\Package{scrbase} assigns family ``\PValue{KOMA}'' to itself and adds member
``\PValue{.scrbase.sty}'' to it. Family ``\PValue{KOMA}'' is reserved to
\KOMAScript{}. For your own packages, use the name of the bundle as
\PName{family} and the name of the package as \PName{family member} of that
\PName{family}.
%
\begin{Example}
  Assume you are writing a bundle called ``master butcher''. Within that
  bundle you have packages \File{salami.sty}, \File{liversausage.sty}, and
  \File{kielbasa.sty}. Therefore, you decide to use family name
  ``\PValue{butcher}'' and,to each of the package file, you add the lines
\begin{lstcode}
  \DefineFamily{butcher}
  \DefineFamilyMember{butcher}
\end{lstcode}
  When loading the three packages, this will
  add the members ``\PValue{.salami.sty}'', ``\PValue{.liversausage.sty}'',
  and ``\PValue{.kielbasa.sty}'' to the family ``\PValue{butcher}''. After
  loading all three packages, all three member will be defined.
\end{Example}
%
\EndIndex{Cmd}{DefineFamilyMember}%
\EndIndex{Cmd}{DefineFamily}%


\begin{Declaration}
  \Macro{DefineFamilyKey}\OParameter{family member}\Parameter{family}%
  \Parameter{key}\\
  \hphantom{\XMacro{DefineFamilyKey}}\OParameter{default}\Parameter{action}\\
  \Macro{FamilyKeyState}\\
  \Macro{FamilyKeyStateUnknown}\\
  \Macro{FamilyKeyStateProcessed}\\
  \Macro{FamilyKeyStateUnknownValue}\\
  \Macro{FamilyKeyStateNeedValue}
\end{Declaration}
\BeginIndex{Cmd}{DefineFamilyKey}%
\BeginIndex{Cmd}{FamilyKeyState}%
\BeginIndex{Cmd}{FamilyKeyStateUnknown}%
\BeginIndex{Cmd}{FamilyKeyStateProcessed}%
\BeginIndex{Cmd}{FamilyKeyStateUnknownValue}%
\BeginIndex{Cmd}{FamilyKeyStateNeedValue}%
The command \Macro{DefineFamilyKey} defines a \PName{key}. If a \PName{family
  member} is given, the \PName{key} becomes an attribute of that member in the
given \PName{family}. If a \PName{family member} is not given, the member
``\texttt{.}\Macro{@currname}\texttt{.}\Macro{@currext}'' is assumed. If,
later, a value is assigned to the \PName{key}, the \PName{action} will be
executed and the value made an argument of \PName{action}. So inside
\PName{action} ``\lstinline{#1}'' would be that value. If the value is
omitted, the \PName{default} is used instead. If there is no \PName{default},
the \PName{key} can be used only with a value being defined.

\begin{Explain}
  \phantomsection\label{explain:scrbase.macro.DefineFamilyKey}%
  At least
\begin{lstcode}[escapeinside=`']
  \DefineFamilyKey[`\PName{member}']{`\PName{family}'}{`\PName{key}'}
                  [`\PName{default}']{`\PName{action}'}
\end{lstcode}
  will result in a call of
\begin{lstcode}[moretexcs={define@key},escapeinside=`']
  \define@key{`\PName{family\,member}'}{`\PName{key}'}
             [`\PName{default}']{`\PName{extended action}'}
\end{lstcode}
  with \Macro{define@key} provided by package
  \Package{keyval}\IndexPackage{keyval} (see \cite{package:keyval}). However,
  the call of \Macro{define@key} and the \PName{action} is, in fact, 
  extended by additional arrangements.
\end{Explain}

Success\ChangedAt{v3.12}{\Package{scrbase}} or failure of the execution of the
\PName{action} should be reported back to \Package{scrbase} by
\Macro{FamilyKeyState}. The package itself will take care of additional
procedures if needed. You should not report errors by yourself! The default
state before execution of \PName{action} is
\Macro{FamilyKeyStateUnknown}. This signals that it is not known whether or
not the execution is successful. If this state does not change until end of
execution of the \PName{action}, \Package{scrbase} will write a message into
the \File{log} file and assumes state \Macro{FamilyKeyStateProcessed} during
the further procedure.

State \Macro{FamilyKeyStateProcessed} signals that the option and the value
assignment to the option are completely and successfully finished. You may
switch to this state by using \Macro{FamilyKeyStateProcessed} itself.

State \Macro{FamilyKeyStateUnknownValue} indicates that the option was
handled, but the value, that should be assigned to the key, was unknown or not
allowed. You should use \Macro{FamilyKeyStateUnknownValue} to switch to
this state.

State \Macro{FamilyKeyStateNeedValue} signals that the option could not be
set because it needs a value, but no value was assigned to the
key. This state is used automatically, whenever an option has been
defined without \PName{default} value and is used without value
assignment. You should not set the state using \Macro{FamilyKeyStateNeedValue}
yourself.

Last but not least you may switch to additional failure states, simply
re-defining \Macro{FamilyKeyState} with a very short text message.
Generally, the four predefined states should be sufficient.

\begin{Example}
  Assume each of the three packages from the previous example should get a
  key named \PValue{coldcuts}. When used, a switch is set at each of
  the packages. For package \Package{salami} this may be:
\begin{lstcode}
  \newif\if@Salami@Aufschnitt
  \DefineFamilyKey{butcher}%
                  {coldcuts}[true]{%
    \expandafter\let\expandafter\if@salami@coldcuts
    \csname if#1\endcsname
    \FamilyKeyStateProcessed
  }
\end{lstcode}
  Available values for the key are \PValue{true} or \PValue{false} in this
  case. Instead of testing on inappropriate values, success will be signalled
  for any case in this example. If the key is used later, it is executed with
  one of the allowed values or without assignment. In the second case, the
  default \PName{true} will be used.

  The definitions in the other packages are similar. Only ``\texttt{salami}''
  has to be replaced by the corresponding names.
\end{Example}
%
\EndIndex{Cmd}{FamilyKeyStateNeedValue}%
\EndIndex{Cmd}{FamilyKeyStateUnknownValue}%
\EndIndex{Cmd}{FamilyKeyStateProcessed}%
\EndIndex{Cmd}{FamilyKeyStateUnknown}%
\EndIndex{Cmd}{FamilyKeyState}%
\EndIndex{Cmd}{DefineFamilyKey}%


\begin{Declaration}
  \Macro{RelaxFamilyKey}\OParameter{family member}\Parameter{family}%
  \Parameter{key}
\end{Declaration}
\BeginIndex{Cmd}{RelaxFamilyKey}%
If\ChangedAt{v3.15}{\Package{scrbase}} the \PName{key} of the \PName{family
  member} of \PName{family} has been defined before, that definition will be
cancelled. Afterwards the \PName{key} will not be defined for the \PName{family
  member} of \PName{family} any longer. Usage of \Macro{RelaxFamilyKey} for a
not yet defined \PName{key} of the \PName{family member} of the \PName{family}
is also allowed.%
\EndIndex{Cmd}{RelaxFamilyKey}%

\begin{Declaration}
  \Macro{FamilyProcessOptions}\OParameter{family member}\Parameter{family}
\end{Declaration}
\BeginIndex{Cmd}{FamilyProcessOptions}%
Generally the extension of keys of families to keys of families and family
members, as mentioned earlier, uses keys or key-value settings as class or
package options. The command \Macro{FamilyProcessOptions} is an extension of
\Macro{ProcessOption*} from \LaTeX{} kernel (see \cite{latex:clsguide}, which
processes not only options that has been declared using \Macro{DeclareOption},
it processes all keys of the given family member. If the optional argument
\PName{family member} is omitted, family member
``\texttt{.}\Macro{@currname}\texttt{.}\Macro{@currext}'' is used.

Somehow special are keys that are not attached to a family member, but to a
family. These are keys with an empty family member. Such keys are set before
the keys of the family members.
\begin{Example}
  If a package in the previous example would be extended by the line
\begin{lstcode}
  \FamilyProcessOptions{butcher}
\end{lstcode}
  then the user may select the option \Option{coldcuts} when loading the
  package. If the option is used globally, this means at the optional
  argument of \Macro{documentclass}, then the option would be passed
  automatically to all three packages, if all three packages are loaded
  later.
\end{Example}
Please note\textnote{Attention!} that packages always process global options
before local options. When processing unknown options initiate an entry in the
\File{log}-file and the option is otherwise ignored. By contrast, unknown
options assigned to the package locally leads to an error message.

\Macro{FamilyProcessOptions} may be interpreted either as an extension of
\Macro{ProcessOption*} or as an extension of the \PName{key=value} mechanism
of \Package{keyval}. Ultimately, with the help of
\Macro{FamilyProcessOptions}, \PName{key=value} pairs become options.%
%
\EndIndex{Cmd}{FamilyProcessOptions}%


\begin{Declaration}
  \Macro{BeforeFamilyProcessOptions}\OParameter{member}\Parameter{family}%
                                    \Parameter{code}%
\end{Declaration}
\BeginIndex{Cmd}{BeforeFamilyProcessOptions}%
Especially\ChangedAt{v3.18}{\Package{scrbase}} authors of wrapper classes or
wrapper packages sometimes need a hook to execute \PName{code} just before
\Macro{FamilyProcessOptions}. The package \Package{scrbase} provides such a
hook and you can add \PName{code} to it using
\Macro{BeforeFamilyProcessOptions}. The parameters \PName{member} and
\PName{family} are same to \Macro{FamilyProcessOptions}. In difference to
\Macro{FamilyProcessOptions} you can add \PName{code} also to the hook of not
yet defined \PName{family} or \PName{member}.

Note, the hook of a family member will be cleaned after execution. But if you
use an empty \PName{member} the \PName{code} will be executed before the
\Macro{FamilyProcessOptions} of every member of the \PName{family} and will
never be deleted.

\begin{Example}
  Now, you are writing a package that loads \Package{liversausage}. But you do
  not provide option \Option{coldcut} with this package. So you use
  \Macro{BeforeFamilyProcessOptions} to deactivate
  that option before loading the package:
\begin{lstcode}
  \RequirePackage{scrbase}
  \BeforeFamilyProcessOptions[.liversausage.sty]{butcher}{%
    \RelaxFamilyKey[.liversausage.sty]{butcher}{coldcut}%
  }
  \RequirePackageWithOptions{liversausage}
\end{lstcode}
  If after this a user tries to load your package with option
  \Option{coldcut}, package \Package{liversausage} will throw an undefined
  option error. If \Option{coldcut} is used as a global option, package
  \Package{liversausage} will ignore it. But default settings inside
  \Package{liversausage}, e.\,g., using \Macro{FamilyExecuteOptions} before
  \Macro{FamilyProcessOptions} are not effected.
\end{Example}
\EndIndex{Cmd}{BeforeFamilyProcessOptions}%


\begin{Declaration}
  \Macro{FamilyExecuteOptions}\OParameter{family member}\Parameter{family}%
  \Parameter{options list}
\end{Declaration}
\BeginIndex{Cmd}{FamilyExecuteOptions}%
This command is an extension of \Macro{ExecuteOptions} from the \LaTeX{}
kernel (see \cite{latex:clsguide}). The command processes not only options
that are defined using \Macro{DeclareOption}, but also processes all keys of
the given \PName{family member}. If the optional argument \Macro{family
  member} is omitted, then
``\texttt{.}\Macro{@currname}\texttt{.}\Macro{@currext}'' is used.

Somehow special are keys of empty family members, which are not attached to a
family member, but to a family. Such keys are set before the keys of family
members.
\begin{Example}
  Assume option \Option{coldcuts} should be set by default in the
  previous example. In this case only line
\begin{lstcode}
  \FamilyExecuteOptions{butcher}{coldcuts}
\end{lstcode}
  has to be added.
\end{Example}

If\ChangedAt{v3.20}{\Package{scrbase}} you call \Macro{FamilyExecuteOptions}
with an unknown option inside the \PName{options list}, you will get an
error. But you will not get an error, if the \PName{family member} has an
option \Option{@else@}. In this case option \Option{@else@} will be used
instead of the unknown option. \KOMAScript{} itself uses this feature, e.\,g.,
inside the definition of section like commands to prior the style attribute
above all other attributes.

Usage of the command inside the execution of an option is provided.%
%
\EndIndex{Cmd}{FamilyExecuteOptions}%


\begin{Declaration}
  \Macro{FamilyOptions}\Parameter{family}\Parameter{options list}%
\end{Declaration}
\BeginIndex{Cmd}{FamilyOptions}%
Hence \PName{options list} is like:
\begin{flushleft}\vskip\dp\strutbox\begin{tabular}{l}
    \PName{key}\texttt{=}\PName{value}\texttt{,}%
    \PName{key}\texttt{=}\PName{value}\dots
\end{tabular}\vskip\dp\strutbox\end{flushleft}
after which the value assignment may be omitted for \PName{key}s that have a
defined default.

In contrast to average options that are defined using \Macro{DeclareOption},
the \PName{key}s also may be set after loading a class or package. For this,
the user calls \Macro{FamilyOptions}. Thereafter, the \PName{key}s of all
members of the specified family are set. If a \PName{key} also exists as a
family attribute, then the family key is set first. After this, the member
keys follow in the order in which the members have been defined. If a given
\PName{key} does not exist, either for the family or for any member of the
family, then \Macro{FamilyOptions} will result in an error. Package
\Package{scrbase} reports an error also if there are members with key
\PName{key}, but all those members signal failure via \Macro{FamilyKeyState}.
\begin{Example}
  You extend your butcher project by a package \Package{sausagesalad}. If this
  package has been loaded, all sausage package should generate cold cuts:
\begin{lstcode}
  \ProvidesPackage{sausagesalad}%
                  [2008/05/06 nonsense package]
  \DefineFamily{butcher}
  \DefineFamilyMember{butcher}
  \FamilyProcessOptions{butcher}\relax
  \FamilyOptions{butcher}{coldcuts}
\end{lstcode}
  If currently none of the sausage packages are loaded, the undefined option
  \Option{coldcuts} leads to an error message.  This is avoided by adding
  before the last line of the code above:
\begin{lstcode}
  \DefineFamilyKey{butcher}%
                  {coldcuts}[true]{}%
\end{lstcode}
  However, sausage packages loaded after
  \Package{sausagesalad} still do not produce cold cuts. This may be corrected
  by editing the last line of the code again to:
\begin{lstcode}
  \AtBeginDocument{%
    \DefineFamiyKey[.sausagesalad.sty]%
                   {butcher}%
                   {coldcuts}[true]{}%
  }
  \DefineFamilyKey{butcher}%
                  {coldcuts}[true]{%
    \AtBeginDocument{\FamilyOptions{butcher}%
                                   {coldcuts=#1}}%
  }%
\end{lstcode}
  This code does following: First the option will be defined while
  \Macro{begin}\PParameter{document} to do nothing for package
  \Package{sausagesalad}. Because \Macro{@currname} and \Macro{@currext} are
  not longer valid at this time, the optional argument on
  \Macro{DefineFamilyKey} has to be used. But until this re-definition of the
  option, a second definition is made, that calls the option again while
  \Macro{begin}\PParameter{document} for the whole family and so also for
  other sausage salad packages.
\end{Example}
%
\EndIndex{Cmd}{FamilyOptions}%


\begin{Declaration}
  \Macro{FamilyOption}\Parameter{family}%
                      \Parameter{option}\Parameter{values list}%
\end{Declaration}
\BeginIndex{Cmd}{FamilyOption}%
Besides options that have concurrently excluding values, there may be options
that produce several values at the same time. Using \Macro{FamilyOptions} for
that type of option would result in using the same option several times with
different value assignments. Instead of this, \Macro{FamilyOption} may be used
to assign a whole \PName{values list} to the same \PName{option}. The
\PName{values list} is a comma separated list of values, also known as
\emph{csv}:
\begin{flushleft}\begin{tabular}{l}
    \PName{value}\texttt{,}\PName{value}\dots
\end{tabular}\end{flushleft}
By the way, please note that usage of a comma inside a value may be done only
if the value is put inside braces. The general functionality of this command
is the same as that of the previous command \Macro{FamilyOptions}.
\begin{Example}
  Package \Package{sausagesalad} should have one mire option, to add
  additional ingredients. Each of the ingredients sets a switch as was done
  previously for the cold cuts.
\begin{lstcode}
  \newif\if@saladwith@onions
  \newif\if@saladwith@gherkins
  \newif\if@saladwith@chillies
  \DefineFamilyKey{butcher}{ingredient}{%
    \csname @saladwith@#1true\endcsname
  }
\end{lstcode}
  Here the three ingredients ``onions'', ``gherkins'', and ``chillies'' have
  been defined. An error message for ``not defined'' ingredients does not
  exist.

  For a salad with onions and gherkins the user may use
\begin{lstcode}
  \FamilyOptions{butcher}{%
    ingredient=onions,ingredient=gherkins}
\end{lstcode}
  or shorter
\begin{lstcode}
  \FamilyOption{butcher}
               {ingredient}{onions,gherkins}
\end{lstcode}
\end{Example}
%
\EndIndex{Cmd}{FamilyOption}%


\begin{Declaration}
  \Macro{AtEndOfFamilyOptions}\Parameter{action}%
\end{Declaration}
\BeginIndex{Cmd}{AtEndOfFamilyOptions}%
Sometimes\ChangedAt{v3.12}{\Package{scrbase}} it is useful to delay the
execution of an \PName{action} that is part of a value assignment to a key
until all assignments inside one \Macro{FamilyProcessOptions},
\Macro{FamilyExecuteOptions}, \Macro{FamilyOptions}, or \Macro{FamilyOption}
is finished. This may be done using \Macro{AtEndOfFamilyOptions} inside
an option definition. Reporting failure states of \PName{action} is not
possible in this case. Furthermore, the command should not be used outside an
option definition.
%
\EndIndex{Cmd}{AtEndOfFamilyOptions}%


\begin{Declaration}
  \Macro{FamilyBoolKey}\OParameter{family member}\Parameter{family}%
                       \Parameter{key}\Parameter{switch name}\\
  \Macro{FamilySetBool}\Parameter{family}%
                       \Parameter{key}\Parameter{switch name}\Parameter{value}
\end{Declaration}
\BeginIndex{Cmd}{FamilyBoolKey}%
\BeginIndex{Cmd}{FamilySetBool}%
In the previous examples, boolean switches often have been used. In the example
with option \Option{coldcuts}, it is necessary that the user assigns either
value \PValue{true} or value \PValue{false}. There is no error message for
wrong value assignment. Because of this, boolean switches are a necessary
feature. Package \Package{scrbase} provides \Macro{FamilyBoolKey} for definition of
such options. Therefore, the arguments \PName{family member}, \PName{family}, and
\PName{key} are the same as that used by \Macro{DefineFamilyKey} (see
\autopageref{desc:scrbase.cmd.DefineFamilyKey}). Argument \PName{switch name}
is the name of the switch without the prefix \Macro{if}. If a switch with this
name does not exist already, \Macro{FamilyBoolKey} will define it and
initialize it to \PName{false}. Internally \Macro{FamilyBooKey} uses
\Macro{FamilySetBool} as \PName{action} of \Macro{DefineFamilyKey}. The
\PName{default} for those options is always \PValue{true}.

On the other hand, \Macro{FamilySetBool} understands \PName{value} \PValue{on}
and \PValue{yes} beside \PName{true} for switching on and \PName{off} and
\PName{no} beside \PName{false} for switching off. Unknown values will result
in a call of \Macro{FamilyUnknownKeyValue} with the arguments \PName{family},
\PName{key}, and \PName{value}, which results in setting of
\Macro{FamilyKeyState}. Depending on the command used and other family
members, this may result in an error message about unknown value assignment
(see also \autopageref{desc:scrbase.cmd.FamilyUnkownKeyValue} and
\autopageref{desc:scrbase.cmd.FamilyKeyState}).
\begin{Example}
  The key \Option{coldcuts} should be declared somehow more
  robust. Additionally, all sausage packages should use the same key. So
  either all or none of them will produce cold cuts.
\begin{lstcode}
  \FamilyBoolKey{butcher}{coldcuts}%
                         {@coldcuts}
\end{lstcode}
  A test, whether or not to produce cold cuts, may be:
\begin{lstcode}
  \if@coldcuts
     ...
  \else
     ...
  \fi
\end{lstcode}
  This would be the same in each of the three sausage packages, thereby
  defining the attribute ``coldcuts'' as a family option:
\begin{lstcode}[moretexcs={define@key}]
  \@ifundefined{if@coldcuts}{%
    \expandafter\newif\csname if@coldcuts\endcsname
  }{}%
  \DefineFamilyKey[]{butcher}{coldcuts}[true]{%
    \FamilySetBool{butcher}{coldcuts}%
                           {@coldcuts}%
                           {#1}%
  }
\end{lstcode}
  or shorter:
\begin{lstcode}
  \FamilyBoolKey[]{butcher}{coldcuts}%
                           {@coldcuts}
\end{lstcode}
  using the additional information at
  \autopageref{explain:scrbase.macro.DefineFamilyKey}, this is not only valid
  for \Macro{DefineFamilyKey} but for \Macro{FamilyBoolKey} too.
\end{Example}
%
\EndIndex{Cmd}{FamilySetBool}%
\EndIndex{Cmd}{FamilyBoolKey}


\begin{Declaration}
  \Macro{FamilyNumericalKey}\OParameter{family member}\Parameter{family}%
                            \Parameter{key}\\
  \hphantom{\XMacro{FamilyNumericalKey}}%
                            \OParameter{default}\Parameter{command}%
                            \Parameter{values list}\\
  \Macro{FamilySetNumerical}\Parameter{family}\Parameter{key}\\
  \hphantom{\XMacro{FamilySetNumerical}}%
                            \Parameter{command}\Parameter{values list}%
                            \Parameter{value}
\end{Declaration}
\BeginIndex{Cmd}{FamilyNumericalKey}%
\BeginIndex{Cmd}{FamilySetNumerical}%
In contrast to switches that may be either true or false, a key exists
that accept several values. For example an alignment may not only be left or
not left, but left, centered, or right. Internally such
differentiation often is made using \Macro{ifcase}. This \TeX{} command
expects a numerical value. Because of this the command to define a macro by
a \PName{key} has been named \Macro{FamilyNumericalKey} in
\Package{scrbase}. The \PName{values list} thereby has the form:
\begin{flushleft}\vskip\dp\strutbox\begin{tabular}{l}
    \Parameter{value}\Parameter{definition}\texttt{,}%
    \Parameter{value}\Parameter{definition}\texttt{,}%
    \dots
\end{tabular}\vskip\dp\strutbox\end{flushleft}
Therefore, the \PName{values list} does not solely define the supported values to the
\PName{key}. For each of the \PName{value}s, the
\PName{definition} of macro \Macro{\PName{command}} also is given. Usually,
\PName{definition} is just a numerical value. Nevertheless, other content is
possible and allowed. Currently, the only limitation is that
\PName{definition} has to be fully expandable and will be expanded during the
assignment.
\begin{Example}
  The sausage may be cut different. For example the cold cuts may stay uncut or
  will be cut roughly or may be cut thinly. This information should be stored
  in command \Macro{cuthow}.
\begin{lstcode}
  \FamilyNumericalKey{butcher}%
                     {saladcut}{cuthow}{%
                       {none}{none},{no}{none},{not}{none}%
                       {rough}{rough},%
                       {thin}{thin}%
                     }
\end{lstcode}
  Not cutting anything may be selected either by
\begin{lstcode}
  \FamilyOptions{butcher}{saladcut=none}
\end{lstcode}
  or
\begin{lstcode}
  \FamilyOptions{butcher}{saladcut=no}
\end{lstcode}
  or
\begin{lstcode}
  \FamilyOptions{butcher}{saladcut=not}
\end{lstcode}
  In all three cases \Macro{cuthow} would be defined with content
  \PValue{none}. It may be very useful to provide several values for the same
  result as shown in this example.

  Now, it's most likely, that the kind of cutting will not be printed, but
  should be evaluated later. In this case a textual definition would not be
  useful. If the key is defined like this:
\begin{lstcode}
  \FamilyNumericalKey{butcher}%
                     {saladcut}{cuthow}{%
                       {none}{0},{no}{0},{not}{0}%
                       {rough}{1},%
                       {thin}{2}%
                     }
\end{lstcode}
  then a condition like the following may be used:
\begin{lstcode}
  \ifcase\cuthow
    % no cut
  \or
    % rough cut
  \else
    % thin cut
  \fi
\end{lstcode}
\end{Example}
Internally, \Macro{FamilyNumericalKey} uses \Macro{FamilySetNumerical} as
\PName{action} of \Macro{DefineFamilyKey}. If a unknown value is assigned to
such a key, \Macro{FamilySetNumerical} will call \Macro{FamilyUnkownKeyValue}
with the arguments \PName{family}, \PName{key} and \PName{value}. This will
normally result in an error message about assigning an unknown value.
%
\EndIndex{Cmd}{FamilySetNumerical}%
\EndIndex{Cmd}{FamilyNumericalKey}%

\begin{Declaration}
  \Macro{FamilyCounterKey}\OParameter{family member}\Parameter{family}%
  \Parameter{key}\\
  \hphantom{\XMacro{FamilyCounterKey}}%
  \OParameter{default}\Parameter{\LaTeX{} counter}\\
  \Macro{FamilySetCounter}\Parameter{family}%
  \Parameter{key}\Parameter{\LaTeX{} counter}\Parameter{value}
\end{Declaration}
\BeginIndex{Cmd}{FamilyCounterKey}%
\BeginIndex{Cmd}{FamilySetCounter}%
Beside\ChangedAt{v3.12}{\Package{scrbase}} \Macro{FamilyNumercialKey} that
defines a macro to a numeric value depending on a symbolic value, there are
circumstances when a \PName{key} directly represents a \PName{\LaTeX{}
  counter}, that should be assigned directly to a numeric value. In those
cases, \Macro{FamilyCounterKey} can be used that internally will call
\Macro{FamilySetCounter}. A primary test of the \PName{value} argument is done
that only detects whether or not usage of \PName{value} as a number is
plausible. The assignment is done, only if this plausibility test is
successful. Nevertheless the assignment can still fail and result in a \TeX{}
error. But if the plausibility test fails already, this is signalled by
\Macro{FamilyKeyStateUnknownValue}.

If\ChangedAt{v3.15}{\Package{scrbase}} the value is omitted, the
\PName{default} is used instead. If there is no \PName{default}, the
\PName{key} can be used only with a value being defined.%
\EndIndex{Cmd}{FamilySetCounter}%
\EndIndex{Cmd}{FamilyCounterKey}%

\begin{Declaration}
  \Macro{FamilyCounterMacroKey}\OParameter{family member}\Parameter{family}%
  \Parameter{key}\\
  \hphantom{\XMacro{FamilyCounterMacroKey}}%
  \OParameter{default}\Parameter{macro}\\
  \Macro{FamilySetCounterMacro}\Parameter{family}%
  \Parameter{key}\Parameter{macro}\Parameter{value}%
\end{Declaration}
\BeginIndex{Cmd}{FamilyCounterMacroKey}%
\BeginIndex{Cmd}{FamilySetCounterMacro}%
These\ChangedAt{v3.12}{\Package{scrbase}} two commands differ from the
previously described \Macro{FamilyCounterKey} and \Macro{FamilySetCounter}
only by the fact, that they do not assign a \PName{value} to a \PName{\LaTeX
  counter}, but define a \Macro{macro} with the
\PName{value}.%
\EndIndex{Cmd}{FamilySetCounterMacro}%
\EndIndex{Cmd}{FamilyCounterMacroKey}%

\begin{Declaration}
  \Macro{FamilyLengthKey}\OParameter{family member}\Parameter{family}%
  \Parameter{key}\\
  \hphantom{\XMacro{FamilyLengthKey}}%
  \OParameter{default}\Parameter{length}\\
  \Macro{FamilySetLength}\Parameter{family}%
  \Parameter{key}\Parameter{length}\Parameter{value}\\
  \Macro{FamilyLengthMacroKey}\OParameter{family member}\Parameter{family}%
  \Parameter{key}\\
  \hphantom{\XMacro{FamilyLengthMacroKey}}%
  \OParameter{default}\Parameter{Makro}\\
  \Macro{FamilySetLengthMacro}\Parameter{family}%
  \Parameter{key}\Parameter{Makro}\Parameter{value}%
\end{Declaration}
\BeginIndex{Cmd}{FamilyLengthKey}%
\BeginIndex{Cmd}{FamilySetLength}%
\BeginIndex{Cmd}{FamilyLengthMacroKey}%
\BeginIndex{Cmd}{FamilySetLengthMacro}%
With\ChangedAt{v3.12}{\Package{scrbase}} \Macro{FamilyLengthKey} you can
define a \PName{key} that represents a \PName{length}. It does not matter
whether the \PName{length} is a \LaTeX{} length, a \TeX{} skip or a \TeX{}
dimension. Internally the \PName{length} will be set to the \PName{value}
using \Macro{FamilySetLength}. Thereby a primary test is used to decide,
whether or not it is plausible to assign \PName{length} to \PName{value}. The
assignment is done only if this plausibility test is successful. Nevertheless,
not all assignment errors can be recognised, so an inaccurate \PName{value}
can still result in \TeX{} error. Recognised errors however will be signalled
by \Macro{FamilyKeyStateUnknownValue}.

If\ChangedAt{v3.15}{\Package{scrbase}} the value is omitted,
the \PName{default} is used instead. If there is no \PName{default}, the
\PName{key} can be used only with a value being defined.

In difference to this, \Macro{FamilyLengthMacroKey} and
\Macro{FamilySetLengthMacro} do not assign \PName{value} to a \PName{length},
but define a \Macro{macro} with this
\PName{value}.%
\EndIndex{Cmd}{FamilySetLengthMacro}%
\EndIndex{Cmd}{FamilyLengthMacroKey}%
\EndIndex{Cmd}{FamilySetLength}%
\EndIndex{Cmd}{FamilyLengthKey}%

\begin{Declaration}
  \Macro{FamilyStringKey}\OParameter{family member}\Parameter{family}%
                         \Parameter{key}\\
  \hphantom{\XMacro{FamilyStringKey}}%
                         \OParameter{default}\Parameter{command}
\end{Declaration}
\BeginIndex{Cmd}{FamilyStringKey}%
This defines\ChangedAt{v3.08}{\Package{scrbase}} a \PName{key} that accepts
every value. The value will be stored into the given \Macro{command}. If there
is no optional argument for the \PName{default}, \Macro{FamilyStringKey} is
the same as:
\begin{quote}
\Macro{DefineFamilyKey}\OParameter{family member}\Parameter{family}%
\Parameter{key}\\
\hphantom{\Macro{DefineFamilyKey}}%
\PParameter{\Macro{def}\PName{command}\string{\#1\string}%
\Macro{FamilyKeyStateProcessed}}.
\end{quote}
If an optional argument \PName{default} is used, \Macro{FamilyStringKey}
is the same as:
\begin{quote}
\Macro{DefineFamilyKey}\OParameter{family member}\Parameter{family}%
\Parameter{key}\\
\hphantom{\Macro{DefineFamilyKey}}%
\OParameter{default}%
\PParameter{\Macro{def}\PName{command}\string{\#1\string}}.
\end{quote}
If \PName{command} is not been defined, an empty macro will be defined.
\begin{Example}
  By default an amount of 250\Unit{g} sausage salad should be produced. The
  amount should be configurable by an option. The wanted amount will be stored
  in the macro \Macro{saladweight}. The option should be named
  \PValue{saladweight}, too:
\begin{lstcode}
  \newcommand*{\saladweight}{250g}
  \FamilyStringKey{butcher}%
                  {saladweight}[250g]{\saladweight}
\end{lstcode}
  To switch back to the default weight after changing it, the user may simply
  use the option without weight:
\begin{lstcode}
  \FamilyOptions{butcher}{saladweight}
\end{lstcode}
  This may be done, because the default weight has been set as default at the
  definition of the option above.
\end{Example}
In this case there are not unknown values because all values are simply used
for a macro definition. Nevertheless, you should note that paragraph breaks
at the value assignment to the key are not allowed.
%
\EndIndex{Cmd}{FamilyStringKey}%


\begin{Declaration}
  \Macro{FamilyUnkownKeyValue}\Parameter{family}\Parameter{key}%
                              \Parameter{value}\Parameter{values list}%
\end{Declaration}
\BeginIndex{Cmd}{FamilyUnkownKeyValue}%
\BeginIndex{Cmd}{FamilyElseValues}%
The command \Macro{FamilyUnknownKeyValue} throws and error message about
unknown values assigned to a known key. The \PName{values list} is a comma
separated list of allowed values in the form:
\begin{flushleft}\vskip\dp\strutbox\begin{tabular}{l}
    `\PName{value}'\texttt{,} `\PName{value}' \dots
\end{tabular}\vskip\dp\strutbox\end{flushleft}
Currently\ChangedAt{v3.12}{\Package{scrbase}}, \PName{values list} is 
not used by \Package{scrbase}.
\begin{Example}
  Now, for the cold cuts, the choices should be cut or no-cut and in case of cut
  rough or thin. Rough should be the default for cutting.
\begin{lstcode}
  \@ifundefined{if@thincut}{%
    \expandafter
    \newif\csname if@thincut\endcsname}{}%
  \@ifundefined{if@coldcuts}{%
    \expandafter
    \newif\csname if@coldcuts\endcsname}{}
  \DefineFamilyKey{butcher}%
                  {coldcuts}[true]{%
    \FamilySetBool{butcher}{coldcuts}%
                           {@coldcuts}%
                           {#1}%
    \ifx\FamilyKeyState\FamilyKeyStateProcessed
      \@thincutfalse
    \else
      \ifstr{#1}{thin}{%
        \@coldcutstrue
        \@thincuttrue
        \FamilyKeyStateProcessed
      }{}%
    \fi
  }%
\end{lstcode}
  Let's have a look at the definition of \Option{butcher}:
  First of all, we try to set the boolean switch of cold cuts using
  \Macro{FamilySetBool}. After this command, we test whether or not
  \Macro{FamilyKeyState} signals the success of the command with state
  \Macro{FamilyKeyStateProcessed}. If so, only the thin cut has to be
  deactivated. 

  In the other case, the value will be tested to be equal to \PValue{thin}. In
  that case, cold cuts and thin cut are activated and the state will be
  switched to \Macro{FamilyKeyStateProcessed}. If the last test failed also,
  the failure state of \Macro{FamilySetBool} is still valid at the end of the
  execution.

  Command \Macro{ifstr} is used for the thin test. It is
  described on \autopageref{desc:scrbase.cmd.ifstr} in
  \autoref{sec:scrbase.if}.
\end{Example}
%
\EndIndex{Cmd}{FamilyUnkownKeyValue}%

\begin{Declaration}
  \Macro{FamilyElseValues}
\end{Declaration}
\BeginIndex{Cmd}{FamilyElseValues}%
With former releases\ChangedAt{v3.12}{\Package{scrbase}} of \Package{scrbase},
additional allowed values reported by \Macro{FamilyUnknownKeyValue} can be
set re-defining \Macro{FamilyElseValues} in the form:
\begin{flushleft}\vskip\dp\strutbox\begin{tabular}{l}
    \texttt{,} `\PName{value}'\texttt{,} `\PName{value}' \dots
\end{tabular}\vskip\dp\strutbox\end{flushleft}
Since release~3.12 \Macro{FamilyUnknownValue} does not report errors itself,
but signals them using \Macro{FamilyKeyState}. Therefore,
\Macro{FamilyElseValues} became deprecated. Nevertheless, its former usage is
recognised by \Package{scrbase} and results in a code change demand message.%
\EndIndex{Cmd}{FamilyElseValues}%


\section{Conditional Execution}
\seclabel{if}

The package \Package{scrbase} provides several commands for conditional
execution. other than the \TeX{} syntax of conditionals, e.\,g.,
% Umbruchkorrektur
\begin{lstcode}[belowskip=\dp\strutbox]
  \iftrue
    ...
  \else
    ...
  \fi
\end{lstcode}
yet the \LaTeX{} syntax also known from \LaTeX{} commands like
\Macro{IfFileExists}, \Macro{@ifundefined}, \Macro{@ifpackageloaded}, and many
others, is used. Nevertheless, some package authors prefer to use the \TeX{}
syntax even for users at the \LaTeX{} interface level that could inevitably
lead to naming conflicts with the \Package{scrbase} conditionals. In fact, the
conditionals of \Package{scrbase} are very basic. Because of this
\Package{scrbase} firstly defines these conditionals as internal commands with
prefix \Macro{scr@}. Additional user commands without this prefix are
subsequently defined. But the definition of the user commands may be
suppressed with option \Option{internalonly} (see
\autoref{sec:scrbase.loadit}, \autopageref{desc:scrbase.option.internalonly}).

Authors of packages and classes should use the internal commands as
\KOMAScript{} itself does. Nevertheless, for completeness the user commands
are described separately.


\begin{Declaration}
  \Macro{scr@ifundefinedorrelax}%
  \Parameter{name}\Parameter{then instructions}\Parameter{else instructions}\\
  \Macro{ifundefinedorrelax}%
  \Parameter{name}\Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{scr@ifundefinedorrelax}%
\BeginIndex{Cmd}{ifundefinedorrelax}%
This command has almost the same functionality as \Macro{@ifundefined} from
the \LaTeX{} kernel (see \cite{latex:source2e}). So the \PName{then
  instructions} will be executed if \PName{name} is the name of a command
that is currently either not defined or \Macro{relax}. Otherwise, the
\PName{else instructions} will be executed. In contrast to
\Macro{@ifundefined}, \Macro{\PName{name}} is not defined to be \Macro{relax}
in the event it was not defined before. Moreover, using \eTeX{} this case will
not consume any hash memory.%
%
\EndIndex{Cmd}{ifundefinedorrelax}%
\EndIndex{Cmd}{scr@ifundefinedorrelax}%


\begin{Declaration}
  \Macro{scr@ifpdftex}%
  \Parameter{then instructions}\Parameter{else instructions}\\
  \Macro{ifpdftex}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{scr@ifpdftex}%
\BeginIndex{Cmd}{ifpdftex}%
If pdf\TeX{} has been used, the \PName{then instructions} will be executed,
otherwise the \PName{else instructions}. Whether or not a PDF-file is
generated does not matter, and the pdf\TeX{} test is rarely useful. In
general, test for the desired command instead (see previous
\Macro{scr@ifundefinedorrelax} and \Macro{ifundefinedorrelax}).
%
\EndIndex{Cmd}{ifpdftex}%
\EndIndex{Cmd}{scr@ifpdftex}%


\begin{Declaration}
  \Macro{scr@ifVTeX}%
  \Parameter{then instructions}\Parameter{else instructions}\\
  \Macro{ifVTeX}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{scr@ifVTeX}%
\BeginIndex{Cmd}{ifVTeX}%
If V\TeX{} has been used, the \PName{then instructions} will be executed,
otherwise the \PName{else instructions}. This test is seldom useful. Test for
the desired command instead (see previous \Macro{scr@ifundefinedorrelax} and
\Macro{ifundefinedorrelax}).
%
\EndIndex{Cmd}{ifVTeX}%
\EndIndex{Cmd}{scr@ifVTeX}%


\begin{Declaration}
  \Macro{scr@ifpdfoutput}%
  \Parameter{then instructions}\Parameter{else instructions}\\
  \Macro{ifpdfoutput}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{scr@ifpdfoutput}%
\BeginIndex{Cmd}{ifpdfoutput}%
When generating a PDF-file the \PName{then instructions} will be executed,
otherwise the \PName{else instructions}. Whether pdf\TeX{} or V\TeX{} or
another \TeX{} engine is used to generate the PDF-file does not matter.
%
\EndIndex{Cmd}{ifpdfoutput}%
\EndIndex{Cmd}{scr@ifpdfoutput}%


\begin{Declaration}
  \Macro{scr@ifpsoutput}%
  \Parameter{then instructions}\Parameter{else instructions}\\
  \Macro{ifpsoutput}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{scr@ifpsoutput}%
\BeginIndex{Cmd}{ifpsoutput}%
When generating a PostScript-file the \PName{then instructions} will be
executed, otherwise the \PName{else instructions}. V\TeX{} provides direct
PostScript generation that will be recognised here. If V\TeX{} is not used,
but a switch \Macro{if@dvips} has been defined, the decision depends on that
switch. \KOMAScript{} provides \Macro{if@dvips} in \Package{typearea}.
%
\EndIndex{Cmd}{ifpsoutput}%
\EndIndex{Cmd}{scr@ifpsoutput}%


\begin{Declaration}
  \Macro{scr@ifdvioutput}%
  \Parameter{then instructions}\Parameter{else instructions}\\
  \Macro{ifdvioutput}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{scr@ifdvioutput}%
\BeginIndex{Cmd}{ifdvioutput}%
When generating a DVI-file the \PName{then instructions} will be executed,
otherwise the \PName{else instructions}. If neither a direct PDF-file
generation nor a direct PostScript-file generation has been detected, DVI-file
generation is assumed.
%
\EndIndex{Cmd}{ifdvioutput}%
\EndIndex{Cmd}{scr@ifdvioutput}%


\begin{Declaration}
  \Macro{ifnotundefined}\Parameter{name}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifnotundefined}%
\eTeX{} will be used to test, whether or not a command with the given
\PName{name} has already been defined. The \PName{then instructions} will be
executed if the command is defined, otherwise the \PName{else
  instructions}. There is no corresponding internal command.
%
\EndIndex{Cmd}{ifnotundefined}%


\begin{Declaration}
  \Macro{ifstr}\Parameter{string}\Parameter{string}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifstr}%
Both \PName{string} arguments are expanded and afterwards compared. If the
expansions are the same, the \PName{then instructions} will be executed,
otherwise the \PName{else instructions}. There is no corresponding internal
command.
%
\EndIndex{Cmd}{ifstr}%

\begin{Declaration}
  \Macro{ifstrstart}\Parameter{string}\Parameter{string}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifstrstart}%
Both\ChangedAt{v3.12}{\Package{scrbase}} \PName{string} arguments are
expanded and afterwards compared. If aside from white spaces the first string
starts with the second one, the \PName{then instructions} will be executed,
otherwise the \PName{else instructions}. The command is not completely
expandable and there is no corresponding internal command.%
\EndIndex{Cmd}{ifstrstart}%

\begin{Declaration}
  \Macro{ifisdimen}\Parameter{code}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifisdimen}%
If\ChangedAt{v3.12}{\Package{scrbase}} the expansion of\PName{code} results in
a \Macro{dimen}, which is also known as \TeX{} length register, the
\PName{then instructions} will be executed, otherwise the \PName{else
  instructions}. The command is not completely expandable and there is no
corresponding internal command.%
\EndIndex{Cmd}{ifisdimen}%

\begin{Declaration}
  \Macro{ifisdimension}\Parameter{code}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifisdimension}%
If\ChangedAt{v3.12}{\Package{scrbase}} \PName{code} expands to something with
the syntax of the value of a length, the \PName{then instructions} will be
executed, otherwise the \PName{else instructions}. Please
note\textnote{Attention!} that currently an invalid unit will result in an
error message. The command is not completely expandable and there is no
corresponding internal command.%
\EndIndex{Cmd}{ifisdimension}%

\begin{Declaration}
  \Macro{ifisdimexpr}\Parameter{code}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifisdimexpr}%
If\ChangedAt{v3.12}{\Package{scrbase}} the expansion of\PName{code} results in
a \Macro{dimexpr}, which is also known as \TeX{} length expression, the
\PName{then instructions} will be executed, otherwise the \PName{else
  instructions}. Note\textnote{Attention!} that illegal expressions will
result in error messages. The command is not completely expandable and there
is no corresponding internal command.%
\EndIndex{Cmd}{ifisdimexpr}%

\begin{Declaration}
  \Macro{ifisskip}\Parameter{code}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifisskip}%
If\ChangedAt{v3.12}{\Package{scrbase}} the expansion of\PName{code} results in
a \Macro{skip}, which is also known as \TeX{} distance register, the
\PName{then instructions} will be executed, otherwise the \PName{else
  instructions}. The command is not completely expandable and there is no
corresponding internal command.%
\EndIndex{Cmd}{ifisskip}%

\begin{Declaration}
  \Macro{ifisglue}\Parameter{code}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifisglue}%
If\ChangedAt{v3.12}{\Package{scrbase}} \PName{code} expands to something with
the syntax of the value of a skip, the \PName{then instructions} will be
executed, otherwise the \PName{else instructions}. Please
note\textnote{Attention!} that currently an invalid unit will result in an
error message. The command is not completely expandable and there is no
corresponding internal command.%
\EndIndex{Cmd}{ifisglue}%

\begin{Declaration}
  \Macro{ifisglueexpr}\Parameter{code}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifisglueexpr}%
If\ChangedAt{v3.12}{\Package{scrbase}} the expansion of\PName{code} results in
a \Macro{glueexpr}, which is also known as \TeX{} distance expression, the
\PName{then instructions} will be executed, otherwise the \PName{else
  instructions}. Note,\textnote{Attention!} that illegal expressions will
result in error messages. The command is not completely expandable and there
is no corresponding internal command.%
\EndIndex{Cmd}{ifisglueexpr}%

\begin{Declaration}
  \Macro{ifiscount}\Parameter{code}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifiscount}%
If\ChangedAt{v3.12}{\Package{scrbase}} the expansion of\PName{code} results in
a \Macro{count}, which is also known as \TeX{} counter register, the
\PName{then instructions} will be executed, otherwise the \PName{else
  instructions}. The command is not completely expandable and there is no
corresponding internal command. For test with \LaTeX{} counters, see
\Macro{ifiscounter}.%
\EndIndex{Cmd}{ifiscount}%

\begin{Declaration}
  \Macro{ifisinteger}\Parameter{code}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifisinteger}%
If\ChangedAt{v3.12}{\Package{scrbase}} \PName{code} expands to something with
the syntax of the value of a counter, which would be a negative or positive
integer, the \PName{then instructions} will be executed, otherwise the
\PName{else instructions}. The command is not completely expandable and there
is no corresponding internal command.%
\EndIndex{Cmd}{ifisinteger}%

\begin{Declaration}
  \Macro{ifisnumexpr}\Parameter{code}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifisnumexpr}%
If\ChangedAt{v3.12}{\Package{scrbase}} the expansion of\PName{code} results in
a \Macro{numexpr}, which is also known as \TeX{} number expression, the
\PName{then instructions} will be executed, otherwise the \PName{else
  instructions}. Note\textnote{Attention!} that illegal expressions will
result in error messages. The command is not completely expandable and there
is no corresponding internal command.%
\EndIndex{Cmd}{ifisnumexpr}%

\begin{Declaration}
  \Macro{ifiscounter}\Parameter{counter}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifiscounter}%
If\ChangedAt{v3.12}{\Package{scrbase}} \PName{counter} is an already defined
\LaTeX{} counter, the \PName{then instructions} will be executed, otherwise
the \PName{else instructions}.  The command is not completely expandable and
there is no corresponding internal command.%
\EndIndex{Cmd}{ifiscounter}%

\begin{Declaration}
  \Macro{ifnumber}\Parameter{string}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifnumber}%
Note that this does not compare numbers.  The \PName{then instructions} will
be executed if the one step expansion of \PName{string} consists of digits
only. Otherwise the \PName{else instructions} will be used. There is no
corresponding internal command.
%
\EndIndex{Cmd}{ifnumber}%


\begin{Declaration}
  \Macro{ifdimen}\Parameter{string}%
  \Parameter{then instructions}\Parameter{else instructions}
\end{Declaration}
\BeginIndex{Cmd}{ifdimen}%
Note that this does not compare dimensions. The \PName{then instructions} will
be executed, if the one step expansion of \PName{string} consists of digits
and a valid unit of length. Otherwise, the \PName{else instructions} will be
used. There is no corresponding internal command.
%
\EndIndex{Cmd}{ifdimen}%


\begin{Declaration}
  \Macro{if@atdocument}\ \PName{the instructions} 
  \Macro{else}\ \PName{else instructions} \Macro{fi}
\end{Declaration}
\BeginIndex{Cmd}{if@atdocument}%
This command exists intentionally as internal command only. In the document
preamble \Macro{if@atdocument} is same as \Macro{iffalse}. After
\Macro{begin}\PParameter{document} it's the same as \Macro{iftrue}. Authors of
classes and packages may use this if a command should work somehow different
depending on whether it has been used in the preamble or inside the documents
body. Please note\textnote{Attention!} that this is a condition in \TeX{}
syntax not in \LaTeX{} syntax!
%
\EndIndex{Cmd}{if@atdocument}%


\section{Definition of Language-Dependent Terms}
\seclabel{languageSupport}
\BeginIndex{}{language>definition}
\index{language>dependent terms|see{language definition}}
\index{terms>language-dependent|see{language definition}}

Normally, one has to change or define language-dependent terms like
\Macro{captionsenglish} in such a way that, in addition to the available terms,
the new or redefined terms are defined. This is made more difficult by the
fact that some packages like \Package{german}\IndexPackage{german} or
\Package{ngerman}\IndexPackage{ngerman} redefine those settings when the
packages are loaded. These definitions unfortunately occur in such a manner as
to destroy all previous private settings. That is also the reason why it makes
sense to delay changes with \Macro{AtBeginDocument} until
\Macro{begin}\PParameter{document}; that is, after package loading is
completed. The user can also use \Macro{AtBeginDocument} or redefine the
language-dependent terms after \Macro{begin}\PParameter{document}; that is,
not put them in the preamble at all. The package \Package{scrbase}
provides some additional commands for defining language-dependent terms.


\begin{Declaration}
  \Macro{defcaptionname}%
    \Parameter{language list}\Parameter{term}\Parameter{definition}\\
  \Macro{providecaptionname}%
    \Parameter{language list}\Parameter{term}\Parameter{definition}\\
  \Macro{newcaptionname}%
    \Parameter{language list}\Parameter{term}\Parameter{definition}\\
  \Macro{renewcaptionname}%
    \Parameter{language list}\Parameter{term}\Parameter{definition}\\
  \Macro{defcaptionname*}%
    \Parameter{language list}\Parameter{term}\Parameter{definition}\\
  \Macro{providecaptionname*}%
    \Parameter{language list}\Parameter{term}\Parameter{definition}\\
  \Macro{newcaptionname*}%
    \Parameter{language list}\Parameter{term}\Parameter{definition}\\
  \Macro{renewcaptionname*}%
    \Parameter{language list}\Parameter{term}\Parameter{definition}
\end{Declaration}
\BeginIndex{Cmd}{defcaptionname}%
\BeginIndex{Cmd}{providecaptionname}%
\BeginIndex{Cmd}{newcaptionname}%
\BeginIndex{Cmd}{renewcaptionname}%
Using one of these commands, the user can assign a \PName{definition} for a
particular language to a \PName{term}. Several languages can be concatenated
with comma to a \PName{language list}.  The \PName{term} is always a
macro. The commands differ depending on whether a given language or a
\PName{term} within a given language are already defined or not at the
time the command is called.

If a language is not defined, then \Macro{providecaptionname} does
nothing other than write a message in the log file. This happens only once
for each language.  If a language is defined, but \PName{term} is not yet
defined for it, then it will be defined using \PName{definition}.  The
\PName{term} will not be redefined if the language already has such a
definition; instead, an appropriate message is written to the log file.

The command \Macro{newcaptionname} has a slightly different behaviour.  If a
language is not yet defined, then a new language command will be
created and a message written to the log file. For language
\PValue{USenglish}, for example, this would be the language command
\Macro{captionsUSenglish}. If \PName{term} is not yet defined in a
language, then it will be defined using \PName{definition}.  If
\PName{term} already exists in a language, then this results in an error
message.

The command \Macro{renewcaptionname} again behaves differently. It requires an
existing definition of \PName{term} in the languages.  If neither
a language nor \PName{term} exist or \PName{term} is unknown in a
defined language, then an error message is given. Otherwise, the
\PName{term} for the language will be redefined according to
\PName{definition}.

The\ChangedAt{v3.12}{\Package{scrbase}} command \Macro{defcaptionname} always
defines the \PName{term}. So previous definitions of \PName{term} for the
given \PName{language} will be overwritten. You may use this command even for
undefined languages.

\KOMAScript{} employs \Macro{providecaptionname} in order to define the
commands in \autoref{sec:scrlttr2-experts.languages}.

\begin{Example}
  If you prefer ``fig.'' instead of ``figure'' in \PValue{USenglish}, you may
  achieve this using:
\begin{lstcode}
  \renewcaptionname{USenglish}{\figurename}{fig.}
\end{lstcode}
  If you want the same change not only in \PValue{USenglish} but also in
  \PValue{UKenglish}, you do not need an additional:
\begin{lstcode}
  \renewcaptionname{UKenglish}{\figurename}{fig.}
\end{lstcode}
  but can simply extend the \PName{language list}:
\begin{lstcode}
  \renewcaptionname{USenglish,UKenglish}{\figurename}{fig.}
\end{lstcode}
  You can extend the \PName{language list} in the same manner by
  \PValue{american}, \PValue{australian}, \PValue{british}, \PValue{canadian},
  and \PValue{newzealand}.
\end{Example}
  
Since \KOMAScript~3.12\ChangedAt{v3.12}{\Package{scrbase}} you do not need to
delay the definition or redefinition until \Macro{begin}\PParameter{document}
using \Macro{AtBeginDocument} any longer because \Package{scrbase} does the
delay automatically for (re)definitions in the document's
preamble. Additionally, \Package{scrbase} tests if a redefinition should be
made in \Macro{extras\PName{language}} instead of
\Macro{captions\PName{language}} and does so automatically. The new star
variants of the commands always use \Macro{extras\PName{language}}. So
redefinition of language dependent terms for packages like \Package{hyperref}
that use \Macro{extras\PName{language}} should work as expected by the user.

Language dependent terms usually defined by classes and language
packages are listed and described in \autoref{tab:scrbase.commonNames}.

\begin{desclist}
  \renewcommand*{\abovecaptionskipcorrection}{-\normalbaselineskip}%
  \desccaption[{%
    Overview of usual language dependent terms%
  }]{%
    Overview of language dependent terms of usual language packages%
    \label{tab:scrbase.commonNames}%
  }{%
    Overview of usual language dependent terms
    (\emph{continuation})%
  }%
  \entry{\Macro{abstractname}}{%
    heading of the abstract%
    \IndexCmd{abstractname}%
  }%
  \entry{\Macro{alsoname}}{%
    ``see also'' in additional cross references of the index%
    \IndexCmd{alsoname}%
  }%
  \entry{\Macro{appendixname}}{%
    ``appendix'' in the heading of an appendix chapter%
    \IndexCmd{appendixname}%
  }%
  \entry{\Macro{bibname}}{%
    heading of the bibliography%
    \IndexCmd{bibname}%
  }%
  \entry{\Macro{ccname}}{%
    prefix heading for the distribution list of a letter%
    \IndexCmd{ccname}%
  }%
  \entry{\Macro{chaptername}}{%
    ``chapter'' in the heading of a chapter%
    \IndexCmd{chaptername}%
  }%
  \entry{\Macro{contentsname}}{%
    heading of the table of contents%
    \IndexCmd{contentsname}%
  }%
  \entry{\Macro{enclname}}{%
    prefix heading for the enclosure of a letter%
    \IndexCmd{enclname}%
  }%
  \entry{\Macro{figurename}}{%
    prefix heading of figure captions%
    \IndexCmd{figurename}%
  }%
  \entry{\Macro{glossaryname}}{%
    heading of the glossary%
    \IndexCmd{glossaryname}%
  }%
  \entry{\Macro{headtoname}}{%
    ``to'' in header of letter pages%
    \IndexCmd{headtoname}%
  }%
  \entry{\Macro{indexname}}{%
    heading of the index%
    \IndexCmd{indexname}%
  }%
  \entry{\Macro{listfigurename}}{%
    heading of the list of figures%
    \IndexCmd{listfigurename}%
  }%
  \entry{\Macro{listtablename}}{%
    heading of the list of tables%
    \IndexCmd{listtablename}%
  }%
  \entry{\Macro{pagename}}{%
    ``page'' in the pagination of letters%
    \IndexCmd{pagename}%
  }%
  \entry{\Macro{partname}}{%
    ``part'' in the heading of a part%
    \IndexCmd{partname}%
  }%
  \entry{\Macro{prefacename}}{%
    heading of the preface%
    \IndexCmd{prefacename}%
  }%
  \entry{\Macro{proofname}}{%
    prefix heading of mathematical proofs%
    \IndexCmd{proofname}%
  }%
  \entry{\Macro{refname}}{%
    heading of the list of references%
    \IndexCmd{refname}%
  }%
  \entry{\Macro{seename}}{%
    ``see'' in cross references of the index%
    \IndexCmd{seename}%
  }%
  \entry{\Macro{tablename}}{%
    prefix heading at table captions%
    \IndexCmd{tablename}%
  }%
\end{desclist}
%
\EndIndex{Cmd}{providecaptionname}%
\EndIndex{Cmd}{newcaptionname}%
\EndIndex{Cmd}{renewcaptionname}%
\EndIndex{Cmd}{defcaptionname}%
%
\EndIndex{}{language>definition}


\section{Identification of \KOMAScript}
\seclabel{identify}

Package \Package{scrbase} may be used independent of \KOMAScript{} with
other packages and classes. Nevertheless, it is a \KOMAScript{} package. For
this, \Package{scrbase} also provides commands to identify \KOMAScript{} and
to identify itself as a \KOMAScript{} package.

\begin{Declaration}
  \Macro{KOMAScript}
\end{Declaration}
\BeginIndex{Cmd}{KOMAScript}%
This command only sets the word ``\KOMAScript'' with sans-serif font and
a little bit tracking for the capitals. By the way: All \KOMAScript{} classes
and packages define this command, if it has not been defined already. The
definition is robust using \Macro{DeclareRobustCommand}.
%
\EndIndex{Cmd}{KOMAScript}


\begin{Declaration}
  \Macro{KOMAScriptVersion}
\end{Declaration}
\BeginIndex{Cmd}{KOMAScriptVersion}%
\KOMAScript{} defines the main version of \KOMAScript{} in this command. It
has the form ``\PName{date} \PName{version} \texttt{KOMA-Script}''. This main
version is same for all \KOMAScript{} classes and the \KOMAScript{} packages
that are essential for the classes. Because of this, it may be inquired after
loading \Package{scrbase}, too. For example, this document has been made using
\KOMAScript{} version ``\KOMAScriptVersion''.
%
\EndIndex{Cmd}{KOMAScriptVersion}%


\section{Extension of the \LaTeX{} Kernel}
\seclabel{latexkernel}

Sometimes the \LaTeX{} kernel itself provides commands, but lacks other,
similar commands that would often be useful, too. Some of those commands for
authors of packages and classes are provided by \Package{scrbase}.

\begin{Declaration}
  \Macro{ClassInfoNoLine}\Parameter{class name}\Parameter{information}\\
  \Macro{PackageInfoNoLine}\Parameter{package name}\Parameter{information}%
\end{Declaration}%
\BeginIndex{Cmd}{PackageInfoNoLine}%
\BeginIndex{Cmd}{ClassInfoNoLine}%
For authors of classes and package the \LaTeX{} kernel already provides
commands like \Macro{ClassInfo} and \Macro{PackageInfo} to write information.
together with the current line number, into the log-file. Besides
\Macro{PackageWarning} and \Macro{ClassWarning} to throw warning messages with
line numbers, it also provides \Macro{PackageWarningNoLine} and
\Macro{ClassWarningNoLine} for warning messages without line
numbers. Nevertheless, the commands \Macro{ClassInfoNoLine} and
\Macro{PackageInfoNoLine} for writing information without line numbers into the
log-file are missing. Package \Package{scrbase} provides them.
%
\EndIndex{Cmd}{ClassInfoNoLine}%
\EndIndex{Cmd}{PackageInfoNoLine}


\begin{Declaration}
  \Macro{l@addto@macro}\Parameter{command}\Parameter{extension}%
\end{Declaration}%
\BeginIndex{Cmd}{l@addto@macro}%
The \LaTeX{} kernel already provides an internal command \Macro{g@addto@macro}
to extend the definition of macro \Macro{command} by \PName{extension}
globally. This may be used only for macros that have no
arguments. Nevertheless, sometimes a command like this, that works locally to
a group instead of globally, could be useful. Package \Package{scrbase}
provides such a command with \Macro{l@addto@macro}. An alternative may be
usage of package \Package{etoolbox}\IndexPackage{etoolbox}, which provides
several of such commands for different purposes (see \cite{package:etoolbox}).
%
\EndIndex{Cmd}{l@addto@macro}


\section{Extension of the Mathematical Features of \eTeX}
\seclabel{etex}

\eTeX{}, that is meanwhile used by \LaTeX{} and needed by \KOMAScript{},
provided with \Macro{numexpr}\IndexCmd{numexpr}, an extended feature for
calculation of simple arithmetic with \TeX{} counters and
integers. The four basic arithmetic operations and brackets are
supported. Correct rounding is done while division. Sometimes additional
operators would be useful.

\begin{Declaration}
  \Macro{XdivY}\Parameter{dividend}\Parameter{divisor}\\
  \Macro{XmodY}\Parameter{dividend}\Parameter{divisor}%
\end{Declaration}%
\BeginIndex{Cmd}{XdivY}%
\BeginIndex{Cmd}{XmodY}%
Having a division with remainder command\ChangedAt{v3.05a}{\Package{scrbase}}
\Macro{XdivY} gives the value of the integer quotient, with command
\Macro{XmodY} giving the value of the remainder. This kind of division is
defined:
\[
\textit{dividend} = \textit{divisor} \cdot
\textit{integer quotient} + \textit{remainder}
\]
with \textit{dividend} and \textit{remainder} are integer, \textit{remainder}
is greater or equal to \textit{divisor}, and \textit{divisor} is a natural
number greater than 0.

The value may be used for assignment to a counter or directly in the
expression of \Macro{numexpr}. For output the value as an Arabic number has
to be prefixed by \Macro{the}.%
%
\EndIndex{Cmd}{XmodY}%
\EndIndex{Cmd}{XdivY}%
%
\EndIndex{Package}{scrbase}%

\endinput

%%% Local Variables:
%%% mode: latex
%%% mode: flyspell
%%% ispell-local-dictionary: "en_GB"
%%% coding: us-ascii
%%% TeX-master: "../guide.tex"
%%% End:
