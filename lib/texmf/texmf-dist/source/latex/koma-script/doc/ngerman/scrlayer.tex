% ======================================================================
% scrlayer.tex
% Copyright (c) Markus Kohm, 2013-2015
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX 
% version 2005/12/01 or later and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrlayer.tex
% Copyright (c) Markus Kohm, 2013-2015
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3c, verteilt und/oder veraendert werden.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3c ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 oder spaeter und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
% 
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
%
% Chapter about scrlayer of the KOMA-Script guide
% Maintained by Markus Kohm
%
% ----------------------------------------------------------------------
%
% Kapitel über scrlayer in der KOMA-Script-Anleitung
% Verwaltet von Markus Kohm
%
% ============================================================================

\KOMAProvidesFile{scrlayer.tex}%
                 [$Date: 2015-11-06 10:16:26 +0100 (Fri, 06 Nov 2015) $
                  KOMA-Script guide (chapter:scrlayer)]

\chapter[{Definition von Ebenen und Seitenstilen mit \Package{scrlayer}}]
  {Definition\ChangedAt{v3.12}{\Package{scrlayer}} von Ebenen und Seitenstilen
    mit \Package{scrlayer}}
\labelbase{scrlayer}

\BeginIndex{Package}{scrlayer}%
\BeginIndex{}{Ebenen}%
Anwender von Grafikprogrammen sind mit dem Modell der Ebenen für eine Seite
bereits vertraut. \LaTeX{} selbst ist ein solches Modell jedoch eher
fremd. Dennoch gibt es bereits einige Pakete wie \Package{eso-pic} oder
\Package{textpos}, mit denen bereits eine Art Hintergrund- oder
Vor\-der\-grund\-ebe\-ne in \LaTeX{} verfügbar gemacht wurden. Das Paket
\Package{scrlayer} ist ein weiteres Paket, das solche Hintergrund- und
Vordergrundebenen zur Verfügung stellt. Im Unterschied zu den anderen
genannten Paketen sind die Ebenen bei \Package{scrlayer} jedoch Teil des
Seitenstils. Dadurch ist eine einfache Umschaltung zwischen der Verwendung
unterschiedlicher Ebenen durch die Umschaltung des Seitenstils möglich.

Um dies zu erreichen, stellt das Paket auf unterer Stufe zusätzlich eine
Schnittstelle zur Definition von Seitenstilen, die auf einem Stapel oder einer
Liste von Ebenen beruhen, zum Hinzufügen von Ebenen wahlweise am Anfang oder
Ende einer solchen Liste von Ebenen oder unmittelbar vor oder hinter einer
anderen Ebene in einer solchen Liste, zum Löschen einer Ebene aus einer
solchen Liste und zum Löschen aller Dubletten einer Ebene aus einer solchen
Liste bereit. Oder kurz und verständlich gesagt: Die Seitenstil-Schnittstelle
von \Package{scrlayer} stellt Befehle bereit, um einen Seitenstil, der auf
einer Liste von Ebenen basiert, zu definieren und diese Ebenenliste zu
verwalten.

Nichtsdestoweniger wird die direkte Verwendung der Ebenen nur erfahrenen
Anwendern empfohlen. Schnittstellen für Anfänger und durchschnittliche
Anwender werden als zusätzliche Pakete angeboten, die dann ihrerseits
\Package{scrlayer} laden. Siehe hierzu \autoref{cha:scrlayer-scrpage} in
\autoref{part:forAuthors} diese\iffree{r Anleitung}{s Buches}.


\section{Hinweis zum Entwicklungsstand}
\seclabel{draft}

Die Entwicklung dieses Pakets ist noch nicht abgeschlossen. Teile des Pakets
sind auch noch als experimentell einzustufen. Daher können sich in Zukunft
insbesondere die internen Funktionalitäten und Funktionsweisen noch ändern. Es
ist auch noch mit Erweiterungen zu rechnen. Wegen dieses noch nicht
abgeschlossenen Entwicklungsstandes sollte der Leser auch keine abgeschlossene
Anleitung erwarten. Dennoch gibt diese Anleitung, die sich vor allem an
erfahrene Anwender und Entwickler richtet, den aktuellen Entwicklungsstand der
Teile von \Package{scrlayer} wieder, die als zur Verwendung freigegeben
eingestuft sind. Dinge, die hier nicht dokumentiert sind, sollten allenfalls
zu Testzwecken Verwendung finden.

\LoadCommon{0} % \section{Frühe oder späte Optionenwahl}

\section{Einige grundlegende Informationen}
\seclabel{generic.information}

Das Paket benötigt einige grundlegende Informationen über die
verwendete Klasse. Autoren von Klassen können \Package{scrlayer} helfen, indem
sie entsprechende Angaben machen. Anderenfalls versucht das Paket diese
Informationen selbst zu ermitteln. Das funktioniert beispielsweise für die
Standardklassen oder für die \KOMAScript-Klassen. Mit anderen Klassen kann es
funktionieren oder auch ganz oder teilweise fehlschlagen.

Dieser Abschnitt beschreibt einige der Informationen, die Autoren von Klassen
bereitstellen können. Anwender sollten sich im Normalfall nicht darum zu
kümmern brauchen.

\begin{Declaration}
  \Macro{if@chapter}\ \PName{Dann-Code} \Macro{else}\ \PName{Sonst-Code}
  \Macro{fi}
\end{Declaration}
\BeginIndex{Cmd}{if@chapter}%
Wenn \Macro{if@chapter} definiert ist und \Macro{iftrue}\IndexCmd{iftrue}
entspricht, berücksichtigt \Package{scrlayer} bei seiner Arbeit die
Kapitel-Ebene beispielsweise bei Verwendung von Option \Option{automark}. Wenn
es definiert ist, aber nicht \Macro{iftrue} entspricht, behandelt
\Package{scrlayer} nur die Ebenen der Befehle \Macro{part}, \Macro{section},
\Macro{subsection}, \Macro{sub\dots subsection}, \Macro{paragraph},
\Macro{subparagraph}, \Macro{sub\dots subparagraph}. Wenn das Makro nicht
definiert ist, macht \Package{scrlayer} die Frage, ob auch die Kapitel-Ebene
zu behandeln ist, an der Anweisung \Macro{chapter} fest. Ist diese Anweisung
definiert und entspricht sie nicht \Macro{relax}, dann definiert
\Package{scrlayer} das Makro \Macro{if@chapter} selbst als Synonym für
\Macro{iftrue}. Anderenfalls definiert es \Macro{if@chapter} als Synonym für
\Macro{iffalse}\IndexCmd{iffalse}.%
%
\EndIndex{Cmd}{if@chapter}%

\begin{Declaration}
  \Macro{if@mainmatter}\ \PName{Dann-Code} \Macro{else}\ \PName{Sonst-Code}
  \Macro{fi}
\end{Declaration}
\BeginIndex{Cmd}{if@mainmatter}%
Klassen wie \Class{book} oder \Class{scrbook} bieten
\Macro{frontmatter}\IndexCmd{frontmatter},
\Macro{mainmatter}\IndexCmd{mainmatter} und
\Macro{backmatter}\IndexCmd{backmatter}, um zwischen Vorderteil, Hauptteil und
Endteil eines Buches umschalten zu können. In der Regel verwenden diese
Klassen intern \Macro{if@mainmatter}, um entscheiden zu können, ob gerade im
Hauptteil des Dokuments gearbeitet wird oder nicht. Klassen wie \Class{report}
oder \Class{article} haben kein \Macro{frontmatter}, \Macro{mainmatter} oder
\Macro{backmatter} und deshalb auch kein \Macro{if@mainmatter}. Stattdessen
gehen sie davon aus, dass es nur einen Hauptteil gibt.

Für \Package{scrlayer} ist es aber einfacher, nicht ständig erneut die
Existenz und Verwendung der Umschaltanweisungen zu erkennen und damit zu
entscheiden, ob nun gerade im Hauptteil gearbeitet wird oder nicht, sondern
stattdessen auch bei Klassen wie \Class{report} oder \Class{article} mit
\Macro{if@mainmatter} zu arbeiten. Das sollte bei den genannten Klassen dann
schlicht \Macro{iftrue}\IndexCmd{iftrue} entsprechen. Wenn also
\Macro{if@mainmatter} nicht definiert ist, dann definiert \Package{scrlayer}
es als Synonym für \Macro{iftrue}.

Einige Klassen definieren jedoch \Macro{frontmatter},
\Macro{mainmatter} oder \Macro{backmatter} und trotzdem kein
\Macro{if@mainmatter}. In diesem Fall definiert \Package{scrlayer}
\Macro{if@mainmatter} ebenfalls als Synonym für \Macro{iftrue} und erweitert
darüber hinaus die gefundenen Definitionen von \Macro{frontmatter}, \Macro{mainmatter} und
\Macro{backmatter} so, dass diese \Macro{if@mainmatter} passend
umdefinieren. Falls es jedoch weitere, vergleichbare Befehle zur Umschaltung
zwischen unterschiedlichen Dokumentteilen gibt, so kennt \Package{scrlayer}
diese nicht, testet nicht auf diese und erweitert sie daher auch nicht
passend. In diesem Fall ist \Package{scrlayer} also auf die Mitarbeit des
Klassenautors angewiesen.%
\EndIndex{Cmd}{if@mainmatter}%

\begin{Declaration}
  \Macro{DeclareSectionNumberDepth}%
  \Parameter{Name der Gliederungsebene}\\
  \hphantom{\XMacro{DeclareSectionNumberDepth}}%
  \Parameter{Tiefe der Gliederungsebene}
\end{Declaration}
\BeginIndex{Cmd}{DeclareSectionNumberDepth}%
Jeder Gliederungsebene ist normalerweise eine nummerische Tiefe
zugeordnet. Das ist notwendig, damit \LaTeX{} die Hierarchie der
Gliederungsebenen verwalten kann. Allerdings sind die Werte normalerweise nur
der jeweiligen Klasse bekannt, in der die Gliederungsbefehle definiert
sind. Diese setzt dann in den entsprechenden \LaTeX-Befehlen selbst die
zugehörigen Nummern ein.

{\setlength{\emergencystretch}{1em}%
Das Paket \Package{scrlayer} benötigt ebenfalls Informationen über die
Hierarchie. Mit Hilfe von \Macro{DeclareSectionNumberDepth} kann
\Package{scrlayer} zum Namen einer Gliederungsebene die zugehörige nummerische
Tiefe bekannt gemacht werden. Für die Standardklassen wäre \PName{Name der
  Gliederungsebene} beispielsweise \PValue{part}, \PValue{chapter},
\PValue{section}, \PValue{subsection}, \PValue{subsubsection},
\PValue{paragraph} oder \PValue{subparagraph} und die jeweils zugehörige
\PName{Tiefe der Gliederungsebene} wäre -1, 0, 1, 2, 3, 4 oder 5.\par}

Das Paket \Package{scrlayer} versucht diese nummerischen Werte zunächst beim
Laden des Pakets und noch einmal während \Macro{begin}\PParameter{document}
selbst zu ermitteln. Aber für den Fall, dass dies einmal nicht zu einem
korrekten Ergebnis führt, beispielsweise falls es vollkommen andere
Gliederungsbefehle gibt, kann man die Zuordnung eben mit
\Macro{DeclareSectionNumberDepth} auch explizit vornehmen.%
%
\EndIndex{Cmd}{DeclareSectionNumberDepth}%

\section{Deklaration von Ebenen}
\seclabel{layers}

Eine Ebene (engl. \emph{layer}) ist ein Denkmodell für eine Seite. Im
Gegensatz zu echtem, physischem Papier ist diese Seite vollständig
transparent. Üblicherweise werden mehrere Ebenen übereinander gestapelt und
undurchsichtiges Material auf einer Ebene überdeckt Material auf den Ebenen
darunter. Ein solcher Stapel von Ebenen wird dann auf eine reale Seite Papier
abgebildet. Das Paket \Package{scrlayer} stellt zwei solche Stapel für jede
Seite zur Verfügung: einen Hintergrundstapel und einen Vordergrundstapel. Der
Hintergrundstapel befindet sich unter oder hinter dem normalen Seiteninhalt,
während der Vordergrundstapel über oder vor dem normalen Seiteninhalt
ausgegeben wird. Der normale Seiteninhalt ist daher eine Art von Trennebene
zwischen den beiden Ebenenstapeln.

Eine Ebene hat mehrere Eigenschaften, die als Antworten auf grundlegende
Fragen verstanden werden können:
\begin{description}
\item[Gehört die Ebene zum Vordergrund oder zum Hintergrund?\textnote{Vorder-
    oder Hintergrund}]%
  Hintergrundebenen werden ausgegeben, bevor der normale Inhalt der Seite
  gedruckt wird. Optisch erscheinen sie daher \emph{hinter} oder \emph{unter}
  dem normalen Inhalt der Seite.  Vordergrundebenen werden an den normalen
  Inhalt anschließend ausgegeben. Optisch erscheinen sie daher \emph{vor},
  \emph{auf} oder \emph{über} dem normalen Inhalt der Seite. In der
  Voreinstellung ist eine Ebene sowohl eine Hintergrundebene als auch eine
  Vordergrundebene und wird daher zweimal ausgegeben. Normalerweise ist es
  daher sinnvoll, dies explizit einzuschränken.
\item[An welcher Position soll die Ebene ausgegeben
  werden?\textnote{horizontale und vertikale Position}]%
  Zur Beantwortung dieser Frage dienen Eigenschaften zur Festlegung der
  horizontalen und der vertikalen Position.
\item[Wie groß ist die Ebene?\textnote{horizontale und vertikale Größe}]%
  Ebenso wie für die Position gibt es auch für die horizontale und vertikale
  Ausdehnung der Ebene Eigenschaften. Damit kann eine Ebene auch kleiner oder
  größer als das Papier sein und an unterschiedlichen Positionen auf dem
  Papier liegen.
\item[Wie werden die horizontale und die vertikale Position
  gemessen?\textnote{Ausrichtung}]%
  Die Antwort auf diese Frage ist die Eigenschaft der Ausrichtung. Man kann
  von der linken Papierkante zur linken Kante der Ebene, zur Mitte der Ebene
  oder zur rechten Kante der Ebene messen. Entsprechend kann man von der
  oberen Kante des Papiers zur oberen Kante der Ebene, zur Mitte der Ebene
  oder zur unteren Kante der Ebene messen.
\item[Ist die Ebene für Textausgabe oder für Grafik vorgesehen?\textnote{Text
    oder Grafik}]%
  Auch diese Frage ist eng mit der Position verknüpft. Während der Anwender
  bei der Grafikausgabe beispielsweise davon ausgeht, dass der Ursprung in der
  linken unteren Ecke der Ebene liegt, wäre dies bei der Textausgabe eher
  ungünstig.  Daher liegt der Ursprung für Textebenen um die Höhe einer
  Standardtextzeile unterhalb der oberen, linken Ecke der Ebene. Grafikebenen
  wiederum spannen von sich aus bereits eine
  \Environment{picture}-Umgebung\IndexEnv{picture} auf, in der zusätzliche
  Befehle zur Positionierung zur Verfügung stehen.
\item[Soll die Ebene auf linken oder rechten Seiten eines Dokuments gedruckt
  werden?\textnote{linke oder rechte Seite}]%
  In der Voreinstellung wird eine Ebene auf allen Seiten gedruckt. Es ist zu
  beachten, dass \LaTeX{} Seiten mit geraden Seitenzahlen als linke Seiten und
  Seiten mit ungeraden Seitenzahlen als rechte Seiten behandelt, dass es
  jedoch im einseitigen Modus unabhängig von der Nummer nur rechte Seiten
  gibt. \LaTeX{} bezeichnet den Gepflogenheiten in der englischen Sprache
  entsprechend linke Seiten auch als gerade Seiten und rechte Seiten als
  ungerade Seiten.
\item[Soll die Ebene in einseitigen oder in doppelseitigen Dokumenten
  verwendet werden?\textnote{einseitig oder doppelseitig}]%
  In der Voreinstellung ist die Ebene diesbezüglich unbeschränkt, wird also
  sowohl im einseitigen als auch im doppelseitigen Modus
  ausgegeben. Nichtsdestotrotz wird eine Ebene, die auf gerade Seiten
  beschränkt ist, im einseitigen Modus niemals ausgegeben werden und ist daher
  auch keine einseitige Ebene.
\item[Soll die Ebene auf Gleitseiten oder auf Normalseiten ausgegeben
  werden?\textnote{Gleitseiten oder Normalseiten}]%
  \LaTeX{} erzeugt Gleitseiten für Objekte aus Umgebungen wie
  \Environment{table} oder \Environment{figure}, wenn diesen erlaubt wurde,
  auf eigenen Seiten ohne Teile des normalen Dokumentinhalts ausgegeben zu
  werden (siehe Option \PValue{p} für \Environment{table} oder
  \Environment{figure}). In gewisser Weise ist es so der gesamten Seite
  erlaubt, im Dokument zu gleiten. Normalseiten in diesem Sinne sind alle
  Seiten, die keine Gleitseiten sind. Normalseiten können ebenfalls
  Gleitumgebungen am Anfang, im Inneren oder am Ende enthalten. Sehr große
  Gleitumgebungen können auch den Eindruck einer Gleitseite erzeugen, obwohl
  es sich bei ihnen in Wirklichkeit um oben auf einer Normalseite platzierte
  Gleitumgebungen handelt.
\item[Welchen Inhalt hat die Ebene?\textnote{Inhalt}]%
  Die zugehörige Eigenschaft gibt schlicht an, was gedruckt werden soll, wann
  immer die Ebene ausgegeben wird.
\end{description}
Damit haben wir derzeit acht Fragen an die Ebenen, aus denen sich unmittelbar
eine Reihe von Eigenschaften ergeben. Später in dieser Anleitung werden wir
weitere Eigenschaften kennen lernen, die jedoch auf diese primären
Eigenschaften abgebildet werden können.

\begin{Declaration}
  \Macro{DeclareLayer}\OParameter{Optionenliste}\Parameter{Name der Ebene}\\
  \Macro{DeclareNewLayer}\OParameter{Optionenliste}\Parameter{Name der Ebene}\\
  \Macro{ProvideLayer}\OParameter{Optionenliste}\Parameter{Name der Ebene}\\
  \Macro{RedeclareLayer}\OParameter{Optionenliste}\Parameter{Name der Ebene}\\
  \Macro{ModifyLayer}\OParameter{Optionenliste}\Parameter{Name der Ebene}
\end{Declaration}
\BeginIndex{Cmd}{DeclareLayer}%
\BeginIndex{Cmd}{DeclareNewLayer}%
\BeginIndex{Cmd}{ProvideLayer}%
\BeginIndex{Cmd}{RedeclareLayer}%
\BeginIndex{Cmd}{ModifyLayer}%
Diese Anweisungen können verwendet werden, um Ebenen zu definieren. Der
\PName{Name der Ebene} muss voll expandierbar sein. Die Expansion sollte in
ASCII-Buchstaben resultieren. Einige zusätzliche Zeichen werden ebenfalls
akzeptiert, ihre Verwendung wird jedoch nicht empfohlen.

Dabei spielt es bei Verwendung von
\Macro{DeclareLayer}\important{\Macro{DeclareLayer}} keine Rolle, ob eine
Ebene \PName{Name der Ebene} bereits existiert oder nicht. Sie wird in jedem
Fall mit den über die \PName{Optionenliste} angegebenen Eigenschaften
definiert. Einzelne Optionen bestehen entweder nur aus einem Schlüssel oder
aus einem Schlüssel, gefolgt von einem Gleichheitszeichen und einem Wert. Die
Optionen sind durch Komma voneinander getrennt. Um innerhalb der Werte einer
Option ein Komma oder ein Leerzeichen verwenden zu können, muss der
entsprechende Wert in geschweifte Klammern gesetzt werden.  Eine Übersicht
über die Optionen und die Eigenschaften, die sie repräsentieren, findet sich
in \autoref{tab:scrlayer.layerkeys}.

Im Unterschied zu \Macro{DeclareLayer} meldet
\Macro{DeclareNewLayer}\important{\Macro{DeclareNewLayer}} einen Fehler, falls
eine Ebene mit dem angegebenen Namen bereits existiert. Damit wird der
Anwender davor bewahrt, versehentlich mehrmals denselben Namen zu
verwenden. Dies ist insbesondere auch dann nützlich, wenn Klassen oder Pakete
intern ebenfalls Ebenen definieren.

Dagegen definiert \Macro{ProvideLayer}\important{\Macro{ProvideLayer}} die
Ebene nur, wenn nicht bereits eine Ebene mit dem angegebenen Namen
existiert. Wird der Name hingegen bereits für eine andere Ebene verwendet, so
wird die neuerliche Definition ignoriert. Die Anweisung hat also die
Bedeutung: \emph{Definiere die Ebene, falls sie noch nicht existiert.}

Soll eine bereits existierende Ebene umdefiniert werden, so kann wahlweise
\Macro{RedeclareLayer} oder \Macro{ModifyLayer} verwendet werden. Während mit
\Macro{RedeclareLayer}\important{\Macro{RedeclareLayer}} die Ebene zunächst
auf die Grundeinstellungen zurückgesetzt und damit über die angegebene
\PName{Optionenliste} komplett neu definiert wird, unterbleibt bei
\Macro{ModifyLayer}\important{\Macro{ModifyLayer}} das Zurücksetzen. Es werden
dann nur die Eigenschaften geändert, für die in der \PName{Optionenliste} auch
Angaben vorhanden sind. Die Anwendung auf eine zuvor noch nicht definierte
Ebene stellt bei beiden Anweisungen einen Fehler dar.

\begin{desclist}
  \desccaption{%
    Optionen für die Definition von Seiten-Ebenen mit ihrer jeweiligen
    Bedeutung als Ebenen-Eigenschaft\label{tab:scrlayer.layerkeys}%
  }{%
    Optionen für die Definition von Ebenen (\emph{Fortsetzung})%
  }%
  \entry{%
    \ChangedAt{v3.16}{\Package{scrlayer}}%
    \KOption{addcontents}\PName{Code}}{%
    Der angegebene Wert wird an den aktuellen Wert des Attributs
    \Option{contents} angehängt. Es wird also ein zusätzlicher Inhalt
    generiert. Zu näheren Informationen über die Behandlung von \PName{Code}
    siehe Option \Option{contents}.%
  }%
  \entry{%
    \ChangedAt{v3.16}{\Package{scrlayer}}%
    \KOption{addheight}\PName{zusätzliche Höhe}}{%
    Der aktuelle Wert von Attribut \Option{height} wird um den Wert dieser
    Option erhöht. Als Wert sind die gleichen Angaben wie bei
    \Option{height} möglich.%
  }%
  \entry{%
    \ChangedAt{v3.16}{\Package{scrlayer}}%
    \KOption{addhoffset}\PName{zusätzlicher horizontaler Abstand}}{%
    Der aktuelle Wert von Attribut \Option{hoffset} wird um den Wert dieser
    Option erhöht. Als Wert sind die gleichen Angaben wie bei
    \Option{hoffset} möglich.%
  }%
  \entry{%
    \ChangedAt{v3.16}{\Package{scrlayer}}%
    \KOption{addvoffset}\PName{zusätzlicher vertikaler Abstand}}{%
    Der aktuelle Wert von Attribut \Option{voffset} wird um den Wert dieser
    Option erhöht. Als Wert sind die gleichen Angaben wie bei
    \Option{voffset} möglich.%
  }%
  \entry{%
    \ChangedAt{v3.16}{\Package{scrlayer}}%
    \KOption{addwidth}\PName{zusätzliche Breite}}{%
    Der aktuelle Wert von Attribut \Option{width} wird um den Wert dieser
    Option erhöht. Als Wert sind die gleichen Angaben wie bei
    \Option{width} möglich.%
  }%
  \nentry{\KOption{align}\PName{Ausrichtungszeichen}}{%
    Über die \PName{Ausrichtungszeichen} wird die gewünschte Ausrichtung der
    Ebene bestimmt. Dabei steht jedes einzelne \PName{Ausrichtungszeichen} für
    eine mögliche Anwendung der Werte \PName{Abstand} der Optionen
    \Option{hoffset} oder \Option{voffset}. Mehrere
    \PName{Ausrichtungszeichen} können ohne Leerzeichen oder Komma direkt
    hintereinander geschrieben werden und werden in der Reihenfolge ihres
    Auftretens ausgewertet. Makros sind im Wert der Option jedoch
    nicht zulässig. Zulässige \PName{Ausrichtungszeichen} sind:
    \begin{description}
    \item[\PValue{b} --] der Wert der Option \Option{voffset} ist der Abstand
      der Unterkante der Ebene von der Oberkante des Papiers.
    \item[\PValue{c} --] die Werte der Optionen \Option{hoffset} und
      \Option{voffset} sind die Abstände des Zentrums der Ebene von der linken
      und der oberen Kante des Papiers.
    \item[\PValue{l} --] der Wert der Option \Option{hoffset} ist der Abstand
      der linken Kante der Ebene von der linken Kante des Papiers.
    \item[\PValue{r} --] der Wert der Option \Option{hoffset} ist der Abstand
      der rechten Kante der Ebene von der linken Kante des Papiers.
    \item[\PValue{t} --] der Wert der Option \Option{voffset} ist der Abstand
      der Oberkante der Ebene von der Oberkante des Papiers.
    \end{description}
  }%
  \entry{\KOption{area}\Parameter{horizontaler Abstand}\Parameter{vertikaler
      Abstand}\Parameter{Breite}\Parameter{Höhe}}{%
    Die zusammengesetzte Eigenschaft resultiert in den primären Eigenschaften
    \KOption{hoffset}\PName{horizontaler Abstand},
    \KOption{voffset}\PName{vertikaler Abstand},
    \KOption{width}\PName{Breite}, \KOption{height}\PName{Höhe}.%
  }%
  \entry{\ChangedAt{v3.18}{\Package{scrlayer}}%
    \Option{backandforeground}}{%
    Mit dieser Option wird die Einschränkung der Ebene auf den Vorder- oder
    Hintergrund wieder aufgehoben und diesbezüglich die Grundeinstellung
    wieder hergestellt. In der Regel ist dies wenig sinnvoll, daher existiert
    die Option nur aus Gründen der Vollständigkeit. Diese Option erwartet und
    erlaubt keinen Wert.%
  }%
  \entry{\Option{background}}{%
    Mit dieser Option wird die Ebene zu einer reinen Hintergrundebene. Sie
    wird also im Gegensatz zur Grundeinstellung nicht mehr gleichzeitig im
    Hintergrund und im Vordergrund, sondern nur noch im Hintergrund
    ausgegeben. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{bottommargin}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene horizontal von der linken Kante bis zur
    rechten Kante des Papiers reicht und vertikal den gesamten Bereich unter
    dem Seitenfuß bis zur unteren Papierkante abdeckt. Diese Option erwartet
    und erlaubt keinen Wert.%
  }%
  \entry{\KOption{clone}\PName{Name einer Ebene}}{%
    Die zusammengesetzte Eigenschaft setzt alle primären Eigenschaften
    entsprechend der aktuellen, primären Eigenschaften der Ebene mit dem
    angegebenen \PName{Name einer Ebene}. Es ist zu beachten, dass \PName{Name
      einer Ebene} voll expandierbar sein muss und zu Buchstaben expandieren
    sollte. Einige weitere Zeichen werden toleriert, ihre Verwendung wird
    jedoch nicht empfohlen! Die Ebene mit dem angegebenen \PName{Name einer
      Ebene} muss außerdem bereits existieren.%
  }%
  \entry{\KOption{contents}\PName{Code}}{%
    Der angegebene \PName{Code} wird immer dann expandiert und ausgeführt,
    wenn die Ebene ausgegeben wird. Damit definiert \PName{Code} das, was auf
    der Ebene zu sehen ist. Es werden keine Tests durchgeführt, ob
    \PName{Code} gültig und korrekt ist. Fehler in \PName{Code} können daher
    zu verschiedenen Fehlermeldungen auf jeder Seite führen, auf der die Ebene
    ausgegeben wird.%
  }%
  \entry{\Option{evenpage}}{%
    Mit dieser Option wird die Ebene zu einer Ebene für linke Seiten. Sie wird
    also im Gegensatz zur Grundeinstellung nicht mehr sowohl auf linken als
    auch auf rechten Seiten ausgegeben. Da es linke Seiten nur im
    doppelseitigen Satz gibt, schließt diese Eigenschaft quasi
    \Option{twoside} mit ein. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\ChangedAt{v3.18}{\Package{scrlayer}}%
    \Option{everypage}}{%
    Dies ist eine Kombination von \Option{oddorevenpage} und
    \Option{floatornonfloatpage}. Diese Option erwartet und erlaubt keinen
    Wert.%
  }%
  \entry{\ChangedAt{v3.18}{\Package{scrlayer}}%
    \Option{everyside}}{%
    Mit dieser Option wird die Einschränkung der Ebene auf den einseitigen
    oder den doppelseitigen Satz aufgehoben. Sie wird damit wie in der
    Voreinstellung wieder sowohl im einseitigen als auch im doppelseitigen
    Satz ausgegeben. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\ChangedAt{v3.18}{\Package{scrlayer}}%
    \Option{floatornonfloatpage}}{%
    Mit dieser Option wird die Einschränkung der Ebene auf Gleitseiten oder
    Seiten, die keine Gleitseiten sind, aufgehoben und diesbezüglich die
    Voreinstellung wieder hergestellt. Diese Option erwartet und erlaubt
    keinen Wert.%
  }%
  \entry{\Option{floatpage}}{%
    Mit dieser Option wird die Ebene zu einer Gleitseitenebene. Sie wird also
    im Gegensatz zur Grundeinstellung nicht mehr auf allen Seiten, sondern nur
    noch auf Gleitseiten ausgegeben. Näheres zu Gleitseiten ist der Einleitung
    zu diesem Abschnitt zu entnehmen. Diese Option erwartet und erlaubt keinen
    Wert.%
  }%
  \entry{\Option{foot}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den Seitenfuß in der Breite des
    Textbereichs überdeckt. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{footskip}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene vertikal den Bereich zwischen dem
    Textbereich und dem Seitenfuß in Breite des Textbereichs überdeckt. Es ist
    zu beachten, dass die Höhe dieses Bereichs zwar von der Länge
    \Length{footskip} abhängt, dieser jedoch nicht entspricht. Diese Option
    erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{foreground}}{%
    Mit dieser Option wird die Ebene zu einer reinen Vordergrundebene. Sie
    wird also im Gegensatz zur Grundeinstellung nicht mehr gleichzeitig im
    Hintergrund und im Vordergrund, sondern nur noch im Vordergrund
    ausgegeben. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{head}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den Seitenkopf in der Breite des
    Textbereichs überdeckt. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{headsep}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den Abstand zwischen dem Seitenkopf und
    dem Textbereich in der Breite des Textbereichs überdeckt. Ihre Höhe
    entspricht damit der Länge \Length{headsep}. Diese Option erwartet und
    erlaubt keinen Wert.%
  }%
  \entry{\KOption{height}\PName{Höhe}}{%
    Setzt die \PName{Höhe} der Ebene. Beachten Sie, dass \PName{Höhe}
    wahlweise eine \LaTeX-Länge sein kann, die mit \Macro{newlength} definiert
    wurde, eine \TeX-Länge, die mit \Macro{newdimen} oder \Macro{newskip}
    definiert wurde, ein Längenwert wie 10\Unit{pt} oder ein Längenausdruck
    unter Verwendung von +, -, /, *, (, und ). Die genaue Syntax eines
    Längenausdrucks ist \cite[Abschnitt~3.5]{manual:eTeX} zu entnehmen.%
  }%
  \entry{\KOption{hoffset}\PName{Abstand}}{%
    Setzt den \PName{Abstand} der Ebene von der linken Kante des Papiers. Wie
    der \PName{Abstand} gemessen wird, hängt von Eigenschaft \Option{align}
    ab. Beachten Sie, dass \PName{Abstand} wahlweise eine \LaTeX-Länge sein
    kann, die mit \Macro{newlength} definiert wurde, eine \TeX-Länge, die mit
    \Macro{newdimen} oder \Macro{newskip} definiert wurde, ein Längenwert wie
    10\Unit{pt} oder ein Längenausdruck unter Verwendung von +, -, /, *, (,
    und ). Die genaue Syntax eines Längenausdrucks ist
    \cite[Abschnitt~3.5]{manual:eTeX} zu entnehmen.%
  }%
  \entry{\Option{innermargin}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den inneren Rand der Seite von der
    Papieroberkante bis zur Papierunterkante überdeckt. Der innere Rand
    entspricht im einseitigen Satz dem linken Rand. Diese Option erwartet und
    erlaubt keinen Wert.%
  }%
  \entry{\Option{leftmargin}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den linken Rand der Seite von der
    Papieroberkante bis zur Papierunterkante überdeckt. Diese Option erwartet
    und erlaubt keinen Wert.%
  }%
  \entry{\ChangedAt{v3.19}{\Package{scrlayer}}%
    \KOption{mode}\PName{Modus}}{%
    Diese primäre Eigenschaft bestimmt in welchem \PName{Modus} der Inhalt der
    Ebene ausgegeben wird. Die Voreinstellung ist \PValue{text}. Dabei wird
    die oberste Grundlinie um die Höhe einer Standardtextzeile unterhalb der
    Oberkante der Ebene platziert. Damit ist Text normalerweise sauber am
    oberen Rand der Ebene ausgerichtet. Im \PValue{picture}-\PName{Modus} wird
    hingegen eine \Environment{picture}-Umgebung mit dem Ursprung in der
    linken, unteren Ecke der Ebene aufgespannt. Der ebenfalls vordefinierte
    \PName{Modus} \PValue{raw} entspricht in der Voreinstellung \PValue{text}.

    Die\textnote{Achtung!} Änderung des \PName{Modus} einer Ebene führt in der
    Regel zu einer Verschiebung des Inhalts. Außerdem stehen beispielsweise im
    \PName{Modus} \PValue{picture} zusätzliche Platzierungsbefehle zur
    Verfügung, die in einem anderen \PName{Modus} zu Fehlermeldungen führen.
    Daher ist es normalerweise nicht sinnvoll, den \PName{Modus} einer Ebene
    nachträglich zu ändern!%
  }%
  \entry{\Option{nonfloatpage}}{%
    Mit dieser Option wird die Ebene auf Seiten beschränkt, die keine
    Gleitseiten sind. Sie wird also im Gegensatz zur Grundeinstellung nicht
    mehr auf allen Seiten, sondern nur noch auf Nichtgleitseiten
    ausgegeben. Näheres zu Gleitseiten und Nichtgleitseiten ist der Einleitung
    zu diesem Abschnitt zu entnehmen. Diese Option erwartet und erlaubt keinen
    Wert.%
  }%
  \entry{\ChangedAt{v3.18}{\Package{scrlayer}}%
    \Option{oddorevenpage}}{%
    Mit dieser Option werden Beschränkungen der Ebene auf rechte oder linke
    Seiten aufgehoben. Damit wird die Ebene wie in der Voreinstellung sowohl
    auf linken als auch rechten Seiten ausgegeben. Diese Option erwartet und
    erlaubt keinen Wert.%
  }%
  \entry{\Option{oddpage}}{%
    Mit dieser Option wird die Ebene zu einer Ebene für rechte Seiten. Sie
    wird also im Gegensatz zur Grundeinstellung nicht mehr sowohl auf linken
    als auch auf rechten Seiten ausgegeben. Es ist zu beachten, dass im
    einseitigen Satz alle Seiten unabhängig von der Seitenzahl rechte Seiten
    sind. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{oneside}}{%
    Mit dieser Option wird die Ebene zu einer Ebene für den einseitigen
    Satz. Sie wird also im Gegensatz zur Grundeinstellung nicht mehr sowohl im
    einseitigen als auch im doppelseitigen Satz ausgegeben. Diese Option
    erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{outermargin}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den äußeren Rand der Seite von der
    Papieroberkante bis zur Papierunterkante überdeckt. Der äußere Rand
    entspricht im einseitigen Satz dem rechten Rand. Diese Option erwartet und
    erlaubt keinen Wert.%
  }%
  \entry{\Option{page}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene die komplette Seite überdeckt. Diese
    Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\ChangedAt{v3.16}{\Package{scrlayer}}%
    \KOption{pretocontents}\PName{Code}}{%
    Der angegebene Wert wird dem aktuellen Wert des Attributs
    \Option{contents} vorangestellt. Es wird also ein zusätzlicher Inhalt vor
    dem bisherigen Inhalt generiert. Zu näheren Informationen über die
    Behandlung von \PName{Code} siehe Option \Option{contents}.%
  }%
  \entry{\Option{rightmargin}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den rechten Rand der Seite von der
    Papieroberkante bis zur Papierunterkante überdeckt. Diese Option erwartet
    und erlaubt keinen Wert.%
  }%
  \entry{\Option{textarea}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den kompletten Textbereich
    überdeckt. Diese Option erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{topmargin}}{%
    Die zusammengesetzte Eigenschaft setzt die primären Eigenschaften
    \Option{hoffset}, \Option{voffset}, \Option{width}, \Option{height} und
    \Option{align} so, dass die Ebene den oberen Rand der Seite von der linken
    Kante des Papiers bis zu dessen rechter Kante überdeckt. Diese Option
    erwartet und erlaubt keinen Wert.%
  }%
  \entry{\Option{twoside}}{%
    Mit dieser Option wird die Ebene zu einer Ebene für den doppelseitigen
    Satz. Sie wird also im Gegensatz zur Grundeinstellung nicht mehr sowohl im
    einseitigen als auch im doppelseitigen Satz ausgegeben. Diese Option
    erwartet und erlaubt keinen Wert.%
  }%
  \entry{\ChangedAt{v3.18}{\Package{scrlayer}}%
    \Option{unrestricted}}{%
    Hebt alle Ausgabebeschränkungen auf. Damit ist die Option eine Kombination
    von \Option{backandforground}, \Option{everyside} und
    \Option{floatornonfloatpage}. Diese Option erwartet und erlaubt keinen
    Wert.%
  }%
  \entry{\KOption{voffset}\PName{Abstand}}{%
    Setzt den \PName{Abstand} der Ebene von der Papieroberkante. Wie der
    \PName{Abstand} gemessen wird, hängt von Eigenschaft \Option{align}
    ab. Beachten Sie, dass \PName{Abstand} wahlweise eine \LaTeX-Länge sein
    kann, die mit \Macro{newlength} definiert wurde, eine \TeX-Länge, die mit
    \Macro{newdimen} oder \Macro{newskip} definiert wurde, ein Längenwert wie
    10\Unit{pt} oder ein Längenausdruck unter Verwendung von +, -, /, *, (,
    und ). Die genaue Syntax eines Längenausdrucks ist
    \cite[Abschnitt~3.5]{manual:eTeX} zu entnehmen.%
  }%
  \entry{\KOption{width}\PName{Breite}}{%
    Setzt die \PName{Breite} der Ebene. Beachten Sie, dass \PName{Breite}
    wahlweise eine \LaTeX-Länge sein kann, die mit \Macro{newlength} definiert
    wurde, eine \TeX-Länge, die mit \Macro{newdimen} oder \Macro{newskip}
    definiert wurde, ein Längenwert wie 10\Unit{pt} oder ein Längenausdruck
    unter Verwendung von +, -, /, *, (, und ). Die genaue Syntax eines
    Längenausdrucks ist \cite[Abschnitt~3.5]{manual:eTeX} zu entnehmen.%
  }%
\end{desclist}
%
\EndIndex{Cmd}{ModifyLayer}%
\EndIndex{Cmd}{RedeclareLayer}%
\EndIndex{Cmd}{ProvideLayer}%
\EndIndex{Cmd}{DeclareNewLayer}%
\EndIndex{Cmd}{DeclareLayer}%

\begin{Declaration}
  \Macro{layerhalign}\\
  \Macro{layervalign}\\
  \Macro{layerxoffset}\\
  \Macro{layeryoffset}\\
  \Macro{layerwidth}\\
  \Macro{layerheight}%
\end{Declaration}
\BeginIndex{Cmd}{layervalign}%
\BeginIndex{Cmd}{layerhalign}%
\BeginIndex{Cmd}{layerxoffset}%
\BeginIndex{Cmd}{layeryoffset}%
\BeginIndex{Cmd}{layerwidth}%
\BeginIndex{Cmd}{layerheight}%
Diese Anweisungen sind nur innerhalb der Ausgabe des mit \Option{contents},
\Option{addcontents} oder \Option{pretocontents} angegebenen \PName{Code}
gültig. In diesem Fall enthalten sie die tatsächlich verwendete Ausrichtung,
Position und Ausdehnung der Ebene, die für die Ausgabe verwendet werden. Dies
ist jedoch nicht zwangsläufig auch die tatsächliche Ausdehnung des Inhalts,
falls dieser beispielsweise überbreit oder überhoch ist oder die Ebene nicht
komplett ausfüllt.

Die primäre Ebeneneigenschaft \PValue{align} wird auf
\Macro{layerhalign}\ChangedAt{v3.19}{\Package{scrlayer}} und
\Macro{layervalign} abgebildet. Dabei werden die horizontalen Werte \PValue{l}
und \PValue{r} nur in \Macro{layerhalign} übernommen, während die vertikalen
Werte \PValue{t} und \PValue{b} nur in \Macro{layervalign} übernommen
werden. Der sowohl horizontale als auch vertikale Wert \PValue{c} wird in
beide Anweisungen übernommen. Sind bei \PValue{align} mehrere,
widersprüchliche Angaben zu finden, so gewinnt die jeweils letzte. Damit ist
also \Macro{layerhalign} immer entweder \PValue{l}, \PValue{c} oder \PValue{r}
und \Macro{layervalign} immer entweder \PValue{r}, \PValue{c} oder \PValue{b}.

Eine\textnote{Achtung!} Umdefinierung der Anweisungen und damit Änderung der in
ihnen gespeicherten Werte ist nicht gestattet und führt zu unvorhersehbaren
Ergebnissen.%
\EndIndex{Cmd}{layerheight}%
\EndIndex{Cmd}{layerwidth}%
\EndIndex{Cmd}{layeryoffset}%
\EndIndex{Cmd}{layerxoffset}%
\EndIndex{Cmd}{layerhalign}%
\EndIndex{Cmd}{layervalign}%

\begin{Declaration}
  \Macro{LenToUnit}\Parameter{Länge}
\end{Declaration}
\BeginIndex{Cmd}{LenToUnit}%
Diese\ChangedAt{v3.19}{\Package{scrlayer}} Anweisung stammt ursprünglich von
\Package{eso-pic}\IndexPackage{eso-pic} ab Version~2.0f. Sie rechnet
Längen-Werte in Vielfache von \Length{unitlength} um und kann daher an Stelle
von Koordinaten oder anderen von \Length{unitlength} abhängigen Werten einer
\Environment{picture}-Umgebung verwendet werden. Siehe dazu auch
\cite{package:eso-pic} und die nachfolgende Erklärung zu \Macro{putUR},
\Macro{putLL} und \Macro{putLR}. Die Anweisung wird nur
definiert, wenn sie nicht bereits beispielsweise durch das Laden von
\Package{eso-pic} definiert ist.

Es sei an dieser Stelle darauf hingewiesen, dass man bei Verwendung von Paket
\Package{picture}\IndexPackage{picture}\textnote{\Package{picture}} (siehe
\cite{package:picture}) die Anweisung \Macro{LenToUnit} in der Regel nicht
mehr benötigt. Das Paket erweitert die \Environment{picture}-Umgebung und
deren Anweisung so, dass man für Koordinaten auch direkt \LaTeX-Längen
verwenden kann.%
\EndIndex{Cmd}{LenToUnit}%

\begin{Declaration}
  \Macro{putUL}\Parameter{Inhalt}\\
  \Macro{putUR}\Parameter{Inhalt}\\
  \Macro{putLL}\Parameter{Inhalt}\\
  \Macro{putLR}\Parameter{Inhalt}\\
  \Macro{putC}\Parameter{Inhalt}
\end{Declaration}
\BeginIndex{Cmd}{putUL}%
\BeginIndex{Cmd}{putUR}%
\BeginIndex{Cmd}{putLL}%
\BeginIndex{Cmd}{putLR}%
\BeginIndex{Cmd}{putC}%
Diese\ChangedAt{v3.19}{\Package{scrlayer}} Anweisungen können innerhalb der
primären Ebeneneigenschaft \PValue{contents} verwendet werden, wenn die Ebene
mit \OptionValue{mode}{picture} erstellt wurde. In diesem Fall platziert
\Macro{putUL} den \PName{Inhalt} relativ zur oberen, linken Ecke der Ebene und
entspricht damit
\lstinline[breaklines=false]|\put(0,\LenToUnit{\layerheight})|. \Macro{putUR}
platziert \PName{Inhalt} relativ zur oberen, rechten Ecke der Ebene und
entspricht damit
\lstinline[breaklines=false]|\put(\LenToUnit{\layerwidth},\LenToUnit{\layerheight})|.
\Macro{putLL} platziert \PName{Inhalt} relativ zur unteren, linken Ecke der
Ebene und entspricht damit
\lstinline[breaklines=false]|\put(0,0)|. \Macro{putLR} platziert
\PName{Inhalt} relativ zur unteren, rechten Ecke der Ebene und entspricht
damit
\lstinline[breaklines=false]|\put(\LenToUnit{\layerwidth},0)|. \Macro{putC}
schließlich platziert \PName{Inhalt} relativ zur Mitte der Ebene.%
%
\begin{Example}
  Sie wollen feststellen, wie genau die Höhe des Textbereichs bei
  \OptionValue{DIV}{classic} tatsächlich der Breite der Seite entspricht und
  erstellen dazu eine Ebene, die sowohl den Textbereich umrandet als auch
  einen Kreis mit der Papierbreite als Durchmesser im Zentrum des Textbereichs
  platziert:
\begin{lstcode}
\documentclass[DIV=classic]{scrartcl}
\usepackage{pict2e}
\usepackage{scrlayer}
\DeclareNewLayer[%
  textarea,background,mode=picture,
  contents={%
    \putLL{\line(1,0){\LenToUnit{\layerwidth}}}%
    \putLR{\line(0,1){\LenToUnit{\layerheight}}}%
    \putUR{\line(-1,0){\LenToUnit{\layerwidth}}}%
    \putUL{\line(0,-1){\LenToUnit{\layerheight}}}%
    \putC{\circle{\LenToUnit{\paperwidth}}}%
  }
]{showtextarea}
\DeclareNewPageStyleByLayers{test}{showtextarea}
\pagestyle{test}
\begin{document}
\null
\end{document}
\end{lstcode}
  Wie Sie sehen werden, passt die von \Package{typearea} vorgenommene
  Abbildung auf einen ganzzahligen \PName{DIV}-Wert im Beispiel sehr gut.
\end{Example}
Näheres zu dem im Beispiel skizzierten spätmittelalterlichen Buchseitenkanon
finden Sie übrigens in \autoref{sec:typearea.circleConstruction},
\autopageref{sec:typearea.circleConstruction}.

Die im Beispiel bereits verwendete Anweisung
\Macro{DeclareNewPageStyleByLayers}\IndexCmd{DeclareNewPageStyleByLayers} wird
leider erst in \autoref{sec:scrlayer.pagestyles},
\autopageref{desc:scrlayer.cmd.DeclareNewPageStyleByLayers} erklärt
werden. Sie dient hier zur Definition eines Seitenstils, der die neu
definierte Ebene auch tatsächlich verwendet.%
\EndIndex{Cmd}{putC}%
\EndIndex{Cmd}{putLR}%
\EndIndex{Cmd}{putLL}%
\EndIndex{Cmd}{putUR}%
\EndIndex{Cmd}{putUL}%


\begin{Declaration}
  \Macro{GetLayerContents}\Parameter{Name der Ebene}
\end{Declaration}
\BeginIndex{Cmd}{GetLayerContents}%
Mit\ChangedAt{v3.16}{\Package{scrlayer}} dieser Anweisung kann der aktuelle
Inhalt einer Ebene ermittelt werden. Es\textnote{Achtung!} ist unbedingt zu
beachten, dass bei Verwendung dieser Anweisung im \PName{Code} der
Ebenen-Attribute \Option{contents}, \Option{addcontents} oder
\Option{pretocontents} unendliche Rekursionen entstehen können, wenn dabei auf
den Inhalt der aktuellen Ebene zugegriffen wird. Der Anwender ist selbst dafür
verantwortlich solche Situationen zu vermeiden!%
\EndIndex{Cmd}{GetLayerContents}%

\begin{Declaration}
  \Macro{IfLayerExists}%^^A
  \Parameter{Name}\Parameter{Dann-Code}\Parameter{Sonst-Code}
\end{Declaration}
\BeginIndex{Cmd}{IfLayerExists}%
Diese Anweisung kann dazu verwendet werden, Code in Abhängigkeit davon, ob ein
eine Ebene existiert oder nicht, auszuführen. Wenn die Ebene mit dem
angegebenen \PName{Name} existiert, so wird der \PName{Dann-Code}
ausgeführt, anderenfalls der \PName{Sonst-Code}. Bitte beachten Sie, dass die
Anweisung nicht wirklich testen kann, ob eine Ebene existiert. Sie verwendet
stattdessen Heuristiken, die niemals falsch-negativ sein können, jedoch im
Extremfall falsch-positiv sein könnten. Nichtsdestotrotz: Falls der Test
falsch-positiv ist, läuft etwas schief. Beispielsweise könnte dies ein
Indikator für die Verwendung eines inkompatiblen Pakets oder dafür sein, dass
der Anwender etwas tut, was er besser nicht tun sollte.%
\EndIndex{Cmd}{IfLayerExists}

\begin{Declaration}
  \Macro{DestroyLayer}\Parameter{Name der Ebene}
\end{Declaration}
\BeginIndex{Cmd}{DestroyLayer}%
Existiert eine Ebene mit dem angegebenen \PName{Name der Ebene}, so werden
alle zu dieser Ebene gehörenden Makros zu \Macro{relax}. Anschließend kann die
Ebene nicht länger verwendet werden. Allerdings ist es kein Problem, falls die
Ebene Bestandteil eines mit \Package{scrlayer} definierten Seitenstils ist, da
derart zerstörte Ebenen schlicht ignoriert werden. Nichtsdestotrotz können
zerstörte Ebenen anschließend mit \Macro{DeclareNewLayer} oder
\Macro{ProvideLayer} neu definiert werden. Sie können jedoch vor einer
neuerlichen Definition nicht länger mit \Macro{RedeclareLayer} oder
\Macro{ModifyLayer} verändert werden.

Die Anweisung ist dazu bestimmt, innerhalb des Arguments \PName{Code} von
\Macro{scrlayerOnAutoRemoveInterface} (siehe
\autoref{sec:scrlayer.enduserinterfaces},
\autopageref{desc:scrlayer.cmd.scrlayerOnAutoRemoveInterface}) verwendet zu
werden. Damit können Ebenen, die unter Verwendung von entfernbaren Anweisungen
einer entfernbaren Benutzerschnittstelle definiert wurden, zusammen mit dieser
Benutzerschnittstelle entfernt werden.%
\EndIndex{Cmd}{DestroyLayer}%


\begin{Declaration}
  \Macro{layercontentsmeasure}
\end{Declaration}
\BeginIndex{Cmd}{layercontentsmeasure}%
Mit Hilfe der \KOMAScript-Option
\Option{draft}\IndexOption{draft~=\PName{Ein-Aus-Wert}} kann für das Paket
\Package{scrlayer} ein Entwurfsmodus aktiviert werden. In diesem Entwurfsmodus
wird hinter jeder Ebene zunächst eine Bemaßung der Ebene ausgegeben. Diese
Bemaßung erfolgt mit \Macro{layercontentsmeasure}. Diese Anweisung zeigt am
oberen und linken Rand der Ebene ein Maßband in Zentimeter und am rechten und
unteren Rand der Ebene ein Maßband in Zoll. Die Anweisung
\Macro{layercontentsmeasure} kann statt über die Option auch schlicht als
alleiniger \PName{Code} für die Eigenschaft \Option{contents} einer Ebene
verwendet werden.%
%
\EndIndex{Cmd}{layercontentsmeasure}%


\section{Deklaration und Verwaltung von Seitenstilen}
\seclabel{pagestyles}

Wir kennen nun Ebenen und wissen, wie diese definiert und verwaltet
werden. Aber bisher wissen wir noch nicht, wie sie verwendet werden. Die
möglicherweise überraschende Antwort lautet: mit Hilfe von
Seitenstilen. Üblicherweise werden Seitenstile in \LaTeX{} zur Definition von
Kopf und Fuß der Seite verwendet.

Kopf und Fuß für ungerade oder rechte Seiten werden im doppelseitigen Modus
auf Seiten mit ungerader Seitenzahl ausgegeben. Im einseitigen Modus werden
sie auf allen Seiten verwendet. Das ist unmittelbar mit den Optionen
\Option{oddpage} und \Option{evenpage} für Ebenen vergleichbar.

Der Seitenkopf wird vor dem normalen Seiteninhalt ausgegeben. Der Seitenfuß
wird entsprechend nach dem normalen Seiteninhalt ausgegeben. Dies
korrespondiert also unmittelbar mit den Optionen \Option{background} und
\Option{foreground} für Ebenen.

Daher liegt es nahe, Seitenstile als Listen von Ebenen zu definieren. Aber
statt nur die genannten vier Optionen können dabei alle Eigenschaften
verwendet werden, die in \autoref{sec:scrlayer.layers},
\autoref{tab:scrlayer.layerkeys}, ab \autopageref{tab:scrlayer.layerkeys}
erklärt wurden.

Als Ergebnis dieser Überlegungen ist eine Form von Seitenstilen, die
\Package{scrlayer} bietet, der
Ebenen-Seitenstil\textnote{Ebenen-Seitenstil}\Index{Seitenstil>Ebenen-}\Index{Ebenen>Seitenstil}\Index{Seiten>Stil}. Ein
solcher Ebenen-Seitenstil besteht aus Ebenen und zusätzlich aus mehreren Haken
(engl. \emph{hooks}). Die Ebenen wurden bereits in
\autoref{sec:scrlayer.layers} beschrieben. Die Haken sind Punkte in der
Expansion oder Anwendung von Seitenstilen, zu denen zusätzlicher Code
hinzugefügt werden kann. Erfahrene Anwender kennen dieses Konzept bereits von
beispielsweise \Macro{AtBeginDocument} (siehe \cite{latex:usrguide}) oder
\Macro{BeforeClosingMainAux} (siehe
\autopageref{desc:scrlfile.cmd.BeforeClosingMainAux}).

Eine zweite Form von Seitenstilen, die \Package{scrlayer} bietet, ist der
Alias-Seitenstil\textnote{Alias-Seitenstil}\Index{Seitenstil>Alias-}\Index{Alias>Seitenstil}\Index{Seiten>Stil} oder
Seitenstil-Alias. Ein Seitenstil-Alias besteht in Wirklichkeit aus einem
anderen Seitenstil. Anders ausgedrückt ist der Name eines Seitenstil-Alias ein
Alias-Name für einen anderen Seitenstil-Alias oder einen primären
Seitenstil. Daher führt die Manipulation an einem Seitenstil-Alias zu einer
Manipulation am originären Seitenstil. Ist der originäre Seitenstil selbst
ebenfalls ein Seitenstil-Alias, so führt dessen Manipulation wiederum zu einer
Manipulation dessen originären Seitenstils und immer so weiter, bis
schließlich ein realer Seitenstil verändert wird. Der Ausdruck \emph{realer
  Seitenstil} wird zur Unterscheidung von einem Seitenstil-Alias
verwendet. Alle Seitenstile, die kein Seitenstil-Alias sind, sind reale
Seitenstile. Seitenstil-Aliase können nicht nur für Seitenstile definiert
werden, die mit \Package{scrlayer} definiert wurden, sondern für alle
Seitenstile.

\begin{Declaration}
  \Macro{currentpagestyle}
\end{Declaration}
\BeginIndex{Cmd}{currentpagestyle}%
Das Paket \Package{scrlayer} erweitert die \LaTeX-Anweisung
\Macro{pagestyle}\IndexCmd{pagestyle} so, dass diese \Macro{currentpagestyle}
als den Namen des jeweils aktiven Seitenstils
definiert. Es\textnote{Achtung!} ist zu beachten, dass
\Macro{thispagestyle}\IndexCmd{thispagestyle} selbst \Macro{currentpagestyle}
nicht verändert. Wird \Macro{thispagestyle} verwendet, so kann sich
\Macro{currentpagestyle} aber innerhalb der \LaTeX-Ausgabefunktion
verändern. Dies hat jedoch nur dann Auswirkungen, wenn
\Macro{currentpagestyle} bis in die \LaTeX-Ausgabefunktion geschützt
verwendet wird.

Es sei darauf hingewiesen, dass die später in diesem Abschnitt dokumentierten
Ebenen-Seitenstile nicht auf diese Erweiterung von \Macro{pagestyle} angewiesen
sind, da sie selbst auch \Macro{currentpagestyle} umdefinieren. Die
Erweiterung wurde für die Verwendung von anderen Seitenstilen, die nicht auf
\Package{scrlayer} basieren, vorgenommen. Es ist außerdem zu
beachten\textnote{Achtung!}, dass \Macro{currentpagestyle} vor der ersten
Verwendung von \Macro{pagestyle} nach dem Laden von \Package{scrlayer} leer
ist. Bei der Definition einer Endanwender-Schnittstelle dürfte es daher
nützlich sein, mit einer impliziten \Macro{pagestyle}-Anweisung den aktuellen
Seitenstil auf eine Voreinstellung zu setzen.%
\EndIndex{Cmd}{currentpagestyle}%

\begin{Declaration}
  \Macro{BeforeSelectAnyPageStyle}\Parameter{Code}\\
  \Macro{AfterSelectAnyPageStyle}\Parameter{Code}%
\end{Declaration}
\BeginIndex{Cmd}{BeforeSelectAnyPageStyle}%
\BeginIndex{Cmd}{AfterSelectAnyPageStyle}%
Die Anweisung \Macro{BeforeSelectAnyPageStyle} fügt einem Haken
(engl. \emph{hook}) \PName{Code} hinzu, der innerhalb der Ausführung von
Anweisung \Macro{pagestyle}\important{\Macro{pagestyle}}\IndexCmd{pagestyle},
unmittelbar vor der Auswahl des Seitenstils ausgeführt wird. Innerhalb von
\PName{Code} kann \texttt{\#1} als Platzhalter für das Argument von
\Macro{pagestyle} verwendet werden.

Die Anweisung \Macro{AfterSelectAnyPageStyle} arbeitet ähnlich. Allerdings
wird hier \PName{Code} ausgeführt, nachdem der Seitenstil gewählt und
\Macro{currentpagestyle} auf den Namen des realen Seitenstils gesetzt wurde.

Es ist zu beachten\textnote{Achtung!}, dass \PName{Code} jeweils nur bei der
Wahl eines Seitenstils mit Hilfe von \Macro{pagestyle} ausgeführt wird. Wird
ein Seitenstil auf andere Art, beispielsweise mit Hilfe von
\Macro{thispagestyle}, gewählt, so wird \PName{Code} nicht ausgeführt. Es ist
außerdem zu beachten\textnote{Achtung!}, dass einmal hinzugefügter
\PName{Code} nicht mehr entfernt werden kann. Allerdings wird der \PName{Code}
lokal hinzugefügt. Sein Gültigkeitsbereich kann daher mit einer Gruppe
beschränkt werden.%
\EndIndex{Cmd}{AfterSelectAnyPageStyle}%
\EndIndex{Cmd}{BeforeSelectAnyPageStyle}%


\begin{Declaration}
  \Macro{DeclarePageStyleAlias}%
  \Parameter{Seitenstil-Alias-Name}\\
  \hphantom{\XMacro{DeclarePageStyleAlias}}%
  \Parameter{originärer Seitenstil-Name}\\
  \Macro{DeclareNewPageStyleAlias}%
  \Parameter{Seitenstil-Alias-Name}\\
  \hphantom{\XMacro{DeclareNewPageStyleAlias}}%
  \Parameter{originärer Seitenstil-Name}\\
  \Macro{ProvidePageStyleAlias}%
  \Parameter{Seitenstil-Alias-Name}\\
  \hphantom{\XMacro{ProvidePageStyleAlias}}%
  \Parameter{originärer Seitenstil-Name}\\
  \Macro{RedeclarePageStyleAlias}%
  \Parameter{Seitenstil-Alias-Name}\\
  \hphantom{\XMacro{RedeclarePageStyleAlias}}%
  \Parameter{originärer Seitenstil-Name}%
\end{Declaration}
\BeginIndex{Cmd}{DeclarePageStyleAlias}%
\BeginIndex{Cmd}{DeclareNewPageStyleAlias}%
\BeginIndex{Cmd}{ProvidePageStyleAlias}%
\BeginIndex{Cmd}{RedeclarePageStyleAlias}%
\BeginIndex{}{Seitenstil>Alias-}%
\BeginIndex{}{Alias>Seitenstil}%
\BeginIndex{}{Seiten>Stil}%
Diese Anweisungen können verwendet werden, um einen Seitenstil mit dem Namen
\PName{Seitenstil-Alias-Name} zu definieren, der einfach nur ein Alias für
einen bereits existierenden Seitenstil mit dem Namen \PName{originärer
  Seitenstil-Name} ist. Falls bereits ein Seitenstil mit dem Namen
\PName{Seitenstil-Alias-Name} existiert, wird dieser vor der Erzeugung des
Alias mit \Macro{DeclarePageStyleAlias} oder \Macro{RedeclarePageStyleAlias}
zerstört.

Die Anweisung \Macro{DeclareNewPageStyleAlias} erzeugt eine Fehlermeldung,
falls zuvor bereits ein Seitenstil \PName{Seitenstil-Alias-Name}
definiert wurde. Dabei spielt es keine Rolle, ob der existierende Seitenstil
selbst ein Alias-Seitenstil, ein Ebenen-Seitenstil oder eine andere Art von
Seitenstil ist.

Die Anweisung \Macro{ProvidePageStyleAlias} definiert den Seitenstil-Alias
nur, falls nicht bereits ein Seitenstil
\PName{Seitenstil-Alias-Name} existiert. Falls ein solcher Seitenstil
existiert, bleibt dieser erhalten und die Anweisung tut schlicht nichts.

Im Gegensatz zu den drei vorgenannten Anweisungen erwartet
\Macro{RedeclarePageStyleAlias}, dass bereits ein Seitenstil mit dem Namen
\PName{Seitenstil-Alias-Name} existiert. Anderenfalls erzeugt die Anweisung
eine Fehlermeldung.
\iffree{\csname @tempswafalse\endcsname}{\csname @tempswatrue\endcsname}%
\csname if@tempswa\endcsname% Umbruchkorrekturtext
\begin{Example}
  Angenommen, Sie schreiben eine Klasse und verwenden darin für
  Kapitelanfangsseiten den Seitenstil \Pagestyle{chapter}. In der
  Voreinstellung soll dieser Seitenstil dem Seitenstil \Pagestyle{plain}
  entsprechen. Daher verwenden Sie das Paket \Package{scrlayer} und definieren
  mit
\begin{lstcode}
  \DeclareNewPageStyleAlias{chapter}{plain}
\end{lstcode}
  den Seitenstil \Pagestyle{chapter} als Alias für den Seitenstil
  \Pagestyle{plain}. Will hingegen der Anwender später, dass der Seitenstil
  \Pagestyle{chapter} dem Seitenstil \Pagestyle{empty} entspricht, so erreicht
  er dies mit:
\begin{lstcode}
  \RedeclarePageStyleAlias{chapter}{empty}
\end{lstcode}
\end{Example}
\fi
\EndIndex{Cmd}{RedeclarePageStyleAlias}%
\EndIndex{Cmd}{ProvidePageStyleAlias}%
\EndIndex{Cmd}{DeclareNewPageStyleAlias}%
\EndIndex{Cmd}{DeclarePageStyleAlias}

\begin{Declaration}
  \Macro{DestroyPageStyleAlias}\Parameter{Seitenstil-Alias-Name}%
\end{Declaration}
\BeginIndex{Cmd}{DestroyPageStyleAlias}%
Mit dieser Anweisung wird der Seitenstil-Alias mit dem angegebenen Namen
\PName{Seitenstil-Alias-Name} für \LaTeX{} wieder undefiniert, wenn es
tatsächlich einen Alias-Seitenstil dieses Namens gibt. Anschließend kann der
Seitenstil auch mit \Macro{DeclareNewAliasPageStyle} oder
\Macro{ProvideAliasPageStyle} wieder neu definiert werden.

Die Anweisung ist dazu bestimmt, innerhalb des Arguments \PName{Code} von
\Macro{scrlayerOnAutoRemoveInterface} (siehe
\autoref{sec:scrlayer.enduserinterfaces},
\autopageref{desc:scrlayer.cmd.scrlayerOnAutoRemoveInterface}) verwendet zu
werden, um Seitenstile, die als Teil eines Endanwender-Interfaces definiert
wurden, beim automatischen Entfernen dieses Interfaces mit zu entfernen.%
\EndIndex{Cmd}{DestroyPageStyleAlias}%

\begin{Declaration}
  \Macro{GetRealPageStyle}\Parameter{Seitenstil-Name}%
\end{Declaration}
\BeginIndex{Cmd}{GetRealPageStyle}%
Diese Anweisung sucht rekursiv nach dem tatsächlichen Namen eines
Seitenstils, wenn der angegebene \PName{Seitenstil-Name} zu einem
Alias-Seitenstil gehört. Ist \PName{Seitenstil-Name} nicht der Name eines
Alias-Seitenstils, so ist das Ergebnis \PName{Seitenstil-Name} selbst. Das
gilt auch, falls ein Seitenstil namens \PName{Seitenstil-Name} gar nicht
existiert. Die Anweisung ist voll expandierbar und kann damit beispielsweise
auch im zweiten Argument einer \Macro{edef}-Anweisung verwendet werden.
%
\EndIndex{Cmd}{GetRealPageStyle}%
\EndIndex{}{Alias>Seitenstil}%
\EndIndex{}{Seitenstil>Alias-}%

\begin{Declaration}
  \Macro{DeclarePageStyleByLayers}%
  \OParameter{Optionenliste}\\
  \hphantom{\XMacro{DeclarePageStyleByLayers}}\Parameter{Seitenstil-Name}%
  \Parameter{Ebenenliste}\\
  \Macro{DeclareNewPageStyleByLayers}%
  \OParameter{Optionenliste}\\
  \hphantom{\XMacro{DeclareNewPageStyleByLayers}}\Parameter{Seitenstil-Name}%
  \Parameter{Ebenenliste}\\
  \Macro{ProvidePageStyleByLayers}%
  \OParameter{Optionenliste}\\
  \hphantom{\XMacro{ProvidePageStyleByLayers}}\Parameter{Seitenstil-Name}%
  \Parameter{Ebenenliste}\\
  \Macro{RedeclarePageStyleByLayers}%
  \OParameter{Optionenliste}\\
  \hphantom{\XMacro{RedeclarePageStyleByLayers}}\Parameter{Seitenstil-Name}%
  \Parameter{Ebenenliste}%
\end{Declaration}
\BeginIndex{Cmd}{DeclarePageStyleByLayers}%
\BeginIndex{Cmd}{DeclareNewPageStyleByLayers}%
\BeginIndex{Cmd}{ProvidePageStyleByLayers}%
\BeginIndex{Cmd}{RedeclarePageStyleByLayers}%
\BeginIndex{}{Seitenstil>Ebenen-}%
\BeginIndex{}{Ebenen>Seitenstil}%
Diese Anweisungen deklarieren einen Seitenstil mit dem
Namen \Parameter{Seitenstil-Name}. Der Seitenstil besteht aus einer Anzahl von
Ebenen, die in der mit Komma separierten \PName{Ebenenliste} angegeben
sind. Es ist zu beachten\textnote{Achtung!}, dass sowohl
\PName{Seitenstil-Name} als auch \PName{Ebenenliste} voll expandierbar sein
müssen und die Expansion zu einer Reihe von Buchstaben führen sollte. Einige
andere Zeichen werden zwar toleriert, ihre Verwendung wird jedoch nicht
empfohlen.

Die \PName{Optionenliste} ist eine mit Komma separierte Liste von Optionen der
Form \texttt{\PName{Schlüssel}=\PName{Code}}. Diese Optionen können verwendet
werden, um zusätzliche Eigenschaften zu setzen und zusätzliche Möglichkeiten
zu nutzen. Derzeit werden sie verwendet, um Code an bestimmten Stellen der
Aktivierung oder Verwendung eines Seitenstils über Haken (engl. \emph{hooks})
auszuführen. Für allgemeine Informationen zu Haken sei auf die Einleitung zu
diesem Abschnitt verwiesen. Details zu den Haken und ihrer Bedeutung sind
\autoref{tab:scrlayer.pagestyle.hooks} zu entnehmen.

\begin{desclist}
  \desccaption{%
    Optionen und gleichnamige Haken für Ebenen-Seitenstile (in der Reihenfolge
    ihrer Abarbeitung)\label{tab:scrlayer.pagestyle.hooks}%
  }{%
    Optionen für die Haken von Ebenen-Seitenstilen (\emph{Fortsetzung})%
  }%
  \entry{\KOption{onselect}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn der
    Seitenstil beispielsweise mit \Macro{pagestyle} ausgewählt wird. Es ist zu
    beachten, dass \Macro{thispagestyle} selbst keinen Seitenstil unmittelbar
    auswählt, sondern der Seitenstil in diesem Fall erst innerhalb der
    Ausgaberoutine von \LaTeX{} aktiviert wird.%
  }%
  \entry{\KOption{oninit}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Seitenstil initialisiert wird. Beachten Sie,
    dass dies für jede Seite zweimal geschieht: einmal für Hintergrund-Ebenen
    und einmal für Vordergrund-Ebenen.%
  }%
  \entry{\KOption{ononeside}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn im
    einseitigen Modus die Ausgabe der Ebenen für den Seitenstil initialisiert
    wird. Beachten Sie, dass dies für jede Seite zweimal geschieht: einmal für
    Hintergrund-Ebenen und einmal für Vordergrund-Ebenen.%
  }%
  \entry{\KOption{ontwoside}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn im
    doppelseitigen Modus die Ausgabe der Ebenen für den Seitenstil
    initialisiert wird. Beachten Sie, dass dies für jede
    Seite zweimal geschieht: einmal für Hintergrund-Ebenen und einmal für
    Vordergrund-Ebenen.%
  }%
  \entry{\KOption{onoddpage}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Seitenstil auf einer rechten Seite
    initialisiert wird. Beachten Sie, dass dies für jede
    Seite zweimal geschieht: einmal für Hintergrund-Ebenen und einmal für
    Vordergrund-Ebenen. Beachten Sie außerdem, dass im
    einseitigen Modus alle Seiten rechte Seiten sind.%
  }%
  \entry{\KOption{onevenpage}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Seitenstil auf einer linken Seite initialisiert
    wird. Beachten Sie, dass dies für jede Seite zweimal
    geschieht: einmal für Hintergrund-Ebenen und einmal für
    Vordergrund-Ebenen. Beachten Sie außerdem, dass im
    einseitigen Modus keine linken Seiten existieren.%
  }%
  \entry{\KOption{onfloatpage}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Seitenstil auf einer Gleitumgebungsseite
    initialisiert wird. Beachten Sie, dass dies für jede
    Seite zweimal geschieht: einmal für Hintergrund-Ebenen und einmal für
    Vordergrund-Ebenen. Beachten Sie außerdem, dass
    Gleitumgebungsseiten nur diejenigen Seiten sind, auf denen eine oder
    mehrere p-platzierte Gleitumgebungen ausgegeben werden.%
  }%
  \entry{\KOption{onnonfloatpage}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Seitenstil auf einer Seite initialisiert wird,
    die keine Gleitumgebungsseite ist. Beachten Sie, dass
    dies für jede Seite zweimal geschieht: einmal für Hintergrund-Ebenen und
    einmal für Vordergrund-Ebenen. Beachten Sie außerdem,
    dass Gleitumgebungsseiten nur diejenigen Seiten sind, auf denen eine oder
    mehrere p-platzierte Gleitumgebungen ausgegeben werden, und auf anderen
    Seiten sehr wohl t-, b- oder h-platzierte Gleitumgebungen stehen können.%
  }%
  \entry{\KOption{onbackground}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Hintergrund einer Seite initialisiert
    wird. Beachten Sie, dass dies auf jeder Seite genau
    einmal der Fall ist.%
  }%
  \entry{\KOption{onforeground}\PName{Code}}{%
    Der \PName{Code} dieses Hakens wird immer dann ausgeführt, wenn die
    Ausgabe der Ebenen für den Vordergrund einer Seite initialisiert
    wird. Beachten Sie, dass dies auf jeder Seite genau
    einmal der Fall ist.%
  }%
\end{desclist}

Während die Anweisung
\Macro{DeclarePageStyleByLayers} %\important{\Macro{DeclarePageStyleByLayers}}%
                                 % Leider zu lang. Deshalb auch auf alle
                                 % weiteren verzichtet.
den Seitenstil immer definiert, erzeugt \Macro{DeclareNewPageStyleByLayers}
eine Fehlermeldung, falls bereits ein Seitenstil gleichen Namens
existiert. Beachten\textnote{Achtung!} Sie, dass die Deklaration eines
Seitenstils, der bereits ein Alias für einen anderen Seitenstil ist (siehe
beispielsweise \Macro{DeclareAliasPageStyle} zuvor in diesem Abschnitt) nicht
zu der Umdefinierung des angegebenen Alias-Seitenstils, sondern des realen
Seitenstils (siehe \Macro{GetRealPageStyle} zuvor in diesem Abschnitt) führt.

Im Unterschied dazu wird bei \Macro{ProvidePageStyleByLayers} der Seitenstil
unverändert erhalten, wenn bereits ein Seitenstil des Namens
\PName{Seitenstil-Name} existiert. Existiert kein solcher Seitenstil, so wird
er wie bei \Macro{DeclarePageStyleByLayers} definiert.

Die Anweisung \Macro{RedeclarePageStyleByLayers} wiederum erwartet, dass
bereits ein Seitenstil des Namens \PName{Seitenstil-Name} existiert und
definiert dessen realen Seitenstil dann um. Existiert jedoch noch kein
Seitenstil des angegebenen Namens, so resultiert daraus eine Fehlermeldung.

Beachten Sie auch die nachfolgenden Anmerkungen zum Pseudo-Seitenstil
\Pagestyle{@everystyle@}.%
\EndIndex{Cmd}{RedeclarePageStyleByLayers}%
\EndIndex{Cmd}{ProvidePageStyleByLayers}%
\EndIndex{Cmd}{DeclareNewPageStyleByLayers}%
\EndIndex{Cmd}{DeclarePageStyleByLayers}%


\begin{Declaration}
  \Pagestyle{@everystyle@}\\
  \Pagestyle{empty}
\end{Declaration}
\BeginIndex{Pagestyle}{@everystyle@}%
\BeginIndex{Pagestyle}{empty}%
Das Paket \Package{scrlayer} definiert von sich aus bereits zwei in gewisser
Weise spezielle Seitenstile. Der erste davon ist
\Pagestyle{@everystyle@}\important{\Pagestyle{@everystyle@}}. Dieser
Seitenstil sollte niemals als normaler Seitenstil beispielsweise mit
\Macro{pagestyle} oder \Macro{thispagestyle} oder als Ziel eines
Alias-Seitenstils verwendet werden. Stattdessen werden die Ebenen und Haken
dieses Seitenstils von allen anderen Ebenen-Seitenstilen mit verwendet. Dabei
werden die Haken von \Pagestyle{@everystyle@} jeweils vor den entsprechenden
Haken und die Ebenen jeweils vor den entsprechenden Ebenen des aktiven
Seitenstils ausgeführt. 

Damit ist das Hinzufügen einer Ebene zum Pseudo-Seitenstil
\Pagestyle{@everystyle@} oder von Code zu einem Haken dieses Seitenstils
vergleichbar mit dem Hinzufügen einer Ebene beziehungsweise von Haken-Code zu
allen Ebenen-Seitenstile. Der eine entscheidende Unterschied ist: Befehle, die
sich auf die Ebenen eines Seitenstils beziehen, das sind neben
\Macro{ForEachLayerOfPageStyle} beispielsweise auch die Anweisungen
\Macro{AddLayersToPageStyleBeforeLayer} oder
\Macro{AddLayersToPageStyleAfterLayer}, lassen die Ebenen des Seitenstils
\Pagestyle{@everystyle@} unberücksichtigt, wenn sie auf einen anderen
Ebenen-Seitenstil angewendet werden.

Der zweite etwas andere Ebenen-Seitenstil ist
\Pagestyle{empty}\important{\Pagestyle{empty}}. Bereits vom \LaTeX-Kern wird
ein Seitenstil dieses Namens definiert, der einen leeren Kopf und Fuß hat. Das
Paket \Package{scrlayer} definiert diesen Seitenstil als Ebenen-Seitenstil
ohne Ebenen um. Nichtsdestotrotz kann er wie jeder andere Ebenen-Seitenstil
verwendet werden. Der Hauptvorteil dieses Ebenen-Seitenstils gegenüber dem
ursprünglichen Seitenstil aus dem \LaTeX-Kern ist, dass er ebenfalls die Haken
und Ebenen des Pseudo-Seitenstils \Pagestyle{@everystyle@} ausführt.%
\EndIndex{Pagestyle}{empty}%
\EndIndex{Pagestyle}{@everystyle@}%


\begin{Declaration}
  \KOption{onpsselect}\PValue{Code}\\
  \KOption{onpsinit}\PValue{Code}\\
  \KOption{onpsoneside}\PValue{Code}\\
  \KOption{onpstwoside}\PValue{Code}\\
  \KOption{onpsoddpage}\PValue{Code}\\
  \KOption{onpsevenpage}\PValue{Code}\\
  \KOption{onpsfloatpage}\PValue{Code}\\
  \KOption{onpsnonfloatpage}\PValue{Code}\\
  \KOption{onpsbackground}\PValue{Code}\\
  \KOption{onpsforeground}\PValue{Code}
\end{Declaration}
\BeginIndex{Option}{onpsselect~=\PName{Code}}%
\BeginIndex{Option}{onpsinit~=\PName{Code}}%
\BeginIndex{Option}{onpsoneside~=\PName{Code}}%
\BeginIndex{Option}{onpstwoside~=\PName{Code}}%
\BeginIndex{Option}{onpsoddpage~=\PName{Code}}%
\BeginIndex{Option}{onpsevenpage~=\PName{Code}}%
\BeginIndex{Option}{onpsfloatpage~=\PName{Code}}%
\BeginIndex{Option}{onpsnonfloatpage~=\PName{Code}}%
\BeginIndex{Option}{onpsbackground~=\PName{Code}}%
\BeginIndex{Option}{onpsforeground~=\PName{Code}}%
Für jeden der Haken aus \autoref{tab:scrlayer.pagestyle.hooks} existiert
außerdem eine \KOMAScript-Option. Die Namen der \KOMAScript-Optionen ähneln
den Namen der Optionen für die Befehle zur Deklaration von
Ebenen-Seitenstilen. Es wird lediglich ein »\texttt{ps}« nach dem
»\texttt{on}« am Anfang des Namens eingefügt. Die Werte dieser
\KOMAScript-Optionen werden als Anfangswerte für die entsprechenden Haken
verwendet. Dieser Anfangswert wird dann um alle Werte, die dem entsprechenden
Haken in der \PName{Optionenliste} der Deklarationsbefehle zugewiesen werden,
erweitert. Der Anfangswert kann mit Hilfe der Anweisung
\Macro{ModifyLayerPageStyleOptions}, die später in diesem Abschnitt erklärt
wird, entfernt werden.%
\EndIndex{Option}{onpsforeground~=\PName{Code}}%
\EndIndex{Option}{onpsbackground~=\PName{Code}}%
\EndIndex{Option}{onpsnonfloatpage~=\PName{Code}}%
\EndIndex{Option}{onpsfloatpage~=\PName{Code}}%
\EndIndex{Option}{onpsevenpage~=\PName{Code}}%
\EndIndex{Option}{onpsoddpage~=\PName{Code}}%
\EndIndex{Option}{onpstwoside~=\PName{Code}}%
\EndIndex{Option}{onpsoneside~=\PName{Code}}%
\EndIndex{Option}{onpsinit~=\PName{Code}}%
\EndIndex{Option}{onpsselect~=\PName{Code}}%

\begin{Declaration}
  \KOption{deactivatepagestylelayers}\PName{Ein-Aus-Wert}\\
  \Macro{ForEachLayerOfPageStyle}\Parameter{Seitenstil-Name}%
  \Parameter{Code}\\
  \Macro{ForEachLayerOfPageStyle*}\Parameter{Seitenstil-Name}%
  \Parameter{Code}
\end{Declaration}
\BeginIndex{Option}{deactivatepagestylelayers~=\PName{Ein-Aus-Wert}}%
\BeginIndex{Cmd}{ForEachLayerOfPageStyle}%
\BeginIndex{Cmd}{ForEachLayerOfPageStyle*}%
Solange \KOMAScript-Option \Option{deactivatepagestylelayers} nicht
aktiviert ist, kann mit \Macro{ForEachLayerOfPageStyle} für jede Ebene des
Seitenstils mit dem Namen \PName{Seitenstil-Name} beliebiger \PName{Code}
ausgeführt werden. Innerhalb von \PName{Code} dient dabei \PValue{\#1} als
Platzhalter für den Namen der gerade abgearbeiteten Ebene.
\begin{Example}
  Angenommen, Sie wollen die Namen aller Ebenen des Seitenstils
  \PValue{scrheadings} als Komma-separierte Liste, so können Sie dies mit
\begin{lstcode}
  \newcommand*\commaatlist{}
  \ForEachLayerOfPageStyle{scrheadings}{%
    \commaatlist#1\gdef\commaatlist{, }}
  \let\commaatlist\relax
\end{lstcode}
  erreichen.
\end{Example}
Die Verwendung von \Macro{gdef} an Stelle von \Macro{def} ist im Beispiel
notwendig, weil \PName{Code} innerhalb einer Gruppe ausgeführt wird, um
unerwünschte Seiteneffekte zu minimieren. Die Anweisung \Macro{gdef} definiert
\Macro{commaatlist} jedoch global um, so dass beim Aufruf des Codes für die
nächste Ebene die Änderung Bestand hat.

Alternativ\ChangedAt{v3.18}{\Package{scrlayer}} hätte man auch zwar mit
\Macro{def}, dafür aber mit der Sternvariante \Macro{ForEachLayerOfPageStyle*}
arbeiten können. Diese Form verzichtet bei der Ausführung von \PName{Code} auf
eine zusätzliche Gruppe. Allerdings muss der Anwender dann selbst
sicherstellen, dass \PName{Code} keine unerwünschten Seiteneffekte
hat. Insbesondere würde die Deaktivierung der Ebenen mit
\OptionValue{deactivatepagestylelayers}{true} innerhalb von \PName{Code} dann
über den Aufruf von \Macro{ForEachLayerOfPageStyle*} hinaus Bestand haben.

Diverse Anweisungen von \Package{scrlayer} setzen intern selbst ebenfalls
\Macro{ForEachLayerOfPageStyle} ein. Auch deren Funktion kann daher über die
\KOMAScript-Option \Option{deactivatepagestylelayers} verändert werden. Diese
Option kann also verwendet werden, um alle Ebenen aller Seitenstile temporär
zu deaktivieren oder zu verstecken.
%
\EndIndex{Cmd}{ForEachLayerOfPageStyle*}%
\EndIndex{Cmd}{ForEachLayerOfPageStyle}%
\EndIndex{Option}{deactivatepagestylelayers~=\PName{Ein-Aus-Wert}}%

\begin{Declaration}
  \Macro{AddLayersToPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}\\
  \Macro{AddLayersAtBeginOfPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}\\
  \Macro{AddLayersAtEndOfPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}\\
  \Macro{RemoveLayersFromPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}%
\end{Declaration}
\BeginIndex{Cmd}{AddLayersToPageStyle}%
\BeginIndex{Cmd}{AddLayersAtBeginOfPageStyle}%
\BeginIndex{Cmd}{AddLayersAtEndOfPageStyle}%
\BeginIndex{Cmd}{RemoveLayersFromPageStyle}%
Diese Anweisungen können verwendet werden, um Ebenen zu einem Seitenstil
hinzuzufügen oder davon zu entfernen. Der Seitenstil wird dabei über seinen
\PName{Seitenstil-Name} referenziert. Die Ebenen werden in einer durch Komma
separierten \PName{Ebenenliste} angegeben. 

Sowohl die Anweisung \Macro{AddLayersToPageStyle} als auch die Anweisung
\Macro{AddLayersAtEndOfPageStyle}\textnote{hinzufügen am Ende} fügt die Ebenen
am Ende der Ebenenliste des Seitenstils ein. Logisch liegen die neu
hinzugefügten Ebenen also über oder vor den bereits vorhandenen Ebenen, wobei
Hintergrund-Ebenen natürlich weiterhin logisch hinter der Textebene und damit
auch hinter allen Vordergrund-Ebenen liegen.

Die Anweisung \Macro{AddLayersAtBeginOfPageStyle}\textnote{hinzufügen am
  Anfang} fügt die Ebenen hingegen am Anfang der Ebenenliste des Seitenstils
ein. Dabei werden die Ebenen in der Reihenfolge am Anfang eingefügt, in der
sie auch in der \PName{Ebenenliste} stehen. Damit wird die Ebene, die ganz am
Ende von \PName{Ebenenliste} steht, nach dem Einfügen die erste und damit die
unterste oder hinterste Ebene (jeweils entweder der Vordergrund- oder der
Hintergrundebenen) sein.

Der Versuch, mit Hilfe von
\Macro{RemoveLayersFromPageStyle}\textnote{entfernen} Ebenen von einem
Seitenstil zu entfernen, die gar nicht Teil des Seitenstils sind, wird
ignoriert, führt also nicht zu einer Fehlermeldung. Dagegen ist der Versuch,
Ebenen zu einem Seitenstil, der kein Ebenen-Seitenstil ist und auch kein
Alias-Seitenstil, der zu einem Ebenen-Seitenstil führt, hinzuzufügen oder von
einem solchen zu entfernen ein Fehler und wird als solcher gemeldet.%
\EndIndex{Cmd}{RemoveLayersFromPageStyle}%
\EndIndex{Cmd}{AddLayersAtEndOfPageStyle}%
\EndIndex{Cmd}{AddLayersAtBeginOfPageStyle}%
\EndIndex{Cmd}{AddLayersToPageStyle}%

\begin{Declaration}
  \Macro{AddLayersToPageStyleBeforeLayer}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}\\
  \hphantom{\XMacro{AddLayersToPageStyleBeforeLayer}}%
  \Parameter{Referenzebenen-Name}\\
  \Macro{AddLayersToPageStyleAfterLayer}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}\\
  \hphantom{\XMacro{AddLayersToPageStyleAfterLayer}}%
  \Parameter{Referenzebenen-Name}%
\end{Declaration}
\BeginIndex{Cmd}{AddLayersToPageStyleBeforeLayer}%
\BeginIndex{Cmd}{AddLayersToPageStyleAfterLayer}%
Diese beiden Befehle ähneln den vorangegangenen. Allerdings wird hier
zusätzlich ein \PName{Referenzebenen-Name} angegeben. Die Ebenen des über den
\PName{Seitenstil-Name} angegebenen Seitenstils werden nach dieser
Referenzebene durchsucht. Die Ebenen der \PName{Ebenenliste} werden dann
vor\textnote{hinzufügen vor/nach Ebene}
respektive nach jedem Auf"|treten der Referenzebene in die Ebenen des
Seitenstils eingefügt. Dabei bleibt die Reihenfolge der Ebenen der
\PName{Ebenenliste} erhalten.%|

Ist die Referenzebene nicht Bestandteil des Seitenstils, so wird auch nichts
eingefügt. Ist der Seitenstil hingegen kein Ebenen-Seitenstil und auch kein
Alias-Seitenstil, der zu einem Ebenen-Seitenstil führt, so wird ein Fehler
gemeldet.%
\EndIndex{Cmd}{AddLayersToPageStyleAfterLayer}%
\EndIndex{Cmd}{AddLayersToPageStyleBeforeLayer}%

\begin{Declaration}
  \Macro{UnifyLayersAtPageStyle}\Parameter{Seitenstil-Name}
\end{Declaration}
\BeginIndex{Cmd}{UnifyLayersAtPageStyle}%
Bei den Befehlen zur Definition eines Seitenstils oder zum Hinzufügen von
Ebenen zu einem Seitenstil wird nicht darauf geachtet, ob eine Ebene mehrfach
Bestandteil eines Seitenstils ist oder wird. Dies ist also durchaus
zulässig. In den meisten Fällen hat es allerdings keinen Sinn, eine Ebene
mehrfach als Bestandteil eines Seitenstils zu haben. Daher kann mit Hilfe von
\Macro{UnifyLayersAtPageStyle} dafür gesorgt werden, dass alle
Ebenen-Dubletten vom Seitenstil mit dem angegebenen \PName{Seitenstil-Name}
entfernt werden.

Es ist zu beachten\textnote{Achtung!}, dass sich dabei die Reihenfolge der
Ebenen ändern kann. Wird also eine spezielle Reihenfolge gewünscht, sollten
stattdessen alle Ebenen entfernt und die gewünschten Ebenen in der erwarteten
Reihenfolge neu hinzugefügt werden. In einem solchen Fall ist
\Macro{UnifyLayersAtPageStyle} also nicht geeignet.%
\EndIndex{Cmd}{UnifyLayersAtPageStyle}%

\begin{Declaration}
  \Macro{ModifyLayerPageStyleOptions}%
  \Parameter{Seitenstil-Name}\Parameter{Optionenliste}\\
  \Macro{AddToLayerPageStyleOptions}%
  \Parameter{Seitenstil-Name}\Parameter{Optionenliste}%
\end{Declaration}
\BeginIndex{Cmd}{ModifyLayerPageStyleOptions}%
\BeginIndex{Cmd}{AddToLayerPageStyleOptions}%
Mit diesen beiden Anweisungen können die Optionen und damit die Haken eines
Ebenen-Seitenstils nachträglich verändert werden. Bei
\Macro{ModifyLayerPageStyleOptions}\textnote{Seitenstil-Optionen ändern}
werden dabei genau die Optionen, die in der durch Komma separierten
\PName{Optionenliste} angegeben sind, auf die dortigen neuen Werte gesetzt. Die
bisherigen Werte gehen dabei verloren. Es sind alle Optionen aus
\autoref{tab:scrlayer.pagestyle.hooks},
\autopageref{tab:scrlayer.pagestyle.hooks} erlaubt. Optionen beziehungsweise
Haken, die nicht in der \PName{Optionenliste} angegeben sind, bleiben hingegen
unverändert. Diese Anweisung ist damit auch die einzige Möglichkeit, die
globalen Voreinstellungen der \KOMAScript-Optionen von einem Seitenstil zu
entfernen.

Die Anweisung \Macro{AddToLayerPageStyleOptions}\textnote{Seitenstil-Optionen
  erweitern} dagegen überschreibt die bisher vorhandenen Werte nicht, sondern
fügt die neuen zu den bisherigen hinzu oder -- genauer gesagt -- hängt die
neuen Werte an die alten an.%
\EndIndex{Cmd}{AddToLayerPageStyleOptions}%
\EndIndex{Cmd}{ModifyLayerPageStyleOptions}%

\begin{Declaration}
  \Macro{IfLayerPageStyleExists}%
  \Parameter{Seitenstil-Name}\\
  \hphantom{\XMacro{IfLayerPageStyleExists}}%
  \Parameter{Dann-Code}\Parameter{Sonst-Code}\\
  \Macro{IfRealLayerPageStyleExists}%
  \Parameter{Seitenstil-Name}\\
  \hphantom{\XMacro{IfRealLayerPageStyleExists}}%
  \Parameter{Dann-Code}\Parameter{Sonst-Code}%
\end{Declaration}
\BeginIndex{Cmd}{IfLayerPageStyleExists}%
\BeginIndex{Cmd}{IfRealLayerPageStyleExists}%
Mit diesen Anweisungen kann Code in Abhängigkeit davon ausgeführt werden, ob
ein Seitenstil ein Ebenen-Seitenstil ist oder nicht. Dabei führt
\Macro{IfLayerPageStyleExists} den \PName{Dann-Code} nur dann aus, wenn
\PName{Seitenstil-Name} der Name eines Ebenen-Seitenstils oder der Name eines
Alias-Seitenstils ist, der zu einem Ebenen-Seitenstil führt. Anderenfalls
führt die Anweisung den \PName{Sonst-Code} aus.

Die Anweisung \Macro{IfRealLayerPageStyleExists} geht einen Schritt weiter und
führt den \PName{Dann-Code} nur dann aus, wenn der über
\PName{Seitenstil-Name} angegebene Seitenstil selbst ein Ebenen-Seitenstil
ist. Im Falle eines Alias-Seitenstils führt diese Anweisung also selbst dann
\PName{Sonst-Code} aus, wenn dieser Alias-Seitenstil zu einem
Ebenen-Seitenstil führt.%
\EndIndex{Cmd}{IfRealLayerPageStyleExists}%
\EndIndex{Cmd}{IfLayerPageStyleExists}%

\begin{Declaration}
  \Macro{IfLayerAtPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenen-Name}\\
  \hphantom{\XMacro{IfLayerAtPageStyle}}%
  \Parameter{Dann-Code}\Parameter{Sonst-Code}\\
  \Macro{IfSomeLayersAtPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}\\
  \hphantom{\XMacro{IfSomeLayersAtPageStyle}}%
  \Parameter{Dann-Code}\Parameter{Sonst-Code}\\
  \Macro{IfLayersAtPageStyle}%
  \Parameter{Seitenstil-Name}\Parameter{Ebenenliste}\\
  \hphantom{\XMacro{IfLayersAtPageStyle}}%
  \Parameter{Dann-Code}\Parameter{Sonst-Code}%
\end{Declaration}
\BeginIndex{Cmd}{IfLayerAtPageStyle}%
\BeginIndex{Cmd}{IfSomeLayersAtPageStyle}%
\BeginIndex{Cmd}{IfLayersAtPageStyle}%
Mit diesen Anweisungen kann überprüft werden, ob ein oder mehrere Ebenen
Bestandteil eines Seitenstils sind. \Macro{IfLayerAtPageStyle}\textnote{genau
  eine Ebene}
erwartet dabei nach dem \PName{Seitenstil-Name} im ersten Argument im zweiten
Argument genau einen \PName{Ebenen-Name}. Ist die entsprechende Ebene
Bestandteil des Seitenstils, so wird der \PName{Dann-Code} ausgeführt,
anderenfalls der \PName{Sonst-Code}.

Im Unterschied dazu erlauben  \Macro{IfSomeLayersAtPageStyle}
und \Macro{IfLayersAtPageStyle} im zweiten Argument eine durch Komma
separierte \PName{Ebenenliste}. Dabei führt
\Macro{IfSomeLayersAtPageStyle}\textnote{mindestens eine Ebene}
den \PName{Dann-Code} bereits aus, wenn \emph{mindestens eine} der Ebenen
Bestandteil des Seitenstils ist. Dagegen führt
\Macro{IfLayersAtPageStyle}\textnote{alle Ebenen} den
\PName{Dann-Code} nur aus, wenn \emph{alle} Ebenen Bestandteil des Seitenstils
sind. Ist die Bedingung nicht erfüllt, so wird jeweils \PName{Sonst-Code}
ausgeführt.

Durch geeignete Schachtelung sind auch komplexe Bedingungen abbildbar. Gibt
man statt einer \PName{Ebenenliste} jeweils nur einen \PName{Ebenen-Name} an,
so sind alle drei Anweisungen gleichbedeutend.%
\EndIndex{Cmd}{IfLayersAtPageStyle}%
\EndIndex{Cmd}{IfSomeLayersAtPageStyle}%
\EndIndex{Cmd}{IfLayerAtPageStyle}%

\begin{Declaration}
  \Macro{DestroyRealLayerPageStyle}\Parameter{Ebenen-Seitenstil-Name}
\end{Declaration}
\BeginIndex{Cmd}{DestroyRealLayerPageStyle}%
Mit dieser Anweisung kann ein Ebenen-Seitenstil aus \LaTeX-Sicht wieder
undefiniert werden. Dies gilt jedoch nur, wenn es einen Ebenen-Seitenstil mit
dem Namen \PName{Ebenen-Seitenstil-Name} auch tatsächlich gibt. Handelt es sich
stattdessen um einen Alias-Seitenstil -- auch wenn dieser zu einem
Ebenen-Seitenstil führt -- oder um einen anderen Seitenstil oder ist gar kein
Seitenstil mit dem Namen \PName{Ebenen-Seitenstil-Name} bekannt, so geschieht
nichts, die Anweisung wird ignoriert.

Falls \PName{Ebenen-Seitenstil-Name} der Name des aktuellen Seitenstils ist, so
wird der aktuelle Seitenstil auf eine Art leerer Seitenstil gesetzt. Falls der
Spezial-Seitenstil, der durch \Macro{thispagestyle} gesetzt wurde, auf
\PName{Ebenen-Seitenstil-Name} lautet, so wird dieser einfach nur
zurückgesetzt. Die vorherige Anweisung \Macro{thispagestyle} verliert damit
ihre aktuelle Auswirkung.

Es ist zu beachten\textnote{Achtung!}, dass die Ebenen des Seitenstils nicht
automatisch mit vernichtet werden. Falls Sie die Ebenen ebenfalls vernichten
möchten, so können Sie dies beispielsweise mit:
\begin{lstcode}[belowskip=\dp\strutbox]
  \ForEachLayerOfPageStyle{...}{\DestroyLayer{#1}}
\end{lstcode}
vor der Vernichtung des Seitenstils selbst erreichen.

Die Anweisung ist dazu bestimmt, innerhalb des Arguments \PName{Code} von
\Macro{scrlayerOnAutoRemoveInterface} (siehe
\autoref{sec:scrlayer.enduserinterfaces},
\autopageref{desc:scrlayer.cmd.scrlayerOnAutoRemoveInterface}) verwendet zu
werden, um Seitenstile, die als Teil eines Endanwender-Interfaces definiert
wurden, beim automatischen Entfernen dieses Interfaces mit zu entfernen.%
\EndIndex{Cmd}{DestroyRealLayerPageStyle}%
\EndIndex{}{Ebenen>Seitenstil}%
\EndIndex{}{Seitenstil>Ebenen-}%
\EndIndex{}{Seiten>Stil}%

\LoadCommon{20} % \section{Höhe von Kopf und Fuß}

\LoadCommon{21} % \section{Beeinflussung der Inhalte von Seitenstilen}

\section{Definition und Verwaltung von Schnittstellen für Endanwender}
\seclabel{enduserinterfaces}

Das Paket \Package{scrlayer} stellt eine experimentelle Benutzerschnittstelle
zur Verfügung um (konkurrierende) Schnittstellen für Endanwender definieren
und verwalten zu können. Möglicherweise wird diese Schnittstelle langfristig
wieder aus \Package{scrlayer} verschwinden und dann stattdessen von
\Package{scrbase} übernommen werden. Derzeit ist die Schnittstelle aber noch
hoch experimentell und wird daher von eigenen Befehlen innerhalb von
\Package{scrlayer} nur für Unterpakete von \Package{scrlayer} bereit
gestellt. Es empfiehlt sich beim aktuellen Entwicklungsstand nicht, sich
darauf zu verlassen, dass die automatische Entfernung einer konkurrierenden
Schnittstelle funktioniert. Stattdessen sollte die Verwendung konkurrierender
Schnittstellen vermieden werden.

Dieser Abschnitt beschreibt lediglich die Schnittstellen"=Anweisungen für die
Definition einer Endanwender-Schnittstelle. Für Endanwender selbst ist es
damit von geringem Interesse. Vielmehr richtet sich dieser Teil der Anleitung
an Autoren von Paketen und Klassen, die auf \Package{scrlayer}
aufbauen. Endanwender finden Informationen zu konkreten
Endanwender-Schnittstellen in \autoref{cha:scrlayer-scrpage},
\autoref{cha:scrlayer-scrpage-experts} und \autoref{cha:scrlayer-notecolumn}.

\begin{Declaration}
  \Macro{scrlayerInitInterface}\OParameter{Schnittstellen-Name}
\end{Declaration}
\BeginIndex{Cmd}{scrlayerInitInterface}%
Mit dieser Anweisung wird eine neue Schnittstelle mit dem Namen
\PName{Schnittstellen-Name} registriert. Der
\PName{Schnittstellen-Name} muss einzigartig sein. Das bedeutet, dass eine
Schnittstelle gleichen Namens noch nicht registriert sein darf. Sollte dies
doch der Fall sein, so wird ein Fehler ausgegeben.

Diese Anweisung sollte immer ganz am Anfang einer Endanwender-Schnittstelle
stehen. Daher wird sie hier auch zuerst erklärt. Wird das optionale Argument
-- einschließlich der eckigen Klammern -- weggelassen, so wird dafür
\PValue{\Macro{@currname}.\Macro{@currext}} verwendet. Für Klassen und
Pakete ist dies der Dateiname der Klasse respektive des Pakets. Aber
selbstverständlich kann jede andere Zeichenfolge der Kategorie \emph{letter}
oder \emph{other} verwendet werden. Dies ist beispielsweise sinnvoll, wenn
eine Klasse oder ein Paket mehrere Endanwender-Schnittstellen definiert.%
\EndIndex{Cmd}{scrlayerInitInterface}%

\begin{Declaration}
  \KOption{forceoverwrite}\PName{Ein-Aus-Wert}\\
  \KOption{autoremoveinterfaces}\PName{Ein-Aus-Wert}\\
  \Macro{scrlayerAddToInterface}%
  \OParameter{Schnittstellen-Name}\\
  \hphantom{\XMacro{scrlayerAddToInterface}}%
  \Parameter{Befehl}\Parameter{Code}\\
  \Macro{scrlayerAddCsToInterface}%
  \OParameter{Schnittstellen-Name}\\
  \hphantom{\XMacro{scrlayerAddCsToInterface}}%
  \Parameter{Befehlssequenz}\Parameter{Code}
\end{Declaration}
\BeginIndex{Option}{forceoverwrite}%
\BeginIndex{Option}{autoremoveinterfaces}%
\BeginIndex{Cmd}{scrlayerAddToInterface}%
\BeginIndex{Cmd}{scrlayerAddCsToInterface}%
Eine der besonderen Eigenschaften der Endanwender-Schnittstellen von
\Package{scrlayer} ist es, dass die Schnittstelle verwendete Befehle (auch
bekannt als \emph{Makros} oder engl. \emph{macros}) registrieren sollte. Dies
kann mit \Macro{scrlayerAddToInterface} erfolgen. Das optionale Argument
\PName{Schnittstellen-Name} entspricht hier dem Namen, der mit
\Macro{scrlayerInitInterface} zuvor registriert wurde.

Werden\textnote{Achtung!} Anweisungen nicht nur während des Ladens einer
Klasse oder eines Pakets, sondern auch zur Laufzeit definiert, so ist das
optionale Argument auch dann zu verwenden, wenn es dem Dateinamen der Klasse
beziehungsweise des Pakets entspricht, da die Werte von \Macro{@currname} und
\Macro{@currext} nur während des Ladens Gültigkeit besitzen.

Das erste obligatorische Argument ist der \PName{Befehl}\footnote{\PName{Befehl}
  besteht aus einem umgekehrten Schrägstrich (engl. \emph{backslash}) gefolgt
  von einer \PName{Befehlssequenz}, die entweder aus Zeichen der
  Kategorie \emph{letter} oder aus genau einem Zeichen der Kategorie
  \emph{other} besteht, oder aus einem Zeichen der Kategorie \texttt{active}
  (ohne umgekehrten Schrägstrich davor).}, der zu der
Endanwender-Schnittstelle hinzugefügt werden soll. Falls der Befehl
definiert werden kann, erfolgt dies. Außerdem wird dann der Befehl auf
\Macro{relax} gesetzt und \PName{Code} wird ausgeführt. Innerhalb von
\PName{Code} kann der \PName{Befehl} dann beispielsweise mit Hilfe von
\Macro{newcommand} definiert werden.

Wann aber kann ein \PName{Befehl}\textnote{definierbare Befehle} definiert
werden? Ist ein \PName{Befehl} undefiniert oder \Macro{relax}, so kann er
immer definiert werden. Wurde ein \PName{Befehl} bereits definiert \emph{und}
für eine andere Endanwender-Schnittstelle registriert \emph{und} wurde auch die
\KOMAScript-Option \Option{autoremoveinterface} aktiviert, so wird diese
andere Endanwender-Schnittstelle automatisch entfernt, der \PName{Befehl} auf
\Macro{relax} gesetzt und für die angegebene neue Endanwender-Schnittstelle
registriert. Damit ist \PName{Befehl} auch dann definierbar. Falls ein
\PName{Befehl} bereits definiert ist, \emph{aber nicht} Teil einer anderen
Endanwender-Schnittstelle ist, \emph{und} falls die \KOMAScript-Option
\Option{forceoverwrite} aktiviert wurde, wird \PName{Befehl} ebenfalls
\Macro{relax} und für die angegebene Endanwender-Schnittstelle
registriert. Der \PName{Befehl} ist also auch in diesem Fall definierbar. In
allen anderen Fällen ist er jedoch nicht definierbar, also insbesondere, falls
er bereits definiert ist und die \KOMAScript-Optionen
\Option{autoremoveinterface} und \Option{forceoverwrite} deaktiviert sind.

Die Anweisung \Macro{scrlayerAddCsToInterface} arbeitet ganz ähnlich der
vorgenannten Anweisung \Macro{scrlayerAddToInterface}. Allerdings erwartet sie
als erstes Argument keinen \PName{Befehl}, sondern eine
\PName{Befehlssequenz}\footnote{Eine \PName{Befehlssequenz} muss voll
  expandierbar sein und ihre Expansion muss zu Zeichen der Kategorie
  \emph{letter}, \emph{other} oder \emph{space} führen.}.%
%
\EndIndex{Cmd}{scrlayerAddCsToInterface}%
\EndIndex{Cmd}{scrlayerAddToInterface}%
\EndIndex{Option}{autoremoveinterfaces}%
\EndIndex{Option}{forceoverwrite}%

\begin{Declaration}
  \Macro{scrlayerOnAutoRemoveInterface}%^^A
  \OParameter{Schnittstellen-Name}\Parameter{Code}
\end{Declaration}
\BeginIndex{Cmd}{scrlayerOnAutoRemoveInterface}%
Für den Fall, dass die Endanwender-Schnittstelle mit dem angegebenen
\PName{Schnittstellen-Name} automatisch entfernt wird (siehe
\KOMAScript-Option \Option{autoremoveinterface} zuvor in diesem Abschnitt)
kann zusätzlich \PName{Code} ausgeführt werden. Dies kann beispielsweise
verwendet werden, um Ebenen oder Seitenstile automatisch mit zu vernichten
(siehe \Macro{DestroyLayer}, \Macro{DestroyAliasPageStyle}, and
\Macro{DestroyRealLayerPageStyle}), die auf Befehlen der
Endanwender-Schnittstelle beruhen. Bezüglich der Voreinstellung für das
optionale Argument sei auf die Erklärung zu
\Macro{scrlayerInitInterface} verwiesen.%
\EndIndex{Cmd}{scrlayerOnAutoRemoveInterface}%
%
\EndIndex{Package}{scrlayer}%
\EndIndex{}{Ebenen}%

%%% Local Variables:
%%% mode: latex
%%% mode: flyspell
%%% coding: iso-latin-1
%%% ispell-local-dictionary: "de_DE"
%%% TeX-master: "../guide"
%%% End: 



% LocalWords:  Vordergrundebene Sternvariante Gleitseiten Hintergrundebenen
%  LocalWords:  Ausgabebeschränkungen Grafikausgabe Textausgabe Textebenen
%  LocalWords:  Standardgrundlinie Grafikebenen Standardtextzeile
%  LocalWords:  Platzierungsbefehle Ebeneneigenschaft Satzspiegelkonstruktion
%  LocalWords:  Kreisschlagen Buchseitenkanon spätmittelalterlichen
