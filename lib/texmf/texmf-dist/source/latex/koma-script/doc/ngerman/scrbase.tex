% ======================================================================
% scrbase.tex
% Copyright (c) Markus Kohm, 2002-2016
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX 
% version 2005/12/01 or later and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrbase.tex
% Copyright (c) Markus Kohm, 2002-2016
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3c, verteilt und/oder veraendert werden.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3c ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 oder spaeter und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
% 
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
%
% Package scrbase for Package and Class Authors
% Maintained by Markus Kohm
%
% ----------------------------------------------------------------------
%
% Paket scrbase für Paket- und Klassenautoren
% Verwaltet von Markus Kohm
%
% ======================================================================

\KOMAProvidesFile{scrbase.tex}
                 [$Date: 2016-03-09 18:09:14 +0100 (Wed, 09 Mar 2016) $
                  KOMA-Script package scrbase]

\chapter{Grundlegende Funktionen im Paket \Package{scrbase}}
\labelbase{scrbase}

\BeginIndex{Package}{scrbase}%

Das Paket \Package{scrbase} stellt einige grundlegende Funktionen bereit, die
sich an Autoren von Paketen und Klassen richten. Dabei kann es nicht nur für
Wrapper-Klassen genutzt werden, die ihrerseits eine \KOMAScript-Klasse
laden. Auch Autoren von Klassen, die ansonsten nichts mit \KOMAScript{} zu tun
haben, können von der Funktionalität von \Package{scrbase} profitieren.

\section{Laden des Pakets}
\seclabel{loadit}

Während Anwender ein Paket mit Hilfe von \Macro{usepackage} laden, verwenden
Paket- und Klassenautoren \Macro{RequirePackage}. Autoren von Wrapper-Paketen
nutzen auch \Macro{RequirePackageWithOptions}. Bei Verwendung von
\Macro{RequirePackage} können wie bei \Macro{usepackage} Optionen angegeben
werden. Demgegenüber erhält das Paket bei \Macro{RequirePackageWithOptions}
alle Optionen, mit denen zuvor das Wrapper-Paket geladen wurde. Näheres zu
diesen Anweisungen ist \cite{latex:clsguide} zu entnehmen.

Das Paket \Package{scrbase} benötigt intern die Funktionalität des Pakets
\Package{keyval}\IndexPackage{keyval}. Diese kann auch vom Paket
\Package{xkeyval} zur Verfügung gestellt werden. Bei Bedarf lädt
\Package{scrbase} selbst \Package{keyval}. 

Das Paket \Package{keyval} erlaubt es, Schlüssel zu definieren und diesen
Werten zuzuweisen.  Auch die Optionen, die \Package{scrbase} bereitstellt,
verwenden die \Package{keyval}-Syntax: \PName{Schlüssel}\texttt{=}\PName{Wert}.

\begin{Declaration}
  \KOption{internalonly}\PName{Wert}
\end{Declaration}
\BeginIndex{Option}{internalonly~=\PName{Wert}}%
Von \Package{scrbase} werden einige Verzweigungsanweisungen
bereitgestellt. Dabei verwendet es primär die Bezeichnungen
\Macro{scr@\PName{Name}}. Es handelt sich somit um interne
Anweisungen. Diese werden auch intern von \KOMAScript{} verwendet. Paket- und
Klassenautoren können diese Anweisungen ebenfalls verwenden, sollten sie aber
nicht umdefinieren. Da einige dieser Anweisungen auch für Benutzer nützlich
sein können, werden die gleichen Anweisungen normalerweise auch als
\Macro{\PName{Name}} bereitgestellt. Da eventuell andere Pakete
gleichnamige Anweisungen mit anderer Syntax bereitstellen könnten und es so zu
Konflikten kommen könnte, kann der Anwender die Definition von
\Macro{\PName{Name}} verhindern. Dazu gibt er entweder die Option
ohne Wertangabe an. In diesem Fall werden nur die internen
Verzweigungsanweisungen definiert. Oder er gibt genau die Anweisungen, die
nicht definiert werden sollen, als Wert an, wobei er »\Macro{}« durch
»\texttt{/}« ersetzt.

Paket- und Klassenautoren sollten diese Option normalerweise nicht verwenden.
Anwender können sie mit oder ohne Wertangabe entweder als globale Option bei
\Macro{documentclass} oder per \Macro{PassOptionsToPackage} angeben.
\begin{Example}
  Der Anwender will nicht, dass die Anweisungen \Macro{ifVTeX} und
  \Macro{ifundefinedorrelax} von \Package{scrbase} definiert werden. Also
  verwendet er beim Laden der Klasse:
\begin{lstcode}
  \documentclass%
    [internalonly=/ifVTeX/ifundefinedorrelax]%
    {foo}
\end{lstcode}
  Der Klassenname \Class{foo} wird hier als Platzhalter für irgendeine Klasse
  verwendet.  Die Bedeutungen der Anweisungen \Macro{ifVTeX} und
  \Macro{ifundefinedorrelax} sowie weitere Verzweigungsanweisungen sind
  \autoref{sec:scrbase.if}, %\autopageref{desc:scrbase.cmd.ifVTeX} und
  %\autopageref{desc:scrbase.cmd.ifundefinedorrelax} 
  ab \autopageref{sec:scrbase.if} zu entnehmen.
\end{Example}
%
\EndIndex{Option}{internalonly~=\PName{Wert}}%


\section{Schlüssel als Eigenschaften von Familien und deren Mitgliedern}
\seclabel{keyvalue}

Wie bereits in \autoref{sec:scrbase.loadit} erwähnt, setzt \Package{scrbase}
bei Schlüsseln und deren Werten auf das Paket \Package{keyval}. Allerdings
erweitert es dessen Funktionalität. Während bei \Package{keyval} ein Schlüssel
einer Familie gehört, kennt \Package{scrbase} zu jeder Familie auch noch
Familienmitglieder. Ein Schlüssel kann dann sowohl einer Familie als auch
einem oder mehreren Familienmitgliedern gehören. Außerdem kann ein Wert einem
Schlüssel eines Familienmitglieds, einem Schlüssel einer Familie oder einem
Schlüssel aller Familienmitglieder zugewiesen werden.

\begin{Declaration}
  \Macro{DefineFamily}\Parameter{Familienname}\\
  \Macro{DefineFamilyMember}\OParameter{Mitglied}\Parameter{Familienname}
\end{Declaration}
\BeginIndex{Cmd}{DefineFamily}%
\BeginIndex{Cmd}{DefineFamilyMember}%
\Package{scrbase} muss aus verschiedenen Gründen die Mitglieder einer Familie
kennen. Daher ist es notwendig, eine neue Familie zunächst mit
\Macro{DefineFamily} zu definieren und so eine leere Mitgliederliste zu
erzeugen. Ist die Familie bereits definiert, so geschieht schlicht nichts. Es
wird also auch nicht eine bereits existierende Mitgliederliste überschrieben.

Ein neues Mitglied wird der Familie dann mit der Anweisung
\Macro{DefineFamilyMember} bekannt gegeben. Existiert die Familie nicht, so
führt dies zu einer Fehlermeldung. Existiert das Mitglied bereits, so
geschieht nichts. Wird kein Mitglied angegeben, so bleibt das Mitglied nicht
etwa leer, sondern es wird
»\texttt{.}\Macro{@currname}\texttt{.}\Macro{@currext}« angenommen. Während
des Ladens einer Klasse oder eines Pakets sind \Macro{@currname} und
\Macro{@currext} zusammen der Dateiname.

Theoretisch wäre es möglich, mit einem leeren optionalen Argument
\PName{Mitglied} auch ein Mitglied ohne Name zu definieren. Dies würde jedoch
der Familie selbst entsprechen. Es wird empfohlen als \PName{Familienname} nur
Buchstaben und Ziffern zu verwenden und das \PName{Mitglied} immer mit einem
anderen Zeichen, vorzugsweise einem Punkt, zu beginnen. Anderenfalls könnte
es passieren, dass sich Mitglieder einer Familie mit Mitgliedern anderer
Familien überdecken.

\Package{scrbase} definiert selbst bereits die Familie »\PValue{KOMA}« und
fügt ihr das Mitglied »\PValue{.scrbase.sty}« hinzu. Grundsätzlich ist die
Familie »\PValue{KOMA}« \KOMAScript{} vorbehalten. Es wird empfohlen für
eigene Pakete den Namen des Gesamtpakets als Familie und den Namen einzelner
Pakete im Gesamtpaket als Mitglied zu verwenden.
%
\begin{Example}
  Angenommen Sie schreiben ein neues Gesamtpaket »Fleischermeister«. Darin
  befinden sich die Pakete \File{Salami.sty}, \File{Mettwurst.sty} und
  \File{Krakauer.sty}. Daher entscheiden Sie sich für den Familienname
  »\PValue{Fleischermeister}« und fügen in jedem der Pakete die Zeilen
% Umbruchoptimierung: listings
\begin{lstcode}[aboveskip=0pt plus \dp\strutbox]
  \DefineFamily{Fleischermeister}
  \DefineFamilyMember{Fleischermeister}
\end{lstcode}
  ein. Dadurch wird beim Laden der drei genannten Pakete der Familie
  »\PValue{Fleischermeister}« je nach Paket eines der drei Mitglieder
  »\PValue{.Salami.sty}«, »\PValue{.Mettwurst.sty}« und
  »\PValue{.Krakauer.sty}« zugefügt. Am Ende sind dann alle drei Mitglieder
  definiert.
\end{Example}
%
\EndIndex{Cmd}{DefineFamilyMember}%
\EndIndex{Cmd}{DefineFamily}%

\begin{Declaration}
  \Macro{DefineFamilyKey}\OParameter{Mitglied}\Parameter{Familie}%
                         \Parameter{Schlüssel}\\
  \hphantom{\Macro{DefineFamilyKey}}%
                         \OParameter{Säumniswert}\Parameter{Aktion}\\
  \Macro{FamilyKeyState}\\
  \Macro{FamilyKeyStateUnknown}\\
  \Macro{FamilyKeyStateProcessed}\\
  \Macro{FamilyKeyStateUnknownValue}\\
  \Macro{FamilyKeyStateNeedValue}
\end{Declaration}
\BeginIndex{Cmd}{DefineFamilyKey}%
\BeginIndex{Cmd}{FamilyKeyState}%
\BeginIndex{Cmd}{FamilyKeyStateUnknown}%
\BeginIndex{Cmd}{FamilyKeyStateProcessed}%
\BeginIndex{Cmd}{FamilyKeyStateUnknownValue}%
\BeginIndex{Cmd}{FamilyKeyStateNeedValue}%
Mit dieser Anweisung wird ein \PName{Schlüssel} definiert. Ist ein
\PName{Mitglied} angegeben, so ist der \PName{Schlüssel} eine Eigenschaft
dieses Mitglieds der angegebenen \PName{Familie}. Ist kein Mitglied
angegeben, so wird wieder das Mitglied
»\texttt{.}\Macro{@currname}\texttt{.}\Macro{@currext}« angenommen. Wird
später dem \PName{Schlüssel} ein Wert zugewiesen, so wird \PName{Aktion}
ausgeführt, wobei der Wert als Parameter übergeben wird. Innerhalb von
\PName{Aktion} steht also »\lstinline{#1}« für den übergebenen Wert. Wurde
kein Wert übergeben, so wird stattdessen der \PName{Säumniswert}
eingesetzt. Falls kein \PName{Säumniswert} angegeben wird, kann später der
\PName{Schlüssel} nur mit Wertübergabe verwendet werden.

\begin{Explain}
  \phantomsection\label{explain:scrbase.macro.DefineFamilyKey}%
  Letztlich führt
\begin{lstcode}[belowskip=\dp\strutbox,escapeinside=»«]
  \DefineFamilyKey[»\PName{Mitglied}«]{»\PName{Familie}«}{»\PName{Schlüssel}«}
                  [»\PName{Säumniswert}«]{»\PName{Aktion}«}
\end{lstcode}
  zu dem Aufruf
\begin{lstcode}[belowskip=\dp\strutbox,moretexcs={define@key},escapeinside=»«]
  \define@key{»\PName{Familie\,Mitglied}«}{»\PName{Schlüssel}«}
             [»\PName{Säumniswert}«]{»\PName{erweiterte Aktion}«}
\end{lstcode}
  wobei \Macro{define@key} im \Package{keyval}-Paket\IndexPackage{keyval}
  definiert ist (siehe \cite{package:keyval}). Allerdings kommen zu dem Aufruf
  von \Macro{define@key} noch einige zusätzliche Vorkehrungen und auch die
  \PName{Aktion} wird um zusätzliche Vorkehrungen erweitert.
\end{Explain}

Erfolg\ChangedAt{v3.12}{\Package{scrbase}} oder Misserfolg der Ausführung der
\PName{Aktion} werden über
\Macro{FamilyKeyState} %\important{\Macro{FamilyKeyState}} % einige davon sind
                                                           % schlicht zu breit!
an \Package{scrbase} zurück gemeldet, damit dieses je nach Bedarf und
Verwendung des Schlüssels weitere Maßnahmen ergreifen kann. In der
Voreinstellung ist \Macro{FamilyKeyState} identisch mit
\Macro{FamilyKeyStateUnknown}. Das bedeutet, dass es nicht sicher ist, ob der
Schlüssel korrekt verarbeitet werden konnte. Findet \Package{scrbase} nach
Ausführung der \PName{Aktion} noch immer diesen Zustand vor, so wird ein
Hinweis in die \File{log}-Datei geschrieben und im weiteren der Zustand
\Macro{FamilyKeyStateProcessed} angenommen.

Der Zustand
\Macro{FamilyKeyStateProcessed} %\important{\Macro{FamilyKeyStateProcessed}}
signalisiert, dass der Schlüssel und die Wertzuweisung an den Schlüssel
vollständig abgeschlossen wurde und alles in Ordnung ist. Auf den Zustand kann
einfach durch Aufruf von \Macro{FamilyKeyStateProcessed} selbst umgeschaltet
werden.

Der Zustand
\Macro{FamilyKeyStateUnknownValue} %\important{\Macro{FamilyKeyStateUnknownValue}}
signalisiert, dass der Schlüssel zwar verarbeitet wurde, ihm jedoch ein Wert
zugewiesen werden sollte, der nicht erlaubt ist. Diesen Zustand meldet
beispielsweise \Package{typearea}, wenn versucht wird, an Option
\Option{twoside} den Wert \PValue{unbekannt} zuzuweisen. Die Umschaltung auf
den Zustand erfolgt einfach durch Aufruf von
\Macro{FamilyKeyStateUnknownValue} selbst.

Der Zustand
\Macro{FamilyKeyStateNeedValue} %\important{\Macro{FamilyKeyStateNeedValue}}
signalisiert, dass der Schlüssel nicht verarbeitet werden konnte, weil er
zwingend einen Wert erwartet, er aber ohne Wertzuweisung aufgerufen
wurde. Dieser Zustand wird automatisch gesetzt, wenn ein Schlüssel, der keinen
\PName{Säumniswert} besitzt, ohne Wertzuweisung verwendet wird. Theoretisch
wäre aber auch eine explizite Umschaltung darauf durch Aufruf von
\Macro{FamilyKeyStateNeedValue} selbst möglich.

Desweiteren können zusätzliche Fehlerzustände definiert werden, indem man
\Macro{FamilyKeyState} auf eine kurze Meldung umdefiniert. In der Regel
sollten jedoch die vier vordefinierten Zustände verwendet werden.

\begin{Example}
  Nehmen wir an, jedes der drei Pakete aus dem letzten Beispiel soll einen
  Schlüssel \PValue{Aufschnitt} erhalten. Wird dieser aufgerufen, so soll in
  jedem der Pakete entsprechend dem Aufrufwert ein Schalter gesetzt
  werden. Für das Paket \Package{Salami} könnte das beispielsweise so
  aussehen:
\begin{lstcode}
  \newif\if@Salami@Aufschnitt
  \DefineFamilyKey{Fleischermeister}%
                  {Aufschnitt}[true]{%
    \expandafter\let\expandafter\if@Salami@Aufschnitt
    \csname if#1\endcsname
    \FamilyKeyStateProcessed
  }
\end{lstcode}
  Als Wert ist daher beim Aufruf \PValue{true} oder \PValue{false}
  erlaubt. Ein Test auf unerlaubte Werte existiert in diesem Beispiel
  nicht. Stattdessen wird immer zurückgemeldet, dass der Schlüssel vollständig
  und korrekt verarbeitet wurde. Wird der Schlüssel später verwendet, so muss
  entweder einer der erlaubten Werte zugewiesen oder ein Aufruf ohne
  Wertzuweisung verwendet werden. In letzterem Fall wird der Säumniswert
  \PName{true} zugewiesen.

  Für die anderen beiden Pakete kann das fast identisch definiert
  werden. Lediglich die Zeichenfolge »\texttt{Salami}« ist jeweils zu
  ersetzen.
\end{Example}
%
\EndIndex{Cmd}{FamilyKeyStateNeedValue}%
\EndIndex{Cmd}{FamilyKeyStateUnknownValue}%
\EndIndex{Cmd}{FamilyKeyStateProcessed}%
\EndIndex{Cmd}{FamilyKeyStateUnknown}%
\EndIndex{Cmd}{FamilyKeyState}%
\EndIndex{Cmd}{DefineFamilyKey}%

\begin{Declaration}
  \Macro{RelaxFamilyKey}\OParameter{Mitglied}\Parameter{Familie}%
  \Parameter{Schlüssel}
\end{Declaration}
\BeginIndex{Cmd}{RelaxFamilyKey}%
Wurde\ChangedAt{v3.15}{\Package{scrbase}} \PName{Schlüssel} zuvor als
\PName{Mitglied} der \PName{Familie} definiert, so wird diese Definition
quasi aufgehoben. Der \PName{Schlüssel} ist dann für dieses \PName{Mitglied}
der \PName{Familie} nicht mehr definiert. Die Verwendung für einen
\PName{Schlüssel}, der für dieses \PName{Mitglied} der \PName{Familie} gar
nicht definiert ist, ist ebenfalls zulässig.%
\EndIndex{Cmd}{RelaxFamilyKey}%

\begin{Declaration}
  \Macro{FamilyProcessOptions}\OParameter{Mitglied}\Parameter{Familie}
\end{Declaration}
\BeginIndex{Cmd}{FamilyProcessOptions}%
Grundsätzlich ist die Erweiterung der Schlüssel von Familien auf Familien
und Familienmitglieder dazu gedacht, dass Schlüssel beziehungsweise die
Wertzuweisung an Schlüssel als ganz normale Klassen- oder Paketoptionen
verwendet werden können. Diese Anweisung stellt daher eine Erweiterung von
\Macro{ProcessOptions*} aus dem \LaTeX-Kern dar (siehe
\cite{latex:clsguide}). Dabei verarbeitet die Anweisung nicht nur Optionen,
die mit \Macro{DeclareOption} definiert wurden. Es werden auch alle Schlüssel
eines angegebenen Familienmitglieds abgearbeitet. Wird das optionale Argument
\PName{Mitglied} nicht angegeben, so wird wieder das Mitglied
»\texttt{.}\Macro{@currname}\texttt{.}\Macro{@currext}« verwendet.

Eine Besonderheit sind Schlüssel, die nicht einem Familienmitglied, sondern
der Familie selbst zugeordnet sind, bei der also das Mitglied leer geblieben
ist. Diese werden ebenfalls gesetzt und zwar noch bevor der Schlüssel des
Mitglieds gesetzt wird.
\begin{Example}
  Wenn in den Paketen aus den zurückliegenden Beispielen die Zeile
\begin{lstcode}
  \FamilyProcessOptions{Fleischermeister}
\end{lstcode}
  ergänzt wird, so kann der Anwender bereits beim Laden der Pakete die
  Eigenschaft \Option{Aufschnitt} wählen. Wird die Option global, also bei
  \Macro{documentclass} angegeben, so wird die Eigenschaft automatisch bei
  allen drei Paketen gesetzt, wenn alle drei Pakete geladen werden.
\end{Example}
Es\textnote{Achtung!} wird darauf hingewiesen, dass bei Paketen globale
Optionen vor den lokal dem Paket zugewiesenen Optionen ausgeführt
werden. Während bei der Abarbeitung der globalen Optionen unbekannte Werte für
Optionen dazu führen, dass darüber lediglich in der \File{log}-Datei
informiert und die Option ansonsten ignoriert wird, führt dies bei lokalen
Optionen zu einer Fehlermeldung.

Man kann \Macro{FamilyProcessOptions} wahlweise als Erweiterung von
\Macro{ProcessOption*} oder als Erweiterung des
\PName{Schlüssel=Wert}-Mechanismus von \Package{keyval} verstehen. Letztlich
werden mit Hilfe von \Macro{FamilyProcessOptions} aus
\PName{Schlüssel=Wert}-Paaren Optionen.

Wie\textnote{Achtung!} auch \Macro{ProcessOptions} darf
\Macro{FamilyProcessOptions} nicht während der Ausführung von Optionen
verwendet werden. Es ist also insbesondere auch nicht erlaubt, innerhalb der
Ausführung von Optionen Pakete zu laden.%, die selbst
%\Macro{FamilyProcessOptions} verwenden.%
%
\EndIndex{Cmd}{FamilyProcessOptions}%

\begin{Declaration}
  \Macro{BeforeFamilyProcessOptions}\OParameter{Mitglied}\Parameter{Familie}%
                                    \Parameter{Code}%
\end{Declaration}
\BeginIndex{Cmd}{BeforeFamilyProcessOptions}%
Insbesondere\ChangedAt{v3.18}{\Package{scrbase}} Autoren von Wrapper-Klassen
wünschen manchmal, in ein Paket oder eine Klasse noch vor der Verarbeitung der
Optionen eines zukünftig geladenen Pakets oder einer zukünftig geladenen
Klasse mit \Macro{FamilyProcessOptions} eingreifen zu können. Dies ist mit
\Macro{BeforeFamilyProcessOptions} möglich. Das Paket \Package{scrbase} bietet
dafür einen sogenannten Haken (engl. \emph{hook}). Diesem kann man mit
\Macro{BeforeFamilyProcessOptions} neuen \PName{Code} hinzufügen. Die
Parameter \PName{Mitglied} und \PName{Familie} entsprechen dabei denen von
\Macro{FammilyProcessOptions}. Allerdings kann man auch den Haken von
Familien-Mitgliedern \PName{Code} hinzufügen, wenn bisher die \PName{Familie}
oder das \PName{Mitglied} noch gar nicht definiert ist.

Der Haken eines Familien-Mitglieds wird übrigens nach dessen Ausführung
automatisch gelöscht. Verwendet man hingegen ein leeres \PName{Mitglied}, so
wird dieser Haken für alle Mitglieder der \PName{Familie} ausgeführt und
bleibt auch über die Ausführung hinaus erhalten.

\begin{Example}
  Sie schreiben ein Paket, das selbst \Package{Mettwurst} lädt. Allerdings
  wollen Sie nicht, dass für dieses Paket die Option \Option{Aufschnitt}
  gesetzt werden kann. Daher deaktivieren sie die Option vor dem Laden des
  Pakets über \Macro{BeforeFamilyProcessOptions}.
\begin{lstcode}
  \RequirePackage{scrbase}
  \BeforeFamilyProcessOptions[.Mettwurst.sty]{Fleischermeister}{%
    \RelaxFamilyKey[.Mettwurst.sty]{Fleischermeister}{Aufschnitt}%
  }
  \RequirePackageWithOptions{Mettwurst}
\end{lstcode}
  Versucht nun jemand Ihr Paket mit Option \Option{Aufschnitt} zu laden, so
  meldet das Paket \Package{Mettwurst}, dass diese Option nicht bekannt
  ist. Wird die Option \Option{Aufschnitt} als globale Option angegeben, so
  ignoriert Paket \Package{Mettwurst} diese. Voreinstellungen innerhalb des
  Pakets beispielsweise mit \Macro{FamilyExecuteOptions} noch vor
  \Macro{FamilyProcessOptions} sind allerdings davon unabhängig.
\end{Example}
\EndIndex{Cmd}{BeforeFamilyProcessOptions}%


\begin{Declaration}
  \Macro{FamilyExecuteOptions}\OParameter{Mitglied}\Parameter{Familie}%
  \Parameter{Optionenliste}
\end{Declaration}
\BeginIndex{Cmd}{FamilyExecuteOptions}%
Diese Anweisung stellt eine Erweiterung von
\Macro{ExecuteOptions} aus dem \LaTeX-Kern dar (siehe
\cite{latex:clsguide}). Dabei verarbeitet die Anweisung nicht nur Optionen,
die mit \Macro{DeclareOption} definiert wurden. Es werden auch alle Schlüssel
eines angegebenen Familienmitglieds abgearbeitet. Wird das optionale Argument
\PName{Mitglied} nicht angegeben, so wird wieder das Mitglied
»\texttt{.}\Macro{@currname}\texttt{.}\Macro{@currext}« verwendet.

Eine Besonderheit sind Schlüssel, die nicht einem Familienmitglied, sondern
der Familie selbst zugeordnet sind, bei der also das Mitglied leer geblieben
ist. Diese werden ebenfalls gesetzt und zwar noch bevor der Schlüssel des
Mitglieds gesetzt wird.
\begin{Example}
  Angenommen, die Option \Option{Aufschnitt} soll in den zurückliegenden
  Beispielen bereits als Voreinstellung gesetzt werden, so müssen die Pakete
  nur um die Zeile
\begin{lstcode}
  \FamilyExecuteOptions{Fleischermeister}{Aufschnitt}
\end{lstcode}
  ergänzt werden.
\end{Example}

Wird\ChangedAt{v3.20}{\Package{scrbase}} \Macro{FamilyExecuteOptions} mit
einer nicht definierten Option in der \PName{Optionenliste} aufgerufen, so
wird normalerweise ein Fehler ausgegeben. Eine Ausnahme von dieser Regel ist,
wenn für das \PName{Mitglied} eine Option namens \Option{@else@} definiert
wurde. In diesem Fall wird statt der unbekannten Option eben diese Option
\Option{@else@} verwendet. Innerhalb von \KOMAScript{} wird das
beispielsweise verwendet, um die Stil-Option bei der Definition von
Gliederungsbefehlen vor allen anderen auszuwerten.

Diese Anweisung darf auch innerhalb der Ausführung von Optionen verwendet
werden.%
%
\EndIndex{Cmd}{FamilyExecuteOptions}%


\begin{Declaration}
  \Macro{FamilyOptions}\Parameter{Familie}\Parameter{Optionenliste}%
\end{Declaration}
\BeginIndex{Cmd}{FamilyOptions}%
Die \PName{Optionenliste} hat dabei die Form:
\begin{flushleft}\begin{tabular}{l}
    \PName{Schlüssel}\texttt{=}\PName{Wert}\texttt{,}%
    \PName{Schlüssel}\texttt{=}\PName{Wert} \dots
\end{tabular}\vskip\dp\strutbox\end{flushleft}
wobei für \PName{Schlüssel}, für die ein Säumniswert definiert ist, die
Wertzuweisung natürlich auch entfallen kann.

Im Gegensatz zu normalen Optionen, die mit \Macro{DeclareOption} definiert
wurden, können die \PName{Schlüssel} auch noch nach dem Laden der Klasse oder
des Pakets gesetzt werden. Dazu verwendet der Anwender
\Macro{FamilyOptions}. Dabei werden die \PName{Schlüssel} aller Mitglieder der
angegebenen \PName{Familie} gesetzt. Existiert ein \PName{Schlüssel} auch als
Eigenschaft der Familie selbst, so wird dieser Familien-Schlüssel zuerst
gesetzt. Danach folgen die Mitglieder-Schlüssel in der Reihenfolge, in der die
Mitglieder definiert wurden. Existiert ein angegebener \PName{Schlüssel} weder
für die Familie noch für ein Mitglied der Familie, so wird von
\Macro{FamilyOptions} ein Fehler ausgegeben. Dies geschieht ebenfalls, wenn
zwar für einige Mitglieder ein Schlüssel existiert, jedoch jedes dieser
Mitglieder über \Macro{FamilyKeyState} einen Fehler zurückmeldet.
\begin{Example}
  Sie ergänzen das Fleischermeister-Projekt um ein weiteres Paket
  \Package{Wurstsalat}. Wird dieses Paket verwendet, so sollen alle
  Wurstpakete zunächst einmal Aufschnitt produzieren:
\begin{lstcode}
  \ProvidesPackage{Wurstsalat}%
                  [2008/05/06 nonsense package]
  \RequirePackage{scrbase}
  \DefineFamily{Fleischermeister}
  \DefineFamilyMember{Fleischermeister}
  \FamilyProcessOptions{Fleischermeister}\relax
  \FamilyOptions{Fleischermeister}{Aufschnitt}
\end{lstcode}
  Sollte noch kein Wurstpaket geladen sein, so würde nun eine Fehlermeldung
  wegen der nicht definierten Option »\Option{Aufschnitt}« ausgegeben. Das
  kann vermieden werden, indem vor der letzten Zeile für das Paket selbst
  ebenfalls ein entsprechender Schlüssel definiert wird:
\begin{lstcode}
  \DefineFamilyKey{Fleischermeister}%
                  {Aufschnitt}[true]{}%
\end{lstcode}
  Allerdings produzieren so Wurstpakete, die nach
  \Package{Wurstsalat} geladen werden, keinen Aufschnitt. Dies kann man
  ebenfalls ändern:
\begin{lstcode}
  \AtBeginDocument{%
    \DefineFamilyKey[.Wurstsalat.sty]%
                    {Fleischermeister}%
                    {Aufschnitt}[true]{}%
  }
  \DefineFamilyKey{Fleischermeister}%
                  {Aufschnitt}[true]{%
    \AtBeginDocument{\FamilyOptions{Fleischermeister}%
                                   {Aufschnitt=#1}}%
  }%
\end{lstcode}
  Somit wird zunächst während \Macro{begin}\PParameter{document} die Option so
  definiert, dass sie für das Paket \Package{Wurstsalat} keine Funktion mehr
  ausübt. Da zu diesem Zeitpunkt \Macro{@currname} und \Macro{@currext} nicht
  mehr gültig sind, muss dabei das optionale Argument von
  \Macro{DefineFamilyKey} verwendet werden. Bis zu dieser Umdefinierung der
  Option wird jedoch eine Definition verwendet, die während
  \Macro{begin}\PParameter{document} die Option erneut für die gesamte Familie
  ausführt und damit auch für andere Wurstpakete setzt.
\end{Example}
%
\EndIndex{Cmd}{FamilyOptions}%

\begin{Declaration}
  \Macro{FamilyOption}\Parameter{Familie}%
  \Parameter{Option}\Parameter{Werteliste}%
\end{Declaration}
\BeginIndex{Cmd}{FamilyOption}%
Neben Optionen, die sich gegenseitig ausschließende Werte besitzen, kann es
auch Optionen geben, die gleichzeitig mehrere Werte annehmen können. Für diese
wäre es bei Verwendung von \Macro{FamilyOptions} notwendig, der Option mehrfach
einen Wert zuzuweisen und dabei die Option selbst mehrfach
anzugeben. Stattdessen kann man einfach mit \Macro{FamilyOption} einer
einzigen \PName{Option} eine ganze \PName{Werteliste} zuweisen. Die
\PName{Werteliste} ist dabei eine durch Komma separierte Liste von Werten:
\begin{flushleft}\begin{tabular}{l}
    \PName{Wert}\texttt{,}\PName{Wert} \dots
\end{tabular}\end{flushleft}
In diesem Zusammenhang sei darauf hingewiesen, dass die Verwendung eines
Kommas in einem Wert möglich ist, wenn man den Wert in geschweifte Klammern
setzt. Die weitere Funktionsweise ist der vorhergehenden Erklärung zu
\Macro{FamilyOptions} zu entnehmen.
\begin{Example}
  Das Paket \Package{Wurstsalat} soll eine Option bekommen, über die man
  weitere Zutaten bestimmen kann. Für jede Zutat wird dabei wieder ein
  Schalter gesetzt.
\begin{lstcode}
  \newif\if@salatmit@Zwiebeln
  \newif\if@salatmit@Gurken
  \newif\if@salatmit@Peperoni
  \DefineFamilyKey{Fleischermeister}{SalatZusatz}{%
    \csname @salatmit@#1true\endcsname
  }
\end{lstcode}
  Es wurden hier die drei Zutaten »Zwiebeln«, »Gurken« und »Peperoni«
  definiert. Eine Fehlerbehandlung für den Fall, dass der Anwender unbekannte
  Zutaten fordert, existiert nicht.

  Für einen Salat mit Zwiebeln und Gurken, kann der Anwender
\begin{lstcode}
  \FamilyOptions{Fleischermeister}{%
    SalatZusatz=Zwiebeln,SalatZusatz=Gurken}
\end{lstcode}
  oder einfach
\begin{lstcode}
  \FamilyOption{Fleischermeister}%
               {SalatZusatz}{Zwiebeln,Gurken}
\end{lstcode}
  verwenden.
\end{Example}
%
\EndIndex{Cmd}{FamilyOption}%


\begin{Declaration}
  \Macro{AtEndOfFamilyOptions}\Parameter{Aktion}%
\end{Declaration}
\BeginIndex{Cmd}{AtEndOfFamilyOptions}%
Manchmal\ChangedAt{v3.12}{\Package{scrbase}} ist es vorteilhafter, wenn nicht
jede Wertzuweisung an eine Option unmittelbar eine \PName{Aktion} auslöst,
sondern dies erst geschieht, wenn alle Wertzuweisungen innerhalb eines Aufrufs
von \Macro{FamilyProcessOptions}\IndexCmd{FamilyProcessOptions} oder
\Macro{FamilyExecuteOptions}\IndexCmd{FamilyExecuteOptions} beziehungsweise
\Macro{FamilyOptions}\IndexCmd{FamilyOptions} oder
\Macro{FamilyOption}\IndexCmd{FamilyOptions} abgeschlossen sind. Genau das ist
mit Hilfe von \Macro{AtEndOfFamilyOptions} möglich. Die Rückmeldung von
Fehlerzuständen ist über diese Anweisung jedoch ebenso wenig möglich, wie die
Verwendung dieser Anweisung außerhalb der Ausführung von Optionen.
%
\EndIndex{Cmd}{AtEndOfFamilyOptions}%


\begin{Declaration}
  \Macro{FamilyBoolKey}\OParameter{Mitglied}\Parameter{Familie}%
  \Parameter{Schlüssel}\Parameter{Schaltername}\\
  \Macro{FamilySetBool}\Parameter{Familie}%
  \Parameter{Schlüssel}\Parameter{Schaltername}\Parameter{Wert}
\end{Declaration}
\BeginIndex{Cmd}{FamilyBoolKey}%
\BeginIndex{Cmd}{FamilySetBool}%
In den vorherigen Beispielen wurden schon mehrfach Schalter gesetzt. Im
Beispiel der Option \Option{Aufschnitt} war es dabei notwendig, dass der
Anwender als Wert \PValue{true} oder \PValue{false} angibt. Es existierte
keine Fehlerbehandlung, falls der Anwender einen falschen Wert verwendet. Da
solche booleschen Schalter ein häufiger Anwendungsfall sind, kann man sie bei
\Package{scrbase} einfach mit \Macro{FamilyBoolKey} definieren. Dabei sind die
Argumente \PName{Mitglied}, \PName{Familie} und \PName{Schlüssel} die gleichen
wie bei \Macro{DefineFamilyKey} (siehe
\autopageref{desc:scrbase.cmd.DefineFamilyKey}). Das Argument
\PName{Schaltername} ist der Name eines Schalter ohne den Präfix
\Macro{if}. Existiert dieser Schalter noch nicht, so wird er automatisch
definiert und mit \PName{false} voreingestellt. Intern verwendet
\Macro{FamilyBoolKey} dann \Macro{FamilySetBool} als \PName{Aktion} für
\Macro{DefineFamilyKey}. Der Säumniswert für eine solche Option ist immer
\PValue{true}.

\Macro{FamilySetBool} wiederum versteht als \PName{Wert} neben \PValue{true}
auch die Werte \PValue{on} und \PValue{yes} zum Einschalten und neben
\PValue{false} auch die Werte \PValue{off} und \PValue{no} zum
Ausschalten. Wird ein unbekannter Wert übergeben, so wird die Anweisung
\Macro{FamilyUnknownKeyValue} mit den Argumenten \PName{Familie},
\PName{Schlüssel} und \PName{Wert} aufgerufen und so \Macro{FamilyKeyState}
entsprechend gesetzt. Dadurch wird dann gegebenenfalls eine Meldung über
eine unbekannte Wertzuweisung ausgegeben (siehe auch
\autopageref{desc:scrbase.cmd.FamilyUnknownKeyValue} und
\autopageref{desc:scrbase.cmd.FamilyKeyState}).
\begin{Example}
  Der Schlüssel \Option{Aufschnitt} soll in den Wurstpaketen etwas robuster
  definiert werden. Außerdem sollen alle Wurstpakete denselben Schalter
  verwenden, so dass entweder alle Wurstpakete Aufschnitt produzieren oder
  keines.
\begin{lstcode}
  \FamilyBoolKey{Fleischermeister}{Aufschnitt}%
                                  {@Aufschnitt}
\end{lstcode}
  Ein Test, ob Aufschnitt produziert wird, sähe dann so aus:
\begin{lstcode}
  \if@Aufschnitt
     ...
  \else
     ...
  \fi
\end{lstcode}
  Dies wäre dann in allen drei Wurstpaketen identisch. Damit könnte man
  prinzipiell die Eigenschaft »Aufschnitt« auch als Eigenschaft der Familie
  definieren:
\begin{lstcode}[moretexcs={define@key}]
  \@ifundefined{if@Aufschnitt}{%
    \expandafter\newif\csname if@Aufschnitt\endcsname
  }{}%
  \DefineFamilyKey[]{Fleischermeister}
                    {Aufschnitt}[true]{%
    \FamilySetBool{Fleischermeister}{Aufschnitt}%
                                    {@Aufschnitt}%
                                    {#1}%
  }
\end{lstcode}
  oder einfacher
\begin{lstcode}
  \FamilyBoolKey[]{Fleischermeister}{Aufschnitt}%
                                    {@Aufschnitt}
\end{lstcode}
  unter Ausnutzung des weiterführenden Hinweises auf
  \autopageref{explain:scrbase.macro.DefineFamilyKey}, der nicht nur für
  \Macro{DefineFamilyKey}, sondern entsprechend auch für \Macro{FamilyBoolKey}
  gilt.

  Da \Macro{FamilyKeyState} bereits von \Macro{FamilySetBool} gesetzt wird,
  kann innerhalb der Definition der Option mit Hilfe von
  \Macro{DefineFamilyKey} der Status gegebenenfalls auch abgefragt werden. So
  könnte man im ersten Fall beispielsweise nach \Macro{FamilySetBool} einen
  Test der Art:
\begin{lstcode}
  \ifx\FamilyKeyState\FamilyKeyStateProcessed
      ...
  \else
      ...
  \fi   
\end{lstcode}
  ergänzen, um zusätzliche Aktionen in Abhängigkeit davon, ob
  \Macro{FamilySetBool} erfolgreich war oder nicht, auszuführen. Es ist zu
  beachten, dass an dieser Stelle unbedingt ein Test mit Hilfe von \Macro{ifx}
  vorzunehmen ist. Expandierende Tests wie \Macro{ifstr} sind hier zu
  vermeiden.
\end{Example}
%
\EndIndex{Cmd}{FamilySetBool}%
\EndIndex{Cmd}{FamilyBoolKey}


\begin{Declaration}
  \Macro{FamilyNumericalKey}\OParameter{Mitglied}\Parameter{Familie}%
                            \Parameter{Schlüssel}\\
  \hphantom{\XMacro{FamilyNumericalKey}}%
                            \OParameter{Säumniswert}\Parameter{Makroname}%
  \Parameter{Werteliste}\\
  \Macro{FamilySetNumerical}\Parameter{Familie}\Parameter{Schlüssel}\\
  \hphantom{\XMacro{FamilySetNumerical}}%
                            \Parameter{Makroname}\Parameter{Werteliste}%
  \Parameter{Wert}
\end{Declaration}
\BeginIndex{Cmd}{FamilyNumericalKey}%
\BeginIndex{Cmd}{FamilySetNumerical}%
Während Schalter nur zwei Werte annehmen können, gibt es auch Schlüssel, die
mehrere Werte kennen. So kann beispielsweise eine Ausrichtung nicht nur links
oder nicht links, sondern beispielsweise links, mittig oder rechts
sein. Intern unterscheidet man solche Einstellungen dann gerne mit Hilfe von
\Macro{ifcase}. Diese \TeX-Anweisung erwartet wiederum einen nummerischen
Wert. Daher heißt bei \Package{scrbase} die Anweisung, mit der man via
\PName{Schlüssel} einem Makro eine Definition zuweisen kann, entsprechend
\Macro{FamilyNumericalKey}. Die \PName{Werteliste} hat dabei die Form
\begin{flushleft}\vskip\dp\strutbox\begin{tabular}{l}
    \Parameter{Wert}\Parameter{Definition}\texttt{,}%
    \Parameter{Wert}\Parameter{Definition} %
    \dots
\end{tabular}\vskip\dp\strutbox\end{flushleft}
Über diese \PName{Werteliste} werden so nicht nur die erlaubten Werte für den
\PName{Schlüssels} angegeben. Für jeden erlaubten \PName{Wert} wird auch
gleich angegeben, wie bei Verwendung desselben das Makro
\Macro{\PName{Makroname}} definiert werden soll. Üblicherweise werden als
\PName{Definition} schlicht Zahlenwerte angegeben. Es sind aber auch andere
Angaben möglich. Derzeit gibt es aber die Einschränkung, dass
\PName{Definition} voll expandierbar sein muss und bei der Zuweisung auch
expandiert wird.
\begin{Example}
  Die Wurst für den Wurstsalat kann unterschiedlich geschnitten werden. So
  wäre es denkbar, dass der Aufschnitt einfach ungeschnitten bleibt oder in
  grobe oder feine Streifen geschnitten werden soll. Diese Information soll in
  der Anweisung \Macro{Schnitt} gespeichert werden.
\begin{lstcode}
  \FamilyNumericalKey{Fleischermeister}%
                     {SalatSchnitt}{Schnitt}{%
                       {Kein}{Kein},{Nein}{Kein},%
                       {Grob}{Grob},%
                       {Fein}{Fein}%
                     }
\end{lstcode}
  Dass nicht geschnitten werden soll, kann in diesem Fall vom Anwender sowohl
  mit
\begin{lstcode}
  \FamilyOptions{Fleischermeister}{SalatSchnitt=Kein}
\end{lstcode}
  als auch mit
\begin{lstcode}
  \FamilyOptions{Fleischermeister}{SalatSchnitt=Nein}
\end{lstcode}
  angegeben werden. In beiden Fällen würde \Macro{Schnitt} mit dem Inhalt
  \PValue{Kein} definiert. Es kann durchaus sinnvoll sein, dem Anwender wie in
  diesem Beispiel mehrere Werte für denselben Zweck anzubieten.

  Nun ist es sehr wahrscheinlich, dass die Schnittart nicht ausgegeben,
  sondern später ausgewertet werden soll. In diesem Fall sind die textuellen
  Definitionen aber eher unpraktisch. Definiert man den Schlüssel hingegen als
\begin{lstcode}
  \FamilyNumericalKey{Fleischermeister}%
                     {SalatSchnitt}{Schnitt}{%
                       {Kein}{0},{Nein}{0},%
                       {Grob}{1},%
                       {Fein}{2}%
                     }
\end{lstcode}
  so kann später einfach in der Form
\begin{lstcode}
  \ifcase\Schnitt
    % ungeschnitten
  \or
    % grob geschnitten
  \else
    % fein geschnitten
  \fi
\end{lstcode}
  unterschieden werden.
\end{Example}
%
Intern wird von \Macro{FamilyNumericalKey} dann \Macro{DefineFamilyKey} mit
der Anweisung \Macro{FamilySetNumerical} verwendet. Wird an einen solchen
Schlüssel ein unbekannter Wert übergeben, so wird von
\Macro{FamilySetNumerical} Anweisung \Macro{FamilyUnknownKeyValue} mit den
Argumenten \PName{Familie}, \PName{Schlüssel} und \PName{Wert}
aufgerufen. Dies führt zu einer Fehlersignalisierung in \Macro{FamilyKeyState}
mit Hilfe des Status \Macro{FamilyKeyStateUnknownValue} und beispielsweise bei
der Verwendung als lokale Option zu einer Fehlermeldung. Ebenso wird beim
Aufruf von \Macro{FamilySetNumerical} auch der Erfolg via
\Macro{FamilyKeyStateProcessed} in \Macro{FamilyKeyState} signalisiert.%
%
\EndIndex{Cmd}{FamilySetNumerical}%
\EndIndex{Cmd}{FamilyNumericalKey}%

\begin{Declaration}
  \Macro{FamilyCounterKey}\OParameter{Mitglied}\Parameter{Familie}%
                          \Parameter{Schlüssel}\\%
  \hphantom{\XMacro{FamilyCounterKey}}%
                          \OParameter{Säumniswert}\Parameter{\LaTeX-Zähler}\\
  \Macro{FamilySetCounter}\Parameter{Familie}%
  \Parameter{Schlüssel}\Parameter{\LaTeX-Zähler}\Parameter{Wert}
\end{Declaration}
\BeginIndex{Cmd}{FamilyCounterKey}%
\BeginIndex{Cmd}{FamilySetCounter}%
Während\ChangedAt{v3.12}{\Package{scrbase}} bei \Macro{FamilyNumericalKey} ein
Makro aufgrund eines symbolischen \PName{Wert}s auf einen korrespondierenden
nummerischen Wert gesetzt wurde, gibt es natürlich auch Fälle, in denen ein
\PName{Schlüssel} direkt einen \PName{\LaTeX-Zähler} rerpäsentiert, dem
unmittelbar ein nummerischer \PName{Wert} zugewiesen werden soll. Dazu dient
die Anweisung \Macro{FamilyCounterKey}, von der intern dann
\Macro{FamilySetCounter} aufgerufen wird. Dabei finden einige grundlegende
Prüfungen des \PName{Wert}-Arguments statt um festzustellen, ob dieses
Argument für eine Zuweisung an einen Zähler in Frage kommt. Die Zuweisung
findet nur statt, wenn diese Prüfungen gelingen. Allerdings können hier nicht
alle Fehler erkannt werden, so dass eine falsche Zuweisung auch zu einer
Fehlermeldung von \TeX{} selbst führen kann. Erkannte Fehler werden hingegen
über \Macro{FamilyKeyStateUnknownValue} signalisiert.

Wurde\ChangedAt{v3.15}{\Package{scrbase}} kein Wert übergeben, so wird
stattdessen der \PName{Säumniswert} eingesetzt. Falls kein \PName{Säumniswert}
angegeben wird, kann später der \PName{Schlüssel} nur mit Wertübergabe
verwendet werden.%
\EndIndex{Cmd}{FamilySetCounter}%
\EndIndex{Cmd}{FamilyCounterKey}%

\begin{Declaration}
  \Macro{FamilyCounterMacroKey}\OParameter{Mitglied}\Parameter{Familie}%
                               \Parameter{Schlüssel}\\%
  \hphantom{\XMacro{FamilyCounterMacroKey}}%
                               \OParameter{Säumniswert}\Parameter{Makro}\\
  \Macro{FamilySetCounterMacro}\Parameter{Familie}%
  \Parameter{Schlüssel}\Parameter{Makro}\Parameter{Wert}%
\end{Declaration}
\BeginIndex{Cmd}{FamilyCounterMacroKey}%
\BeginIndex{Cmd}{FamilySetCounterMacro}%
Diese\ChangedAt{v3.12}{\Package{scrbase}} beiden Anweisungen unterscheiden
sich von den zuvor erklärten \Macro{FamilyCounterKey} und
\Macro{FamilySetCounter} nur dadurch, dass nicht ein \LaTeX-Zähler auf einen
Wert gesetzt wird, sondern ein \PName{Makro} mit diesem Wert definiert
wird.%
\EndIndex{Cmd}{FamilySetCounterMacro}%
\EndIndex{Cmd}{FamilyCounterMacroKey}%

\begin{Declaration}
  \Macro{FamilyLengthKey}\OParameter{Mitglied}\Parameter{Familie}%
                         \Parameter{Schlüssel}\\%
  \hphantom{\XMacro{FamilyLengthKey}}%
                         \OParameter{Säumniswert}\Parameter{Länge}\\
  \Macro{FamilySetLength}\Parameter{Familie}%
  \Parameter{Schlüssel}\Parameter{Länge}\Parameter{Wert}\\
  \Macro{FamilyLengthMacroKey}\OParameter{Mitglied}\Parameter{Familie}%
                              \Parameter{Schlüssel}\\%
  \hphantom{\XMacro{FamilyLengthMacroKey}}%
                              \OParameter{Säumniswert}\Parameter{Makro}\\
  \Macro{FamilySetLengthMacro}\Parameter{Familie}%
  \Parameter{Schlüssel}\Parameter{Makro}\Parameter{Wert}%
\end{Declaration}
\BeginIndex{Cmd}{FamilyLengthKey}%
\BeginIndex{Cmd}{FamilySetLength}%
\BeginIndex{Cmd}{FamilyLengthMacroKey}%
\BeginIndex{Cmd}{FamilySetLengthMacro}%
Über\ChangedAt{v3.12}{\Package{scrbase}} \Macro{FamilyLengthKey} kann ein
\PName{Schlüssel} definiert werden, der eine \PName{Länge}
repräsentiert. Dabei spielt es keine Rolle, ob eine \LaTeX-Länge, ein
\TeX-Abstand oder eine \TeX-Ausdehnung als \PName{Länge} verwendet
wird. Intern wird die \PName{Länge} über \Macro{FamilySetLength} gesetzt.
Dabei finden einige grundlegende Prüfungen des \PName{Wert}-Arguments statt um
festzustellen, ob dieses Argument für eine Zuweisung an eine \PName{Länge} in
Frage kommt. Die Zuweisung findet nur statt, wenn diese Prüfungen
gelingen. Allerdings können hier nicht alle Fehler erkannt werden, so dass
eine falsche Zuweisung auch zu einer Fehlermeldung von \TeX{} selbst führen
kann. Erkannte Fehler werden hingegen über \Macro{FamilyKeyStateUnknownValue}
signalisiert.

Wurde\ChangedAt{v3.15}{\Package{scrbase}} kein Wert übergeben, so wird
stattdessen der \PName{Säumniswert} eingesetzt. Falls kein \PName{Säumniswert}
angegeben wird, kann später der \PName{Schlüssel} nur mit Wertübergabe
verwendet werden.

Bei Verwendung der Anweisungen \Macro{FamilyLengthMacroKey} und
\Macro{FamilySetLengthMacro} findet die Speicherung des Werts nicht in einer
\Macro{Länge}, sondern in einem \Macro{Makro}
statt.%
\EndIndex{Cmd}{FamilySetLengthMacro}%
\EndIndex{Cmd}{FamilyLengthMacroKey}%
\EndIndex{Cmd}{FamilySetLength}%
\EndIndex{Cmd}{FamilyLengthKey}%

\begin{Declaration}
  \Macro{FamilyStringKey}\OParameter{Mitglied}\Parameter{Familie}%
                         \Parameter{Schlüssel}\\
  \hphantom{\XMacro{FamilyStringKey}}%
                         \OParameter{Säumniswert}\Parameter{Makro}
\end{Declaration}
\BeginIndex{Cmd}{FamilyStringKey}%
Hier wird nun\ChangedAt{v3.08}{\Package{scrbase}} ein Schlüssel definiert, der
jeden beliebigen Wert annehmen kann. Der Wert wird in dem angegebenen
\PName{Makro} gespeichert. Wird das optionale Argument für den
\PName{Säumniswert} weggelassen, so entspricht die Anweisung:
\begin{lstcode}[belowskip=\dp\strutbox plus 1pt,escapeinside=»«]
  \DefineFamilyKey[»\PName{Mitglied}«]{»\PName{Familie}«}{»\PName{Schlüssel}«}
                  {\def»\PName{Makro}«{#1}}
\end{lstcode}
Existiert
das optionale Argument für den \PName{Säumniswert} so entspricht die Anweisung:
\begin{lstcode}[belowskip=\dp\strutbox plus 1pt,escapeinside=»«]
  \DefineFamilyKey[»\PName{Mitglied}«]{»\PName{Familie}«}{»\PName{Schlüssel}«}
                  [»\PName{Säumniswert}«]
                  {\def»\PName{Makro}«{#1}\FamilyKeyStateProcessed}
\end{lstcode}

Ist
\PName{Makro} noch nicht definiert, so wird es als leeres Makro definiert.
\begin{Example}
  In der Voreinstellung sollen 250\,g Wurstsalat erzeugt werden. Die Menge
  soll jedoch einfach per Option geändert werden können. Dazu wird die zu
  erstellende Menge im Makro \Macro{Salatgewicht} gespeichert. Die Option,
  über die das Gewicht geändert werden kann, soll ebenfalls
  \PValue{Salatgewicht} heißen:
\begin{lstcode}
  \newcommand*{\Salatgewicht}{250g}
  \FamilyStringKey{Fleischermeister}%
                  {Salatgewicht}[250g]{\Salatgewicht}
\end{lstcode}
  Soll nach einer vorherigen Änderung wieder die Standardmenge hergestellt
  werden, so kann der Anwender die Option einfach ohne Gewichtsangabe
  aufrufen:
\begin{lstcode}
  \FamilyOptions{Fleischermeister}{Salatgewicht}
\end{lstcode}
  Das ist möglich, weil die Standardmenge bei der Definition auch als
  Säumniswert angegeben wurde.
\end{Example}
In diesem Fall existieren keine unbekannten Werte, da alle Werte schlicht für
eine Makrodefinition verwendet werden. Es ist jedoch zu beachten, dass in der
Wertzuweisung an den Schlüssel keine Absätze enthalten sein dürfen.
%
\EndIndex{Cmd}{FamilyStringKey}%

\begin{Declaration}
  \Macro{FamilyUnknownKeyValue}\Parameter{Familie}\Parameter{Schlüssel}%
  \Parameter{Wert}\Parameter{Werteliste}
\end{Declaration}
\BeginIndex{Cmd}{FamilyUnknownKeyValue}%
Diese Anweisung signalisiert über \Macro{FamilyKeyState} einen Fehler aufgrund
eines unbekannten oder unerlaubten Werts. Dabei wird als \PName{Werteliste}
eine durch Komma separierte Liste von erlaubten Werten der Form
\begin{flushleft}\vskip\dp\strutbox\begin{tabular}{l}
    `\PName{Wert}'\texttt{,} `\PName{Wert}' \dots
\end{tabular}\vskip\dp\strutbox\end{flushleft}
erwartet. Allerdings\ChangedAt{v3.12}{\Package{scrbase}} wird die
\PName{Werteliste} derzeit nicht ausgewertet.
\begin{Example}
  Für den Aufschnitt soll nun zusätzlich wählbar sein, ob er grob oder
  fein geschnitten werden soll. Dabei ist grob die Voreinstellung, die auch
  dann verwendet werden soll, wenn nicht angegeben wird, wie der Aufschnitt zu
  schneiden ist.
\begin{lstcode}
  \@ifundefined{if@Feinschnitt}{%
    \expandafter
    \newif\csname if@Feinschnitt\endcsname}{}%
  \@ifundefined{if@Aufschnitt}{%
    \expandafter
    \newif\csname if@Aufschnitt\endcsname}{}
  \DefineFamilyKey{Fleischermeister}%
                  {Aufschnitt}[true]{%
    \FamilySetBool{Fleischermeister}{Aufschnitt}%
                                    {@Aufschnitt}%
                                    {#1}%
    \ifx\FamilyKeyState\FamilyKeyStateProcessed
      \@Feinschnittfalse
    \else      
      \ifstr{#1}{fein}{%
        \@Aufschnitttrue
        \@Feinschnittrue
        \FamilyKeyStateProcessed
      }{}%
    \fi
  }%
\end{lstcode}
  Zunächst wird versucht, den booleschen Schalter für Aufschnitt über
  \Macro{FamilySetBool} zu setzen. Gelingt dies, wurde also
  \Macro{FamilyKeyState} zu \Macro{FamilyKeyStateProcessed} definiert, wird
  der Feinschnitt abgeschaltet. Anderenfalls wird überprüft, ob an
  Stelle eines gültigen Werts für einen booleschen Schalter %der Wert
  \PValue{fein} übergeben wurde. In diesem Fall wird sowohl der Feinschnitt,
  als auch Aufschnitt aktiviert und mit Hilfe von
  \Macro{FamilyKeyStateProcessed} der Erfolgs-Status gesetzt. Ist auch das
  nicht der Fall, bleibt der von \Macro{FamilySetBool} signalisierte
  Fehler-Zustand bestehen.

  Die bei den Tests verwendete Anweisung \Macro{ifstr}\IndexCmd{ifstr} ist auf
  \autopageref{desc:scrbase.cmd.ifstr} in \autoref{sec:scrbase.if} erklärt.
\end{Example}
%
\EndIndex{Cmd}{FamilyUnknownKeyValue}%

\begin{Declaration}
  \Macro{FamilyElseValues}
\end{Declaration}
\BeginIndex{Cmd}{FamilyElseValues}%
In\ChangedAt{v3.12}{\Package{scrbase}} früheren Versionen von
\Package{scrbase} konnte man über die Anweisung \Macro{FamilyElseValues} weitere
erlaubte Werte für die Bearbeitung durch \Macro{FamilyUnknownValue} in der Form
\begin{flushleft}\vskip\dp\strutbox\begin{tabular}{l}
    \texttt{,} `\PName{Wert}'\texttt{,} `\PName{Wert}' \dots
\end{tabular}\vskip\dp\strutbox\end{flushleft}
ablegen, die dann ebenfalls in einer Fehlermeldung mit ausgegeben wurden. Seit
Version~3.12 gibt \Macro{FamilyUnknownValue} keine Fehlermeldungen mehr
aus, sondern setzt nur noch \Macro{FamilyKeyState} entsprechend. Damit ist die
Verwendung von \Macro{FamilyElseValue} ebenfalls überholt. Ihre Verwendung
wird jedoch erkannt und führt dann zu einer Aufforderung, den Code
entsprechend anzupassen.%
\EndIndex{Cmd}{FamilyElseValues}%


\section{Verzweigungen}
\seclabel{if}

Das Paket \Package{scrbase} stellt eine ganze Reihe von
Verzweigungsanweisungen zur Verfügung. Dabei wird nicht auf die \TeX-Syntax
von Verzweigungen, wie beispielsweise
\begin{lstcode}[belowskip=\dp\strutbox]
  \iftrue
    ...
  \else
    ...
  \fi
\end{lstcode}
gebaut, sondern es wird die \LaTeX-Syntax mit Argumenten eingesetzt, wie man
sie auch von \LaTeX-Anweisungen wie \Macro{IfFileExists},
\Macro{@ifundefined}, \Macro{@ifpackageloaded} und vielen weiteren
kennt. Einige Paketautoren ziehen es allerdings vor, die \TeX-Syntax auch für
Anwender in die \LaTeX-Ebene zu bringen. Da es sich bei den Verzweigungen von
\Package{scrbase} um recht grundlegende Möglichkeiten handelt, ist die
Wahrscheinlichkeit gegeben, dass dabei gleichnamige Anwenderanweisungen
verwendet würden. Dies würde selbst bei eigentlich gleicher Semantik
zwangsläufig zu einem Problem aufgrund der unterschiedlichen Syntax
führen. Deshalb definiert \Package{scrbase} einige dieser Anweisungen zunächst
als interne Anweisungen mit dem Präfix \Macro{scr@}. Für den Anwender werden
dann gleichbedeutende Anweisungen ohne diesen Präfix bereit
gestellt. Letzteres kann jedoch mit Hilfe der Option \Option{internalonly}
(siehe \autoref{sec:scrbase.loadit},
\autopageref{desc:scrbase.option.internalonly}) verhindert werden.

Paket- und Klassenautoren sollten wie \KOMAScript{} selbst auch die internen
Namen verwenden. Zur Vollständigkeit sind aber auch die Anwenderanweisungen
angegeben.

\begin{Declaration}
  \Macro{scr@ifundefinedorrelax}%
  \Parameter{Name}\Parameter{Dann-Teil}\Parameter{Sonst-Teil}\\
  \Macro{ifundefinedorrelax}%
  \Parameter{Name}\Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{scr@ifundefinedorrelax}%
\BeginIndex{Cmd}{ifundefinedorrelax}%
Diese Anweisung funktioniert prinzipiell wie 
\Macro{@ifundefined} aus dem \LaTeX-Kern (siehe \cite{latex:source2e}). Es
wird also der \PName{Dann-Teil} ausgeführt, wenn \PName{Name} der
Name einer undefinierten Anweisung oder \Macro{\PName{Name}} derzeit
\Macro{relax} ist. Im Unterschied zu \Macro{@ifundefined} wird
allerdings \Macro{\PName{Name}} nicht als \Macro{relax} definiert,
wenn es zuvor undefiniert war. Unter Verwendung von \eTeX{} wird in diesem Fall
noch nicht einmal Hash-Speicher belegt.
%
\EndIndex{Cmd}{ifundefinedorrelax}%
\EndIndex{Cmd}{scr@ifundefinedorrelax}%

\begin{Declaration}
  \Macro{scr@ifpdftex}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}\\
  \Macro{ifpdftex}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{scr@ifpdftex}%
\BeginIndex{Cmd}{ifpdftex}%
Wird mit pdf\TeX{} gearbeitet, so wird der \PName{Dann-Teil} ausgeführt,
anderenfalls der \PName{Sonst-Teil}. Dabei ist es unerheblich, ob tatsächlich
eine PDF-Datei ausgegeben werden soll, oder nicht. Diese Unterscheidung ist
nur sehr selten wirklich von Nutzen. In der Regel sollte man eher auf die
gewünschte Anweisung testen.
%
\EndIndex{Cmd}{ifpdftex}
\EndIndex{Cmd}{scr@ifpdftex}

\begin{Declaration}
  \Macro{scr@ifVTeX}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}\\
  \Macro{ifVTeX}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{scr@ifVTeX}%
\BeginIndex{Cmd}{ifVTeX}%
Wird mit V\TeX{} gearbeitet, so wird der \PName{Dann-Teil} ausgeführt,
anderenfalls der \PName{Sonst-Teil}. Diese Unterscheidung ist nur sehr selten
wirklich von Nutzen. In der Regel sollte man eher auf die gewünschte Anweisung
testen.
%
\EndIndex{Cmd}{ifVTeX}
\EndIndex{Cmd}{scr@ifVTeX}

\begin{Declaration}
  \Macro{scr@ifpdfoutput}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}\\
  \Macro{ifpdfoutput}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{scr@ifpdfoutput}%
\BeginIndex{Cmd}{ifpdfoutput}%
Wird eine PDF-Datei erzeugt, so wird der \PName{Dann-Teil} ausgeführt,
anderenfalls der \PName{Sonst-Teil}. Dabei ist es unerheblich, ob die
PDF-Datei mit Hilfe von pdf\TeX{} oder mit Hilfe von V\TeX{} erzeugt wird.
%
\EndIndex{Cmd}{ifpdfoutput}
\EndIndex{Cmd}{scr@ifpdfoutput}

\begin{Declaration}
  \Macro{scr@ifpsoutput}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}\\
  \Macro{ifpsoutput}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{scr@ifpsoutput}%
\BeginIndex{Cmd}{ifpsoutput}%
Wird eine PostScript-Datei erzeugt, so wird der \PName{Dann-Teil} ausgeführt,
anderenfalls der \PName{Sonst-Teil}. V\TeX{} kann PostScript direkt erzeugen,
was hier auch erkannt wird. Wird hingegen kein V\TeX{} verwendet, ist aber ein
Schalter \Macro{if@dvips} definiert, so wird die Entscheidung darüber
getroffen. \KOMAScript{} stellt \Macro{if@dvips} in \Package{typearea} bereit.
%
\EndIndex{Cmd}{ifpsoutput}
\EndIndex{Cmd}{scr@ifpsoutput}

\begin{Declaration}
  \Macro{scr@ifdvioutput}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}\\
  \Macro{ifdvioutput}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{scr@ifdvioutput}%
\BeginIndex{Cmd}{ifdvioutput}%
Wird eine DVI-Datei erzeugt, so wird der \PName{Dann-Teil} ausgeführt,
anderenfalls der \PName{Sonst-Teil}. Es wird immer dann davon ausgegangen,
dass eine DVI-Datei erzeugt wird, wenn keine direkte Ausgabe einer PDF- oder
Postscript-Datei erkannt werden kann.
%
\EndIndex{Cmd}{ifdvioutput}
\EndIndex{Cmd}{scr@ifdvioutput}

\begin{Declaration}
  \Macro{ifnotundefined}\Parameter{Name}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifnotundefined}%
Unter Verwendung von \eTeX{} wird hier tatsächlich getestet, ob die Anweisung
mit dem angegebenen \PName{Name} noch undefiniert ist. Von dieser Anweisung
gibt es keine interne Variante.
%
\EndIndex{Cmd}{ifnotundefined}

\begin{Declaration}
  \Macro{ifstr}\Parameter{Zeichenfolge}\Parameter{Zeichenfolge}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifstr}%
Die beiden Argumente \PName{Zeichenfolge} werden expandiert und dann
verglichen. Sind sie dabei gleich, so wird der \PName{Dann-Teil} ausgeführt,
anderenfalls der \PName{Sonst-Teil}. Von dieser Anweisung gibt es keine
interne Variante.
%
\EndIndex{Cmd}{ifstr}

\begin{Declaration}
  \Macro{ifstrstart}\Parameter{Zeichenfolge}\Parameter{Zeichenfolge}\\
  \hphantom{\XMacro{ifstrstart}}\Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifstrstart}%
Die\ChangedAt{v3.12}{\Package{scrbase}} beiden Argumente \PName{Zeichenfolge}
werden expandiert und dann verglichen. Beginnt die erste Zeichenfolge von
Leerzeichen abgesehen mit der zweiten Zeichenfolge, so wird der
\PName{Dann-Teil} ausgeführt, anderenfalls der \PName{Sonst-Teil}. Von dieser
Anweisung gibt es keine interne Variante.%
\EndIndex{Cmd}{ifstrstart}%

\begin{Declaration}
  \Macro{ifisdimen}\Parameter{Code}\Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifisdimen}%
Wenn\ChangedAt{v3.12}{\Package{scrbase}} die Expansion von \PName{Code} in
einem \Macro{dimen}, also einem \TeX-Längenregister, resultiert, wird der
\PName{Dann-Teil} ausgeführt, anderenfalls der \PName{Sonst-Teil}. Die
Anweisung ist nicht voll expandierbar. Von dieser
Anweisung gibt es keine interne Variante.%
\EndIndex{Cmd}{ifisdimen}%

\begin{Declaration}
  \Macro{ifisdimension}\Parameter{Code}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifisdimension}%
Wenn\ChangedAt{v3.12}{\Package{scrbase}} die Expansion von \PName{Code} in
etwas resultiert, das syntaktisch dem Wert einer Länge entspricht, wird der
\PName{Dann-Teil} ausgeführt, anderenfalls der \PName{Sonst-Teil}. Es ist zu
beachten,\textnote{Achtung!} dass derzeit unbekannte Einheiten zu einer
Fehlermeldung führen. Die Anweisung ist nicht voll expandierbar. Von dieser
Anweisung gibt es keine interne Variante.%
\EndIndex{Cmd}{ifisdimension}%

\begin{Declaration}
  \Macro{ifisdimexpr}\Parameter{Code}\Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifisdimexpr}%
Wenn\ChangedAt{v3.12}{\Package{scrbase}} die Expansion von \PName{Code} in
einer \Macro{dimexpr}, also einem \TeX-Längenausdruck resultiert, wird der
\PName{Dann-Teil} ausgeführt, anderenfalls der \PName{Sonst-Teil}. Es ist zu
beachten,\textnote{Achtung!} dass fehlerhafte Ausdrücke zu Fehlermeldungen
führen! Die Anweisung ist nicht voll expandierbar. Von dieser
Anweisung gibt es keine interne Variante.%
\EndIndex{Cmd}{ifisdimexpr}%

\begin{Declaration}
  \Macro{ifisskip}\Parameter{Code}\Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifisskip}%
Wenn\ChangedAt{v3.12}{\Package{scrbase}} die Expansion von \PName{Code} in
einem \Macro{skip}, also einem \TeX-Abstand, resultiert, wird der
\PName{Dann-Teil} ausgeführt, anderenfalls der \PName{Sonst-Teil}. Die
Anweisung ist nicht voll expandierbar. Von dieser
Anweisung gibt es keine interne Variante.%
\EndIndex{Cmd}{ifisskip}%

\begin{Declaration}
  \Macro{ifisglue}\Parameter{Code}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifisglue}%
Wenn\ChangedAt{v3.12}{\Package{scrbase}} die Expansion von \PName{Code} in
etwas resultiert, das syntaktisch dem Wert eines Abstandes entspricht, wird der
\PName{Dann-Teil} ausgeführt, anderenfalls der \PName{Sonst-Teil}. Es ist zu
beachten,\textnote{Achtung!} dass derzeit unbekannte Einheiten zu einer
Fehlermeldung führen. Die Anweisung ist nicht voll expandierbar. Von dieser
Anweisung gibt es keine interne Variante.%
\EndIndex{Cmd}{ifisglue}%

\begin{Declaration}
  \Macro{ifisglueexpr}\Parameter{Code}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifisglueexpr}%
Wenn\ChangedAt{v3.12}{\Package{scrbase}} die Expansion von \PName{Code} in
einer \Macro{glueexpr}, also einem \TeX-Abstandsausdruck resultiert, wird der
\PName{Dann-Teil} ausgeführt, anderenfalls der \PName{Sonst-Teil}. Es ist zu
beachten,\textnote{Achtung!} dass fehlerhafte Ausdrücke zu Fehlermeldungen
führen! Die Anweisung ist nicht voll expandierbar. Von dieser
Anweisung gibt es keine interne Variante.%
\EndIndex{Cmd}{ifisglueexpr}%

\begin{Declaration}
  \Macro{ifiscount}\Parameter{Code}\Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifiscount}%
Wenn\ChangedAt{v3.12}{\Package{scrbase}} die Expansion von \PName{Code} in
einem \Macro{count}, also einem \TeX-Zähler, resultiert, wird der
\PName{Dann-Teil} ausgeführt, anderenfalls der \PName{Sonst-Teil}. Die
Anweisung ist nicht voll expandierbar. Für einen Test auf einen \LaTeX-Zähler
siehe \Macro{ifiscounter}. Von dieser
Anweisung gibt es keine interne Variante.%
\EndIndex{Cmd}{ifiscount}%

\begin{Declaration}
  \Macro{ifisinteger}\Parameter{Code}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifisinteger}%
Wenn\ChangedAt{v3.12}{\Package{scrbase}} die Expansion von \PName{Code} in
etwas resultiert, das syntaktisch dem Wert eines Zählers entspricht, also eine
negative oder positive ganze Zahl ist, wird der \PName{Dann-Teil} ausgeführt,
anderenfalls der \PName{Sonst-Teil}. Die Anweisung ist nicht voll
expandierbar. Von dieser Anweisung gibt es keine interne Variante.%
\EndIndex{Cmd}{ifisinteger}%

\begin{Declaration}
  \Macro{ifisnumexpr}\Parameter{Code}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifisnumexpr}%
Wenn\ChangedAt{v3.12}{\Package{scrbase}} die Expansion von \PName{Code} in
einer \Macro{numexpr}, also einem \TeX-Zahlenausdruck resultiert, wird der
\PName{Dann-Teil} ausgeführt, anderenfalls der \PName{Sonst-Teil}. Es ist zu
beachten,\textnote{Achtung!} dass fehlerhafte Ausdrücke zu Fehlermeldungen
führen! Die Anweisung ist nicht voll expandierbar. Von dieser
Anweisung gibt es keine interne Variante.%
\EndIndex{Cmd}{ifisnumexpr}%

\begin{Declaration}
  \Macro{ifiscounter}\Parameter{Zähler}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifiscounter}%
Wenn\ChangedAt{v3.12}{\Package{scrbase}} \PName{Zähler} ein definierter
\LaTeX-Zähler ist, wird der \PName{Dann-Teil} ausgeführt, anderenfalls der
\PName{Sonst-Teil}. Die Anweisung ist nicht voll expandierbar. Von dieser
Anweisung gibt es keine interne Variante.%
\EndIndex{Cmd}{ifiscounter}%

\begin{Declaration}
  \Macro{ifnumber}\Parameter{Zeichenfolge}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifnumber}%
Hier werden keine Zahlen verglichen. Der \PName{Dann-Teil} wird vielmehr
ausgeführt, wenn die einfache Expansion der \PName{Zeichenfolge} nur aus
Ziffern besteht. Anderenfalls wird der \PName{Sonst-Teil} verwendet. Von
dieser Anweisung gibt es keine interne Variante.%
\EndIndex{Cmd}{ifnumber}

\begin{Declaration}
  \Macro{ifdimen}\Parameter{Zeichenfolge}%
  \Parameter{Dann-Teil}\Parameter{Sonst-Teil}
\end{Declaration}
\BeginIndex{Cmd}{ifdimen}%
Hier werden keine Längen verglichen. Der \PName{Dann-Teil} wird vielmehr
ausgeführt, wenn die einfache Expansion der \PName{Zeichenfolge} eine gültige
Länge mit einer gültigen Längeneinheit ist. Anderenfalls wird der
\PName{Sonst-Teil} verwendet. Von dieser Anweisung gibt es keine interne
Variante.
%
\EndIndex{Cmd}{ifdimen}

\begin{Declaration}
  \Macro{if@atdocument}\ \PName{Dann-Teil} 
  \Macro{else}\ \PName{Sonst-Teil} \Macro{fi}
\end{Declaration}
\BeginIndex{Cmd}{if@atdocument}%
Diese Verzweigung existiert ganz bewusst nur als interne Anweisung. Dabei
entspricht \Macro{if@atdocument} in der Dokumentpräambel \Macro{iffalse}, nach
\Macro{begin}\PParameter{document} entspricht \Macro{if@atdocument} hingegen
\Macro{iftrue}. Klassen und Paketautoren können dieses Anweisung manchmal
sinnvoll nutzen, wenn sich Anweisungen in der Dokumentpräambel anders
verhalten sollen als innerhalb des Dokuments. Es\textnote{Achtung!} ist zu
beachten, dass es sich bei dieser Anweisung um eine Verzweigung in \TeX-Syntax
und nicht in \LaTeX-Syntax handelt!
%
\EndIndex{Cmd}{if@atdocument}


\section{Definition sprachabhängiger Bezeichner}
\seclabel{languageSupport}
\BeginIndex{}{Sprachdefinition}

Normalerweise muss man zur Definition oder zur Änderung sprachabhängiger
Begriffe Anweisungen wie \Macro{captionsngerman} so umdefinieren, dass
zusätzlich zu den bisherigen Begriffen auch die neuen oder geänderten
definiert werden. Erschwert wird dieses Vorhaben dadurch, dass beim Laden
eines Paketes wie \Package{german}\IndexPackage{german} oder
\Package{ngerman}\IndexPackage{ngerman} diese Anweisungen von den Paketen
erneut definiert werden. Bei den genannten Paketen geschieht dies leider in
einer Form, die alle zuvor gemachten Änderungen zunichte macht. Aus diesem
Grund ist es sinnvoll die Änderungen mit Hilfe von \Macro{AtBeginDocument} bis
\Macro{begin}\PParameter{document}, also bis nach dem Laden aller Pakete, zu
verzögern. Auch der Anwender muss entweder von \Macro{AtBeginDocument}
Gebrauch machen oder aber seine Änderungen nicht in die Dokumentpräambel,
sondern hinter \Macro{begin}\PParameter{document} einfügen.

Darüber hinaus kommt erschwerend hinzu, dass einige Pakete zusätzliche,
sprachabhängige Begriffe in \Macro{captions\PName{Sprache}} definieren,
während andere dafür \Macro{extras\PName{Sprache}} verwenden. So muss der
Anwender sich schon sehr genau auskennen, um die richtige Anweisung auf die
richtige Weise zu ergänzen.

Das Paket \Package{scrbase} bietet dem Anwender daher für die Definition
selbst einige zusätzliche Anweisungen, die ihn von vielen dieser Überlegungen
entlasten.

\begin{Declaration}
  \Macro{defcaptionname}%
    \Parameter{Sprachliste}\Parameter{Begriff}\Parameter{Inhalt}\\
  \Macro{providecaptionname}%
    \Parameter{Sprachliste}\Parameter{Begriff}\Parameter{Inhalt}\\
  \Macro{newcaptionname}%
    \Parameter{Sprachliste}\Parameter{Begriff}\Parameter{Inhalt}\\
  \Macro{renewcaptionname}%
    \Parameter{Sprachliste}\Parameter{Begriff}\Parameter{Inhalt}\\
  \Macro{defcaptionname*}%
    \Parameter{Sprachliste}\Parameter{Begriff}\Parameter{Inhalt}\\
  \Macro{providecaptionname*}%
    \Parameter{Sprachliste}\Parameter{Begriff}\Parameter{Inhalt}\\
  \Macro{newcaptionname*}%
    \Parameter{Sprachliste}\Parameter{Begriff}\Parameter{Inhalt}\\
  \Macro{renewcaptionname*}%
    \Parameter{Sprachliste}\Parameter{Begriff}\Parameter{Inhalt}
\end{Declaration}
\BeginIndex{Cmd}{defcaptionname}%
\BeginIndex{Cmd}{providecaptionname}%
\BeginIndex{Cmd}{newcaptionname}%
\BeginIndex{Cmd}{renewcaptionname}%
Mit Hilfe dieser vier Anweisungen und ihrer Sternvarianten ist es möglich,
einem \PName{Begriff} in Abhängigkeit der Sprache einen \PName{Inhalt}
zuzuweisen. Mehrere Sprachen können durch Komma voneinander getrennt als
\PName{Sprachliste}\ChangedAt{v3.12}{\Package{scrbase}} angegeben werden.

Der \PName{Begriff} ist immer ein Makro. Die Arbeitsweise der Anweisungen
unterscheidet sich je nachdem, ob eine Sprache und ein \PName{Begriff}
innerhalb dieser Sprache zum Zeitpunkt des Aufrufs bereits definiert ist.

Ist eine Sprache nicht definiert, so tut \Macro{providecaptionname}
nichts weiter, als dies in der \File{log}-Datei zu vermerken. Dabei wird für
jede Sprache nur einmal eine entsprechende Information in die \File{log}-Datei
geschrieben. Ist die Sprache definiert, enthält aber bisher keinen
entsprechenden \PName{Begriff}, so wird er mit dem angegebenen \PName{Inhalt}
definiert. Ist der \PName{Begriff} hingegen in der Sprache bereits
definiert, so wird er nicht umdefiniert, sondern ein entsprechender Hinweis in
die \File{log}-Datei geschrieben.

Die Anweisung \Macro{newcaptionname} verhält sich etwas anders. Ist bei ihr
eine Sprache nicht definiert, dann wird diese neu definiert, indem eine
entsprechende Anweisung definiert wird. Für die Sprache
\PValue{ngerman} wäre das beispielsweise \Macro{captionsngerman}. Außerdem
wird darüber auch in der \File{log}-Datei informiert. Ist die Sprache
definiert, der \PName{Begriff} in dieser Sprache aber noch nicht
vorhanden, so wird er mit dem gewünschten \PName{Inhalt} definiert. Ist der
\PName{Begriff} in der Sprache bereits vorhanden, so wird eine
Fehlermeldung ausgegeben.

Die Anweisung \Macro{renewcaptionname} verhält sich noch einmal anders. Ist
eine Sprache nicht definiert, so wird eine Fehlermeldung
ausgegeben. Ist die Sprache definiert, der \PName{Begriff} in dieser
Sprache jedoch nicht, so wird ebenfalls eine Fehlermeldung
ausgegeben. Ist der \PName{Begriff} in der Sprache definiert, so wird
er auf den gewünschten \PName{Inhalt} umdefiniert.

Die\ChangedAt{v3.12}{\Package{scrbase}} Anweisung \Macro{defcaptionname}
definiert einen \PName{Begriff} immer, überschreibt also eventuell vorhandene
Definitionen. Wie bei \Macro{providecaptionname} braucht eine angegebene
Sprache nicht definiert zu sein.

\KOMAScript{} selbst verwendet \Macro{providecaptionname} um die Begriffe aus
\autoref{sec:scrlttr2-experts.languages},
\autopageref{desc:scrlttr2-experts.cmd.yourrefname} zu definieren.

\begin{Example}
  Möchten Sie »Abb.« statt »Abbildung« in den Abbildungsunterschriften, so
  erreichen Sie dies mit:
\begin{lstcode}
  \renewcaptionname{ngerman}{\figurename}{Abb.}
\end{lstcode}

  Soll dieselbe Änderung nicht nur für \PValue{ngerman}, sondern
  auch für die Sprachen \PValue{naustrian} und \PValue{nswissgerman}, also für
  Österreichisch und Schweizer Deutsch gelten, so ist
  es nicht notwendig zwei weitere Anweisungen:
\begin{lstcode}
  \renewcaptionname{naustrian}{\figurename}{Abb.}
  \renewcaptionname{nswissgerman}{\figurename}{Abb.}
\end{lstcode}
  hinzuzufügen. Stattdessen kann einfach, die \PName{Sprachliste} erweitert
  werden:
\begin{lstcode}
  \renewcaptionname{ngerman,naustrian,nswissgerman}%
                   {\figurename}{Abb.}
\end{lstcode}
  In gleicher Weise können auch \PValue{german}, \PValue{austrian} und
  \PValue{swissgerman}, also Deutsch, Österreichisch und Schweizer Deutsch
  nach der veralteten Rechtschreibung, hinzugefügt werden.
\end{Example}
\begin{Explain}
  Die Sprachen \PValue{swissgerman} und \PValue{nswissgerman} werden übrigens
  von älteren Versionen von \Package{babel} noch nicht unterstützt. Sie sind
  erst seit Dezember~2013 Bestandteil des deutschen Sprachpakets für
  \Package{babel}. Für die Anweisungen \Macro{defcaptionname},
  \Macro{newcaptionname} und \Macro{providecaptionname} spielt dies kaum eine
  Rolle, da diese auch Begriffe für nicht existierende Sprachen definieren
  können. Da mit \Macro{renewcaptionname} jedoch nur existierende Begriffe von
  existierenden Sprachen umdefiniert werden können, resultiert die
  Umdefinierung für \Option{nswissgerman} und \Option{swissgerman} bei
  Verwendung einer älteren Version von \Package{babel} in einer entsprechenden
  Fehlermeldung.
\end{Explain}

Seit \KOMAScript~3.12\ChangedAt{v3.12}{\Package{scrbase}} ist es auch nicht
mehr erforderlich, die Definierung oder Umdefinierung mit Hilfe von
\Macro{AtBeginDocument} bis \Macro{begin}\PParameter{document} zu
verzögern. Stattdessen erledigt \Package{scrbase} dies selbst, falls die
Anweisungen in der Dokumentpräambel aufgerufen werden. Außerdem prüft
\Package{scrbase} nun auch, ob ein umzudefinierender Begriff statt in
\Macro{captions\PName{Sprache}} in \Macro{extras\PName{Sprache}} zu definieren
ist. Die neuen Sternvarianten der Befehle verwenden grundsätzlich
\Macro{extras\PName{Sprache}}, da dessen Definitionen in der Regel nach
\Macro{captions\PName{Sprache}} Anwendung finden. Damit funktioniert nun in
der Regel auch das Umdefinieren von sprachabhängigen Bezeichnern von Paketen
wie \Package{hyperref}, die dafür \Macro{extras\PName{Sprache}} verwenden.

In \autoref{tab:scrbase.commonNames} ist ein Überblick über die üblicherweise
von Klassen und Sprachpaketen definierten Begriffe und deren Verwendung zu
finden.

\begin{desclist}
  \renewcommand*{\abovecaptionskipcorrection}{-\normalbaselineskip}%
  \desccaption[{%
    Überblick über übliche sprachabhängige Begriffe%
  }]{%
    Überblick über sprachabhängige Begriffe in den üblichen
    Sprachpaketen\label{tab:scrbase.commonNames}%
  }{%
    Überblick über übliche sprachabhängige Begriffe
    (\emph{Fortsetzung})%
  }%
  \entry{\Macro{abstractname}}{%
    Überschrift für die Zusammenfassung%
    \IndexCmd{abstractname}%
  }%
  \entry{\Macro{alsoname}}{%
    »Siehe auch« bei ergänzenden Verweisen im Stichwortverzeichnis%
    \IndexCmd{alsoname}%
  }%
  \entry{\Macro{appendixname}}{%
    »Anhang« in der Kapitelüberschrift eines Anhangs%
    \IndexCmd{appendixname}%
  }%
  \entry{\Macro{bibname}}{%
    Überschrift für das Literaturverzeichnis%
    \IndexCmd{bibname}%
  }%
  \entry{\Macro{ccname}}{%
    Spitzmarke für den Verteiler in Briefen%
    \IndexCmd{ccname}%
  }%
  \entry{\Macro{chaptername}}{%
    »Kapitel« in der Kapitelüberschrift%
    \IndexCmd{chaptername}%
  }%
  \entry{\Macro{contentsname}}{%
    Überschrift für das Inhaltsverzeichnis%
    \IndexCmd{contentsname}%
  }%
  \entry{\Macro{enclname}}{%
    Spitzmarke für die Anlagen bei Briefen%
    \IndexCmd{enclname}%
  }%
  \entry{\Macro{figurename}}{%
    Spitzmarke in der Abbildungsunterschrift%
    \IndexCmd{figurename}%
  }%
  \entry{\Macro{glossaryname}}{%
    Überschrift für das Glossar%
    \IndexCmd{glossaryname}%
  }%
  \entry{\Macro{headtoname}}{%
    »An« im Briefkopf%
    \IndexCmd{headtoname}%
  }%
  \entry{\Macro{indexname}}{%
    Überschrift für das Stichwortverzeichnis%
    \IndexCmd{indexname}%
  }%
  \entry{\Macro{listfigurename}}{%
    Überschrift für das Abbildungsverzeichnis%
    \IndexCmd{listfigurename}%
  }%
  \entry{\Macro{listtablename}}{%
    Überschrift für das Tabellenverzeichnis%
    \IndexCmd{listtablename}%
  }%
  \entry{\Macro{pagename}}{%
    »Seite« in der Seitennummer von Briefen%
    \IndexCmd{pagename}%
  }%
  \entry{\Macro{partname}}{%
    »Teil« in der Teileüberschrift%
    \IndexCmd{partname}%
  }%
  \entry{\Macro{prefacename}}{%
    Überschrift für das Vorwort%
    \IndexCmd{prefacename}%
  }%
  \entry{\Macro{proofname}}{%
    Spitzmarke bei Beweisen%
    \IndexCmd{proofname}%
  }%
  \entry{\Macro{refname}}{%
    Überschrift für das Quellenverzeichnis%
    \IndexCmd{refname}%
  }%
  \entry{\Macro{seename}}{%
    »Siehe« bei Verweisen im Stichwortverzeichnis%
    \IndexCmd{seename}%
  }%
  \entry{\Macro{tablename}}{%
    Spitzmarke in der Tabellenunter- bzw. "~überschrift%
    \IndexCmd{tablename}%
  }%
\end{desclist}
%
\EndIndex{Cmd}{renewcaptionname}%
\EndIndex{Cmd}{newcaptionname}%
\EndIndex{Cmd}{providecaptionname}%
\EndIndex{Cmd}{defcaptionname}%
%
\EndIndex{}{Sprachdefinition}%


\section{Identifikation von \KOMAScript}
\seclabel{identify}

Obwohl \Package{scrbase} unabhängig von \KOMAScript{} auch für andere
Pakete und Klassen verwendet werden kann, so ist es dennoch ein
\KOMAScript-Paket. Als solches enthält es auch Anweisungen, die es als
\KOMAScript-Paket identifizieren.


\begin{Declaration}
  \Macro{KOMAScript}
\end{Declaration}
\BeginIndex{Cmd}{KOMAScript}%
Diese Anweisung setzt schlicht die Wortmarke »\KOMAScript« in serifenloser
Schrift und mit leichter Sperrung des in Versalien gesetzten
Teils. \Macro{KOMAScript} wird übrigens bei Bedarf von allen
\KOMAScript-Klassen und "~Paketen definiert. Die Definition erfolgt mit
\Macro{DeclareRobustCommand}.
%
\EndIndex{Cmd}{KOMAScript}


\begin{Declaration}
  \Macro{KOMAScriptVersion}
\end{Declaration}
\BeginIndex{Cmd}{KOMAScriptVersion}%
Bei \KOMAScript{} ist in dieser Anweisung die Hauptversion von \KOMAScript{}
in der Form »\PName{Datum} \PName{Version} \texttt{KOMA-Script}«
abgelegt. Diese Hauptversion ist für alle \KOMAScript-Klassen und alle
\KOMAScript-Pakete, die von den Klassen verwendet werden, gleich. Daher kann
sie auch nach dem Laden von \Package{scrbase} abgefragt werden. Diese
Anleitung wurde beispielsweise mit der \KOMAScript-Version
»\KOMAScriptVersion« erstellt.
%
\EndIndex{Cmd}{KOMAScriptVersion}%


\section{Erweiterungen des \LaTeX-Kerns}
\seclabel{latexkernel}

In einigen Fällen stellt der \LaTeX-Kern selbst Anweisungen zur Verfügung,
lässt aber ganz ähnliche Anweisungen, die ebenfalls häufiger benötigt werden
oder eigentlich nahe liegen, vermissen. Einige wenige solcher Anweisungen
für Klassen- und Paketautoren stellt \Package{scrbase} zur Verfügung.

\begin{Declaration}
  \Macro{ClassInfoNoLine}\Parameter{Klassenname}\Parameter{Information}\\
  \Macro{PackageInfoNoLine}\Parameter{Paketname}\Parameter{Information}%
\end{Declaration}%
\BeginIndex{Cmd}{PackageInfoNoLine}%
\BeginIndex{Cmd}{ClassInfoNoLine}%
Der \LaTeX-Kern bietet dem Klassen- und Paketautor zwar Anweisungen wie
\Macro{PackageInfo} und \Macro{ClassInfo}, um Informationen mit aktueller
Zeilennummer in die Log-Datei zu schreiben. Er bietet neben
\Macro{PackageWarning} und \Macro{ClassWarning}, die Warnungen mit aktueller
Zeilennummer ausgeben, auch die beiden Anweisungen
\Macro{PackageWarningNoLine} und \Macro{ClassWarningNoLine}, um Warnungen ohne
Zeilennummer auszugeben. Die nahe liegenden Anweisungen
\Macro{ClassInfoNoLine} und \Macro{PackageInfoNoLine}, um auch Informationen
ohne Zeilennummer in die Log-Datei zu schreiben, fehlen jedoch. Diese werden
von \Package{scrbase} bereit gestellt.
%
\EndIndex{Cmd}{ClassInfoNoLine}%
\EndIndex{Cmd}{PackageInfoNoLine}

\begin{Declaration}
  \Macro{l@addto@macro}\Parameter{Anweisung}\Parameter{Erweiterung}%
\end{Declaration}%
\BeginIndex{Cmd}{l@addto@macro}%
Der \LaTeX-Kern bietet mit \Macro{g@addto@macro} eine interne Anweisung, um
die Definition eines Makro \PName{Anweisung} global um den Code
\PName{Erweiterung} zu erweitern. Das funktioniert in dieser Form nur für
Makros ohne Argumente. Dennoch könnte man diese Anweisung in einigen Fällen
auch in einer Form benötigen, die lokal zur aktuellen Gruppe arbeitet. Diese
wird mit \Macro{l@addto@macro} von \Package{scrbase} bereit gestellt. Eine
Alternative stellt hier die Verwendung des Pakets
\Package{etoolbox}\IndexPackage{etoolbox} dar, das eine ganze Reihe solcher
Anweisungen für unterschiedliche Zwecke bietet (siehe
\cite{package:etoolbox}).
%
\EndIndex{Cmd}{l@addto@macro}


\section{Erweiterungen der mathematischen Fähigkeiten von \eTeX}
\seclabel{etex}

Das für \LaTeX{} inzwischen verwendete und von \KOMAScript{} vorausgesetzte
\eTeX{} besitzt mit \Macro{numexpr}\IndexCmd{numexpr} erweiterte Möglichkeiten
zur Berechnung einfacher Ausdrücke mit \TeX-Zählern und ganzen Zahlen. Als
Operationen werden dabei die vier Grundrechenarten und Klammern
unterstützt. Bei der Division wird korrekt gerundet. Manchmal sind weitere
Operationen nützlich.

\begin{Declaration}
  \Macro{XdivY}\Parameter{Dividend}\Parameter{Divisor}\\
  \Macro{XmodY}\Parameter{Dividend}\Parameter{Divisor}%
\end{Declaration}%
\BeginIndex{Cmd}{XdivY}%
\BeginIndex{Cmd}{XmodY}%
Die\ChangedAt{v3.05a}{\Package{scrbase}} Anweisung \Macro{XdivY} liefert den
Wert des ganzzahligen Quotienten, die Anweisung \Macro{XmodY} den Wert des
Rests der Division mit Rest. Diese Art der Division ist nach der Gleichung
\[
\textit{Dividend} = \textit{Divisor} \cdot
\textit{Quotient} + \textit{Rest}
\]
%
definiert, wobei \textit{Dividend}, \textit{Divisor} und \textit{Rest} ganze
Zahlen und \textit{Rest} außerdem größer oder gleich 0 und kleiner als
\textit{Divisor} ist. Der \textit{Divisor} ist eine natürliche Zahl (ohne die
0).

Der Wert kann jeweils zur Zuweisung an einen Zähler oder direkt innerhalb
eines Ausdrucks mit \Macro{numexpr} verwendet werden. Zur Ausgabe als
arabische Zahl ist \Macro{the} voran zu stellen.%
%
\EndIndex{Cmd}{XmodY}%
\EndIndex{Cmd}{XdivY}%
%
\EndIndex{Package}{scrbase}%

\endinput

%%% Local Variables:
%%% mode: latex
%%% mode: flyspell
%%% coding: iso-latin-1
%%% ispell-local-dictionary: "de_DE"
%%% TeX-master: "../guide.tex"
%%% End:

% LocalWords:  Paketoptionen Familienmitglieder Familienmitglieds Säumniswert
% LocalWords:  Fleischermeister FamilyProcessOptions ProcessOption keyval Cmd
% LocalWords:  documentclass ProcessOptions FamilyExecuteOptions currname
% LocalWords:  Optionenliste ExecuteOptions DeclareOption currext Wurstsalat
% LocalWords:  FamilyOptions FamilyKeyState Wurstpakete nonsense package true
% LocalWords:  Wurstpaket FamilyOption salatmit SalatZusatz scrbase false
% LocalWords:  AtEndOfFamilyOptions FamilyBoolKey FamilySetBool Schaltername
% LocalWords:  FamilyLengthKey FamilySetLength FamilyLengthMacroKey
% LocalWords:  FamilySetLengthMacro Wertübergabe Gliederungsbefehlen
