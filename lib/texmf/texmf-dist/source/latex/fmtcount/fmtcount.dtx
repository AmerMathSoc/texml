%\iffalse
% fmtcount.dtx generated using makedtx version 0.94b (c) Nicola Talbot
% Command line args:
%   -src "(.+)\.(sty|def)$=>\1.\2"
%   -doc "fmtcount-manual.tex"
%   -author "Nicola Talbot and Vincent Belaïche"
%   fmtcount
% Created on 2015/5/8 16:50
%\fi
%\iffalse
%<*package>
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
%</package>
%\fi
% \iffalse
% Doc-Source file to use with LaTeX2e
% Copyright (C) 2015 Nicola Talbot and Vincent Belaïche, all rights reserved.
% \fi
% \iffalse
%<*driver>
\documentclass{nlctdoc}

\usepackage{color}
\usepackage[utf8]{inputenc}
\usepackage[french,english]{babel}
\usepackage{amsmath,amssymb}
\usepackage{tabularx,supertabular,multirow}
\usepackage[T1]{fontenc}
\usepackage{cmap}
\usepackage{fmtcount}% needed for \fc@iterate@on@languages
\newcommand*\uref[1]{\href{#1}{#1}}
\DeclareMathOperator{\intv}{..}
\newcommand*\interface{}
\makeatletter
\newcommand*{\LanguagePackageOptionList}{{%
 \def\@tempf##1{\texttt{##1}}% how to format each option
 % we don't use \cs{newtoks} because anyway this is within a group
 \toks0{}%
 \def\@tempd{\toks0}% token in which we accumulate result
 \def\@tempc{\toks1}% token in which we place next dialect
 \count0 0 % to distinguish first and second iteration, we need to do tricks because we want to insert `and'
           % before the last item in the list.
 \def\@tempb##1{%
   \ifnum\count0=0 %
   \else\ifnum\count0=1 %
     \expandafter\@tempd\expandafter{\the\toks1}%
   \else
     \edef\@tempa{\the\toks0, \the\toks1}%
     \expandafter\@tempd\expandafter{\@tempa}%
   \fi\fi
   \expandafter\@tempc\expandafter{\@tempf{##1}}%
   \advance\count0 by 1 %
 }%
 \fc@iterate@on@languages\@tempb
 \edef\@tempa{\the\toks0, and \the\toks1}%
 \expandafter
}\@tempa}
\makeatother

\usepackage[colorlinks,
            bookmarks,
            bookmarksopen,
            pdfauthor={Nicola L.C. Talbot},
            pdftitle={fmtcount.sty: Displaying the Values of LaTeX Counters},
            pdfkeywords={LaTeX,counter}]{hyperref}

\CheckSum{9930}

\doxitem{Option}{option}{options}

\newlength{\tabcolwidth}

\begin{document}
\DocInput{fmtcount.dtx}
\end{document}
%</driver>
%\fi
%\RecordChanges
%
% \title{fmtcount.sty: Displaying the Values of 
%\LaTeX\ Counters}
% \author{Nicola L.C. Talbot\\
% \url{www.dickimaw-books.com}
% \and
% Vincent Bela\"iche}
% \date{2015-05-05 (version 3.01)\relax
%}
% \maketitle
% \tableofcontents
% \section{Introduction}
%
%The \styfmt{fmtcount} package provides commands to display
%the values of \LaTeX\ counters in a variety of formats. It also
%provides equivalent commands for actual numbers rather than 
%counter names. Limited multilingual support is available. 
%Currently, there is only support for English, French (including
%Belgian and Swiss variations), Spanish, Portuguese, German and 
%Italian.
%
%\section{Available Commands}
%
%The commands can be divided into two categories: those that
%take the name of a counter as the argument, and those
%that take a number as the argument.
%
%\begin{definition}[\DescribeMacro{\ordinal}]
%\cs{ordinal}\marg{counter}\oarg{gender}
%\end{definition}
%This will print the value of a \LaTeX\ counter \meta{counter} as an 
%ordinal, where the macro
%\begin{definition}[\DescribeMacro{\fmtord}]
%\cs{fmtord}\marg{text}
%\end{definition}
%is used to format the st, nd, rd, th bit.  By default the ordinal is
%formatted as a superscript, if the package option \pkgopt{level} is
%used, it is level with the text.  For example, if the current section
%is 3, then \verb"\ordinal{section}" will produce the output:
%3\textsuperscript{rd}. Note that the optional argument \meta{gender} 
%occurs \emph{at the end}. This argument may only take one of
%the following values: \texttt{m} (masculine), \texttt{f}
%(feminine) or \texttt{n} (neuter.) If \meta{gender} is omitted, 
%or if the given gender has no meaning in the current language, 
%\texttt{m} is assumed.
%
%\textbf{Notes:} 
%\begin{enumerate}
%\item the \cls{memoir} class also defines a command called
%\cs{ordinal} which takes a number as an argument instead of a
%counter. In order to overcome this incompatiblity, if you want
%to use the \styfmt{fmtcount} package with the \cls{memoir} class 
%you should use
%\begin{definition}[\DescribeMacro{\FCordinal}]
%\cs{FCordinal}
%\end{definition}
%to access \styfmt{fmtcount}'s version of \cs{ordinal}, and use
%\cs{ordinal} to use \cls{memoir}'s version of that command.
%
%\item As with all commands which have an optional argument as the
%last argument, if the optional argument is omitted, any spaces
%following the final argument will be ignored. Whereas, if the
%optional argument is present, any spaces following the optional
%argument won't be ignored. so \verb"\ordinal{section} !"
%will produce: 3\textsuperscript{rd}! whereas
% \verb"\ordinal{section}[m] !" will produce:
%3\textsuperscript{rd} !
%\end{enumerate}
%
%The commands below only work for numbers in the range 0~to~99999.
%\begin{definition}[\DescribeMacro{\ordinalnum}]
%\cs{ordinalnum}\marg{n}\oarg{gender}
%\end{definition}
%This is like \cs{ordinal} but takes an actual number rather than a 
%counter as the argument. For example: \verb"\ordinalnum{3}" will
%produce: 3\textsuperscript{rd}.
%
%\begin{definition}[\DescribeMacro{\numberstring}]
%\cs{numberstring}\marg{counter}\oarg{gender}
%\end{definition}
%This will print the value of \meta{counter} as text.  E.g.\
%\verb"\numberstring{section}" will produce: three. The optional
%argument is the same as that for \cs{ordinal}.
%
%\begin{definition}[\DescribeMacro{\Numberstring}]
%\cs{Numberstring}\marg{counter}\oarg{gender}
%\end{definition}
%This does the same as \cs{numberstring}, but with initial letters in
%uppercase.  For example, \verb"\Numberstring{section}" will produce:
%Three.
%
%\begin{definition}[\DescribeMacro{\NUMBERstring}]
%\cs{NUMBERstring}\marg{counter}\oarg{gender}
%\end{definition}
%This does the same as \cs{numberstring}, but converts the string to
%upper case. Note that
%\verb"\MakeUppercase{\NUMBERstring{"\meta{counter}\verb'}}' doesn't
%work, due to the way that \cs{MakeUppercase} expands its
%argument\footnote{See all the various postings to
%\texttt{comp.text.tex} about \cs{MakeUppercase}}.
%
%\begin{definition}[\DescribeMacro{\numberstringnum}]
%\cs{numberstringnum}\marg{n}\oarg{gender}
%\end{definition}
%\begin{definition}[\DescribeMacro{\Numberstringnum}]
%\cs{Numberstringnum}\marg{n}\oarg{gender}
%\end{definition}
%\begin{definition}[\DescribeMacro{\NUMBERstringnum}]
%\cs{NUMBERstringnum}\marg{n}\oarg{gender}
%\end{definition}
%Theses macros  work like 
%\cs{numberstring}, \cs{Numberstring} and \cs{NUMBERstring}, 
%respectively, but take an actual number
%rather than a counter as the argument. For example:
%\verb'\Numberstringnum{105}' will produce: One Hundred and Five.
%
%\begin{definition}[\DescribeMacro{\ordinalstring}]
%\cs{ordinalstring}\marg{counter}\oarg{gender}
%\end{definition}
%This will print the value of \meta{counter} as a textual ordinal.
%E.g.\ \verb"\ordinalstring{section}" will produce: third. The
%optional argument is the same as that for \cs{ordinal}.
%
%\begin{definition}[\DescribeMacro{\Ordinalstring}]
%\cs{Ordinalstring}\marg{counter}\oarg{gender}
%\end{definition}
%This does the same as \cs{ordinalstring}, but with initial letters in
%uppercase.  For example, \verb"\Ordinalstring{section}" will produce:
%Third.
%
%\begin{definition}[\DescribeMacro{\ORDINALstring}]
%\cs{ORDINALstring}\marg{counter}\oarg{gender}
%\end{definition}
%This does the same as \cs{ordinalstring}, but with all words in upper
%case (see previous note about \cs{MakeUppercase}).
%
%\begin{definition}[\DescribeMacro{\ordinalstringnum}]
%\cs{ordinalstringnum}\marg{n}\oarg{gender}
%\end{definition}
%\begin{definition}[\DescribeMacro{\Ordinalstringnum}]
%\cs{Ordinalstringnum}\marg{n}\oarg{gender}
%\end{definition}
%\begin{definition}[\DescribeMacro{\ORDINALstringnum}]
%\cs{ORDINALstringnum}\marg{n}\oarg{gender}
%\end{definition}
%These macros work like \cs{ordinalstring}, \cs{Ordinalstring} and
%\cs{ORDINALstring}, respectively, but take an actual number rather
%than a counter as the argument. For example,
%\verb"\ordinalstringnum{3}" will produce: third.
%
%\changes{v.1.09}{21 Apr 2007}{store facility added}
%As from version 1.09, textual representations can be stored for
%later use. This overcomes the problems encountered when you
%attempt to use one of the above commands in \cs{edef}.
%
%Each of the following commands takes a label as the first argument,
%the other arguments are as the analogous commands above. These
%commands do not display anything, but store the textual 
%representation. This can later be retrieved using
%
%\begin{definition}[\DescribeMacro{\FMCuse}]
%\cs{FMCuse}\marg{label}
%\end{definition}
%
%\begin{important}
%Note: with \cs{storeordinal} and \cs{storeordinalnum}, the 
%only bit that doesn't get expanded is \cs{fmtord}. So, for 
%example, \verb"\storeordinalnum{mylabel}{3}" will be stored as
%\verb"3\relax \fmtord{rd}".
%\end{important}
%
%\begin{definition}[\DescribeMacro{\storeordinal}]
%\cs{storeordinal}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeordinalstring}]
%\cs{storeordinalstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeOrdinalstring}]
%\cs{storeOrdinalstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%
%\begin{definition}[\DescribeMacro{\storeORDINALstring}]
%\cs{storeORDINALstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storenumberstring}]
%\cs{storenumberstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeNumberstring}]
%\cs{storeNumberstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeNUMBERstring}]
%\cs{storeNUMBERstring}\marg{label}\marg{counter}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeordinalnum}]
%\cs{storeordinalnum}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeordinalstringnum}]
%\cs{storeordinalstring}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeOrdinalstringnum}]
%\cs{storeOrdinalstringnum}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeORDINALstringnum}]
%\cs{storeORDINALstringnum}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storenumberstringnum}]
%\cs{storenumberstring}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeNumberstringnum}]
%\cs{storeNumberstring}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\storeNUMBERstringnum}]
%\cs{storeNUMBERstring}\marg{label}\marg{number}\oarg{gender}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\binary}]
%\cs{binary}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as a binary number.
%E.g.\ \verb"\binary{section}" will produce: 11. The declaration
%\begin{definition}[\DescribeMacro{\padzeroes}]
%\cs{padzeroes}\oarg{n}
%\end{definition}
%will ensure numbers are written to \meta{n} digits, padding with
%zeroes if necessary. E.g.\ \verb"\padzeroes[8]\binary{section}" will
%produce: 00000011. The default value for \meta{n} is 17.
%
%\begin{definition}[\DescribeMacro{\binarynum}]
%\cs{binary}\marg{n}
%\end{definition}
%This is like \cs{binary} but takes an actual number rather than a
%counter as the argument. For example: \verb"\binarynum{5}" will
%produce: 101.
%
%The octal commands only work for values in the range 0~to~32768.
%\begin{definition}[\DescribeMacro{\octal}]
%\cs{octal}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as an octal number.  For
%example, if you have a counter called, say \texttt{mycounter}, and
%you set the value to 125, then \verb"\octal{mycounter}" will produce:
%177.  Again, the number will be padded with zeroes if necessary,
%depending on whether \cs{padzeroes} has been used.
%
%\begin{definition}[\DescribeMacro{\octalnum}]
%\cs{octalnum}\marg{n}
%\end{definition}
%This is like \cs{octal} but takes an actual number rather than a
%counter as the argument. For example: \verb"\octalnum{125}" will
%produce: 177.
%
%\begin{definition}[\DescribeMacro{\hexadecimal}]
%\cs{hexadecimal}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as a hexadecimal number.
%Going back to the counter used in the previous example,
%\verb"\hexadecimal{mycounter}" will produce: 7d. Again, the number
%will be padded with zeroes if necessary, depending on whether
%\cs{padzeroes} has been used.
%
%\begin{definition}[\DescribeMacro{\Hexadecimal}]
%\cs{Hexadecimal}\marg{counter}
%\end{definition}
%This does the same thing, but uses uppercase characters, e.g.\
%\verb"\Hexadecimal{mycounter}" will produce: 7D.
%
%\begin{definition}[\DescribeMacro{\hexadecimalnum}]
%\cs{hexadecimalnum}\marg{n}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\Hexadecimalnum}]
%\cs{Hexadecimalnum}\marg{n}
%\end{definition}
%These are like \cs{hexadecimal} and \cs{Hexadecimal}
%but take an actual number rather than a counter as the
%argument. For example: \verb"\hexadecimalnum{125}" will
%produce: 7d, and \verb"\Hexadecimalnum{125}" will 
%produce: 7D.
%
%\begin{definition}[\DescribeMacro{\decimal}]
%\cs{decimal}\marg{counter}
%\end{definition}
%This is similar to \cs{arabic} but the number can be padded with
%zeroes depending on whether \cs{padzeroes} has been used.  For
%example: \verb"\padzeroes[8]\decimal{section}" will produce:
%00000005.
%
%\begin{definition}[\DescribeMacro{\decimalnum}]
%\cs{decimalnum}\marg{n}
%\end{definition}
%This is like \cs{decimal} but takes an actual number rather than a
%counter as the argument. For example:
%\verb"\padzeroes[8]\decimalnum{5}" will produce: 00000005.
%
%\begin{definition}[\DescribeMacro{\aaalph}]
%\cs{aaalph}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as: a b \ldots\ z aa bb
%\ldots\ zz etc.  For example, \verb"\aaalpha{mycounter}" will
%produce: uuuuu if \texttt{mycounter} is set to 125.
%
%\begin{definition}[\DescribeMacro{\AAAlph}]
%\cs{AAAlph}\marg{counter}
%\end{definition}
%This does the same thing, but uses uppercase characters, e.g.\
%\verb"\AAAlph{mycounter}" will produce: UUUUU.
%
%\begin{definition}[\DescribeMacro{\aaalphnum}]
%\cs{aaalphnum}\marg{n}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\AAAlphnum}]
%\cs{AAAlphnum}\marg{n}
%\end{definition}
%These macros are like \cs{aaalph} and \cs{AAAlph}
%but take an actual number rather than a counter as the
%argument. For example: \verb"\aaalphnum{125}" will
%produce: uuuuu, and \verb"\AAAlphnum{125}" will 
%produce: UUUUU.
%
%The abalph commands described below only work for values in the
%range 0~to~17576.
%\begin{definition}[\DescribeMacro{\abalph}]
%\cs{abalph}\marg{counter}
%\end{definition}
%This will print the value of \meta{counter} as: a b \ldots\ z aa ab
%\ldots\ az etc.  For example, \verb"\abalpha{mycounter}" will
%produce: du if \texttt{mycounter} is set to 125.
%
%\begin{definition}[\DescribeMacro{\ABAlph}]
%\cs{ABAlph}\marg{counter}
%\end{definition}
%This does the same thing, but uses uppercase characters, e.g.\
%\verb"\ABAlph{mycounter}" will produce: DU.
%
%\begin{definition}[\DescribeMacro{\abalphnum}]
%\cs{abalphnum}\marg{n}
%\end{definition}
%
%\begin{definition}[\DescribeMacro{\ABAlphnum}]
%\cs{ABAlphnum}\marg{n}
%\end{definition}
%These macros are like \cs{abalph} and \cs{ABAlph}
%but take an actual number rather than a counter as the
%argument. For example: \verb"\abalphnum{125}" will
%produce: du, and \verb"\ABAlphnum{125}" will 
%produce: DU.
%
%\section{Package Options}
%\label{sec:package-options}
%
%The following options can be passed to this package:
%
%\begin{description}
%\item[\meta{dialect}] load language \meta{dialect}, supported \meta{dialect} are the same as passed to
%  \cs{FCloadlang}, see~\ref{sec:multilingual-support}
%\item[\pkgopt{raise}] make ordinal st,nd,rd,th appear as superscript
%\item[\pkgopt{level}] make ordinal st,nd,rd,th appear level with rest of text
%\end{description}
%
%
%\noindent Options \pkgopt{raise} and \pkgopt{level} can also be set using the command:
%
%\begin{definition}[\DescribeMacro{\fmtcountsetoptions}]
%\cs{fmtcountsetoptions}\verb"{fmtord="\meta{type}\verb'}'
%\end{definition}
%where \meta{type} is either \texttt{level} or \texttt{raise}. Since version~3.01 of \sty{fmtcount}, it is also
%possible to set \meta{type} on a language by language basis, see~\S~\ref{sec:multilingual-support}.
%
%\section{Multilingual Support}
%\label{sec:multilingual-support}
%
%Version 1.02 of the \sty{fmtcount} package now has
%limited multilingual support.  The following languages are
%implemented: English, Spanish, Portuguese, French, French (Swiss)
%and French (Belgian). German support was added in version 
%1.1.\footnote{Thanks to K. H. Fricke for supplying the information.}
%Italian support was added in version 1.31.\footnote{Thanks to
%Edoardo Pasca for supplying the information.}
%
%
%To ensure the language definitions are loaded correctly for document
%dialects, use
%\begin{definition}[\DescribeMacro{\FCloadlang}]
%\cs{FCloadlang}\marg{dialect}
%\end{definition}
%in the preamble. The \meta{dialect} should match the options passed to \sty{babel} or
%\sty{polyglossia}. \sty{fmtcount} currently supports the following \meta{dialect}:
%\LanguagePackageOptionList. If you don't use this,
%\sty{fmtcount} will attempt to detect the required dialects, but
%this isn't guaranteed to work.
%
%The commands
%\cs{ordinal}, \cs{ordinalstring} and \cs{numberstring} (and their
%variants) will be formatted in the currently selected language.
%If the current language hasn't been loaded (via \cs{FCloadlang}
%above) and \sty{fmtcount} detects a definition file for that
%language it will attempt to load it, but this isn't robust and may
%cause problems, so it's best to use \cs{FCloadlang}.
%
%If the French language is selected, the \texttt{french} option let you
%configure the dialect and other aspects. The \texttt{abbr} also has
%some influence with French. Please refer to \S~\ref
%{sec:options-french}.
%
%
%The male gender for all languages is used by default, however the
%feminine or neuter forms can be obtained by passing \texttt{f} or
%\texttt{n} as an optional argument to \cs{ordinal},
%\cs{ordinalnum} etc.  For example:
%\verb"\numberstring{section}[f]". Note that the optional argument
%comes \emph{after} the compulsory argument.  If a gender is
%not defined in a given language, the masculine version will
%be used instead.
%
%Let me know if you find any spelling mistakes (has been known
%to happen in English, let alone other languages with which I'm not so
%familiar.) If you want to add support for another language,
%you will need to let me know how to form the numbers and ordinals 
%from~0 to~99999 in that language for each gender.
%
%\subsection{Options for setting ordinal ending position raise/level}
%\label{sec:options-fmtord}
%
%\begin{definition}[\DescribeMacro{\fmtcountsetoptions}]
%\cs{fmtcountsetoptions}\verb"{"\meta{language}\verb"={fmtord="\meta{type}\verb'}}'
%\end{definition}
%where \meta{language} is one of the supported language \meta{type} is either \texttt{level} or \texttt{raise}
%or \texttt{undefine}. If the value is \texttt{level} or \texttt{raise}, then that will set the \texttt{fmtord}
%option accordingly\footnote{see~\S~\ref{sec:package-options}} only for that language \meta{language}. If the
%value is \texttt{undefine}, then the non-language specific behaviour is followed.
%
%Some \meta{language} are synonyms, here is a table:
%
%\begin{center}
%  \begin{tabular}{|l|l|}\hline
%    \textbf{language}& \textbf{alias(es)}\\\hline
%    english& british\\\hline
%    french&frenchb\\\hline
%            &germanb\\
%    german&ngerman\\
%            &ngermanb\\\hline
%    USenglish&american\\\hline
%  \end{tabular}
%\end{center}
%
%\subsection{Options for French}
%\label{sec:options-french}
%
%This section is in French, as it is most useful to French speaking people.
%
%\selectlanguage{french} Il est possible de configurer plusieurs
%aspects de la numérotation en français avec les options
%\texttt{french} et \texttt{abbr}. Ces options n'ont d'effet que si le
%langage \texttt{french} est chargé.
%
%\begin{definition}[\DescribeMacro{\fmtcountsetoptions}]
%\cs{fmtcountsetoptions}\verb"{french="\marg{french options}\verb'}'
%\end{definition}
%L'argument \meta{french options} est une liste entre accolades et
%séparée par des virgules de réglages de la forme
%``\meta{clef}\texttt{=}\meta{valeur}'', chacun de ces réglages est
%ci-après désigné par ``option française'' pour le distinguer des
%``options générales'' telles que \texttt{french}.
%
%Le dialecte peut être sélectionné avec l'option française
%\texttt{dialect} dont la valeur \meta{dialect} peut être
%\texttt{france}, \texttt{belgian} ou \texttt{swiss}.
%\begin{definition}[\DescribeOption{dialect}]
%\cs{fmtcountsetoptions}\verb"{french={dialect="\marg{dialect}\verb'}}'
%\end{definition}
%\begin{definition}[\DescribeOption{french}]
%\cs{fmtcountsetoptions}\verb"{french="\meta{dialect}\verb'}'
%\end{definition}
%
%Pour alléger la notation et par souci de rétro-compatibilité
%\texttt{france}, \texttt{belgian} ou \texttt{swiss} sont également des
%\meta{clef}s pour \meta{french options} à utiliser sans \meta{valeur}.
%
%L'effet de l'option \texttt{dialect} est illustré ainsi:\newline
%\begin{tabularx}{\linewidth}{@{}lX@{}}
%  \pkgopt{france}& soixante-dix pour 70, quatre-vingts pour 80, et
%  quatre-vingts-dix pour 90,\\
%  \pkgopt{belgian} & septante pour 70, quatre-vingts pour 80, et
%  nonante pour 90, \\
%  \pkgopt{swiss} &septante pour 70, huitante\footnote{voir
%    \href{http://www.alain.be/Boece/huitante_octante.html}{Octante et
%      huitante} sur le site d'Alain Lassine} pour 80, et
%  nonante pour 90
%\end{tabularx}
%Il est à noter que la variante \texttt{belgian} est parfaitement
%correcte pour les francophones français\footnote{je précise que
%  l'auteur de ces lignes est français}, et qu'elle est également
%utilisée en Suisse Romande hormis dans les cantons de Vaud, du Valais
%et de Fribourg. En ce qui concerne le mot ``octante'', il n'est
%actuellement pas pris en charge et n'est guère plus utilisé, ce qui
%est sans doute dommage car il est sans doute plus acceptable que le
%``huitante'' de certains de nos amis suisses.
%
%\begin{definition}[\DescribeOption{abbr}]
%\cs{fmtcountsetoptions}\verb"{abbr="\meta{boolean}\verb'}'
%\end{definition}
%L'option générale \texttt{abbr} permet de changer l'effet de
%\cs{ordinal}. Selon \meta{boolean} on a:\newline
%\begin{tabularx}{\linewidth}{@{}lX@{}}
%  \pkgopt{true}& pour produire des ordinaux de la forme
%  {\def\languagename{french}\csname fmtord@abbrvtrue\endcsname\ordinalnum{2}} (par défaut), ou\\
%  \pkgopt{false}& pour produire des ordinaux de la forme
%  {\def\languagename{french}\csname fmtord@abbrvfalse\endcsname\ordinalnum{2}} \\
%\end{tabularx}
%
%\begin{definition}[\DescribeOption{vingt plural}]
%\cs{fmtcountsetoptions}\verb"{french={vingt plural="\meta{french plural control}\verb'}}'
%\end{definition}
%\begin{definition}[\DescribeOption{cent plural}]
%\cs{fmtcountsetoptions}\verb"{french={cent plural="\meta{french plural control}\verb'}}'
%\end{definition}
%\begin{definition}[\DescribeOption{mil plural}]
%\cs{fmtcountsetoptions}\verb"{french={mil plural="\meta{french plural control}\verb'}}'
%\end{definition}
%\begin{definition}[\DescribeOption{n-illion plural}]
%\cs{fmtcountsetoptions}\verb"{french={n-illion plural="\meta{french plural control}\verb'}}'
%\end{definition}
%\begin{definition}[\DescribeOption{n-illiard plural}]
%\cs{fmtcountsetoptions}\verb"{french={n-illiard plural="\meta{french plural control}\verb'}}'
%\end{definition}
%\begin{definition}[\DescribeOption{all plural}]
%\cs{fmtcountsetoptions}\verb"{french={all plural="\meta{french plural control}\verb'}}'
%\end{definition}
%Les options \texttt{vingt plural}, \texttt{cent plural}, \texttt{mil plural}, \texttt{n-illion plural}, et
%\texttt{n-illiard plural}, permettent de contrôler très finement l'accord en nombre des mots respectivement
%vingt, cent, mil, et des mots de la forme \meta{\(n\)}illion et \meta{\(n\)}illiard, où \meta{\(n\)} désigne
%`m' pour 1, `b' pour 2, 'tr' pour 3, etc. L'option \texttt{all plural} est un raccourci permettant de
%contrôler de concert l'accord en nombre de tous ces mots. Tous ces paramètres valent \texttt{reformed} par
%défaut.
%
%Attention, comme on va l'expliquer, seules quelques combinaisons de configurations de ces options donnent un
%orthographe correcte vis à vis des règles en vigueur. La raison d'être de ces options est la suivante~:
%\begin{itemize}
%\item la règle de l'accord en nombre des noms de nombre dans un numéral cardinal dépend de savoir s'il a
%  vraiment une valeur cardinale ou bien une valeur ordinale, ainsi on écrit \og aller à la page deux-cent
%  (sans s) d'un livre de deux-cents (avec s) pages\fg, il faut donc pouvoir changer la configuration pour
%  sélectionner le cas considéré,
%\item un autre cas demandant quelque configurabilité est celui de \og mil\fg\ et \og mille\fg. Pour rappel \og
%  mille\fg\ est le pluriel irrégulier de \og mil\fg, mais l'alternance mil/mille est rare, voire pédante, car
%  aujourd'hui \og mille\fg\ n'est utilisé que comme un mot invariable, en effet le sort des pluriels étrangers
%  est systématiquement de finir par disparaître comme par exemple \og scénarii\fg\ aujourd'hui supplanté par
%  \og scénarios\fg. Pour continuer à pouvoir écrire \og mil\fg, il aurait fallu former le pluriel comme \og
%  mils\fg, ce qui n'est pas l'usage.  Certaines personnes utilisent toutefois encore \og mil\fg\ dans les
%  dates, par exemple \og mil neuf cent quatre-vingt quatre\fg\ au lieu de \og mille neuf cent quatre-vingt
%  quatre\fg,
%\item finalement les règles du français quoique bien définies ne sont pas très cohérentes et il est donc
%  inévitable qu'un jour ou l'autre on on les simplifie. Le paquetage \styfmt{fmtcount} est déjà prêt à cette
%  éventualité.
%\end{itemize}
%
%Le paramètre \meta{french plural control} peut prendre les valeurs suivantes:\newline
%\settowidth{\tabcolwidth}{\pkgopt{multiple lng-width}}
%\begin{supertabular}{@{}p{\tabcolwidth}p{\dimexpr\linewidth-\tabcolwidth-2\tabcolsep}@{}}
%  \pkgopt{traditional}& pour sélectionner la règle en usage chez les adultes à la date de parution de ce
%  document, et dans le cas des numéraux cardinaux, lorsqu'ils ont une valeur cardinale,\\
%  \pkgopt{reformed}& pour suivre toute nouvelle recommandation à la date de parution de ce document, , et
%  dans le cas des numéraux cardinaux, lorsqu'ils ont une valeur cardinale, l'idée des options
%  \texttt{traditional} et \texttt{reformed} est donc de pouvoir contenter à la fois les anciens et les
%  modernes, mais à dire vrai à la date où ce document est écrit elles ont exactement
%  le même effet,\\
%  \pkgopt{traditional o}& pareil que \texttt{traditional} mais dans le cas des numéraux cardinaux,
%  lorsqu'ils
%  ont une valeur ordinale,\\
%  \pkgopt{reformed o}& pareil que \texttt{reformed} mais dans le cas des numéraux cardinaux, lorsqu'ils ont
%  une valeur ordinale, de même que précédemment \texttt{reformed o} et \texttt{traditional o} ont
%  exactement le même effet,\\
%  \pkgopt{always}& pour marquer toujours le pluriel, ceci n'est correct que pour \og mil\fg\ vis à vis des
%  règles en vigueur,\\
%  \pkgopt{never}& pour ne jamais marquer le pluriel, ceci est incorrect vis à vis des règles d'orthographe
%  en vigueur,\\
%  \pkgopt{multiple}& pour marquer le pluriel lorsque le nombre considéré est multiplié par au moins 2, ceci
%  est la règle en vigueur pour les nombres de la forme \meta{\(n\)}illion et \meta{\(n\)}illiard lorsque le
%  nombre a une valeur cardinale,\\
%  \pkgopt{multiple g-last}& pour marquer le pluriel lorsque le nombre considéré est multiplié par au moins 2
%  est est \emph{\textbf{g}lobalement} en dernière position, où ``globalement'' signifie qu'on considère le
%  nombre formaté en entier, ceci est incorrect vis à vis des règles d'orthographe
%  en vigueur,\\
%  \pkgopt{multiple l-last}& pour marquer le pluriel lorsque le nombre considéré est multiplié par au moins 2
%  et est \emph{\textbf{l}ocalement} en dernière position, où ``localement'' siginifie qu'on considère
%  seulement la portion du nombre qui multiplie soit l'unité, soit un \meta{\(n\)}illion ou un
%  \meta{\(n\)}illiard~; ceci est la convention en vigueur pour le pluriel de ``vingt'' et de ``cent''
%  lorsque le nombre formaté a une valeur cardinale,\\
%  \pkgopt{multiple lng-last}& pour marquer le pluriel lorsque le nombre considéré est multiplié par au moins
%  2 et est \emph{\textbf{l}ocalement} mais \emph{\textbf{n}on \textbf{g}lobablement} en dernière position,
%  où ``localement'' et \emph{globablement} on la même siginification que pour les options \texttt{multiple
%    g-last} et \texttt{multiple l-last}~; ceci est la convention en vigueur pour le pluriel de ``vingt'' et
%  de ``cent'' lorsque le nombre formaté a une valeur ordinale,\\
%  \pkgopt{multiple ng-last}& pour marquer le pluriel lorsque le nombre considéré est multiplié par au moins
%  2, et \emph{\textbf{n}}'est pas \emph{\textbf{g}lobalement} en dernière position, où ``globalement'' a la
%  même signification que pour l'option \texttt{multiple g-last}~; ceci est la règle que j'infère être en
%  vigueur pour les nombres de la forme \meta{\(n\)}illion et \meta{\(n\)}illiard lorsque le nombre a une
%  valeur ordinale, mais à dire vrai pour des nombres aussi grands, par exemple \og deux millions\fg, je
%  pense qu'il n'est tout simplement pas d'usage de dire \og l'exemplaire deux million(s?)\fg\ pour \og le
%  deux millionième
%  exemplaire\fg.\\
%\end{supertabular}
%
%L'effet des paramètres \texttt{traditional}, \texttt{traditional o}, \texttt{reformed}, et \texttt{reformed
%  o}, est le suivant~:
%
%\setlength{\tabcolwidth}{\linewidth}
%\addtolength{\tabcolwidth}{-10\tabcolsep}
%\addtolength{\tabcolwidth}{-6\arrayrulewidth}
%\noindent\begin{tabular*}{\linewidth}{|%
%    >{\centering\arraybackslash\ttfamily}p{\dimexpr0.204\tabcolwidth-\arrayrulewidth-\doublerulesep}||%
%    *{4}{>{\centering\arraybackslash\ttfamily}p{0.199\tabcolwidth}|}}\hline
%  \textrm{\meta{x} dans ``\meta{x} }plural\textrm{''}&traditional&reformed&traditional o&reformed o\\\hline
%  \hline
%  vingt&\multicolumn{2}{c|}{}&\multicolumn{2}{c|}{}\\\cline{1-1}
%  cent&%
%  \multicolumn{2}{c|}{\multirow{-2}{\dimexpr0.398\tabcolwidth+\arrayrulewidth+2\tabcolsep}{\centering 
%      multiple l-last}}&%
%  \multicolumn{2}{c|}{\multirow{-2}{\dimexpr0.398\tabcolwidth+\arrayrulewidth+2\tabcolsep}{\centering 
%      multiple lng-last}}\\\hline
%  mil&\multicolumn{4}{c|}{always}\\\hline
%  n-illion&\multicolumn{2}{c|}{}&\multicolumn{2}{c|}{}\\\cline{1-1}
%  n-illiard&%
%  \multicolumn{2}{c|}{\multirow{-2}{\dimexpr0.398\tabcolwidth+\arrayrulewidth+2\tabcolsep}{\centering 
%      multiple}}&%
%  \multicolumn{2}{c|}{\multirow{-2}{\dimexpr0.398\tabcolwidth+\arrayrulewidth+2\tabcolsep}{\centering 
%      multiple ng-last}}\\\hline
%\end{tabular*}
%
%Les configurations qui respectent les règles d'orthographe sont les suivantes~:
%\begin{itemize}
%\item \verb"\fmtcountsetoptions{french={all plural=reformed o}}" pour formater les numéraux cardinaux à
%  valeur ordinale,
%\item \verb"\fmtcountsetoptions{french={mil plural=multiple}}" pour activer l'alternance mil/mille.
%\item \verb"\fmtcountsetoptions{french={all plural=reformed}}" pour revenir dans la configuration par
%  défaut.
%\end{itemize}
%
%\begin{definition}[\DescribeOption{dash or space}]
%\cs{fmtcountsetoptions}\verb"{french={dash or space="\meta{dash or space}\verb'}}'
%\end{definition}
%Avant la réforme de l'orthographe de 1990, on ne met des traits d'union qu'entre les dizaines et les unités,
%et encore sauf quand le nombre \(n\) considéré est tel que \(n\mod10=1\), dans ce cas on écrit ``et un''
%sans trait d'union. Après la réforme de 1990, on recommande de mettre des traits d'union de partout sauf
%autour de ``mille'', ``million'' et ``milliard'', et les mots analogues comme ``billion'',
%``billiard''. Cette exception a toutefois été contestée par de nombreux auteurs, et on peut aussi mettre des
%traits d'union de partout.  Mettre l'option \meta{dash or space} à:\newline
%\begin{tabularx}{\linewidth}{lX}
%  \pkgopt{traditional}&  pour sélectionner la règle d'avant la réforme de 1990,\\
%  \pkgopt{1990}&  pour suivre  la recommandation de la réforme de 1990, \\
%  \pkgopt{reformed}&  pour suivre  la recommandation de la dernière
%  réforme pise en charge, actuellement l'effet est le même que \textrm{1990}, ou à\\
%  \pkgopt{always}&  pour mettre systématiquement des traits d'union de partout.\\
%\end{tabularx}
%Par défaut, l'option vaut \texttt{reformed}.
%
%
%\begin{definition}[\DescribeOption{scale}]
%\cs{fmtcountsetoptions}\verb"{french={scale="\meta{scale}\verb'}}'
%\end{definition}
%L'option \texttt{scale} permet de configurer l'écriture des grands
%nombres. Mettre \meta{scale} à:\newline
%\begin{tabularx}{\linewidth}{lX}
%  \pkgopt{recursive}&  dans ce cas \(10^{30}\) donne mille milliards de
%  milliards de milliards, pour \(10^n\), on écrit \(10^{n-9\times
%    \max\{(n\div 9)-1,0\}}\) suivi de la répétition \(\max\{(n\div
%  9)-1,0\}\) fois de ``de milliards''\\
%  \pkgopt{long}&  \(10^{6\times n}\) donne un \meta{\(n\)}illion où
%  \meta{\(n\)} est remplacé par ``bi'' pour 2, ``tri'' pour 3, etc. et
%  \(10^{6\times n+3}\) donne un \meta{\(n\)}illiard avec la même
%  convention pour \meta{\(n\)}. L'option \texttt{long} est correcte en
%  Europe, par contre j'ignore l'usage au
%  Québec.\\
%  \pkgopt{short}&  \(10^{6\times n}\) donne un \meta{\(n\)}illion où
%  \meta{\(n\)} est remplacé par ``bi'' pour 2, ``tri'' pour 3,
%  etc. L'option \texttt{short} est incorrecte en Europe.
%\end{tabularx}
%Par défaut, l'option vaut \texttt{recursive}.
%
%\begin{definition}[\DescribeOption{n-illiard upto}]
%\cs{fmtcountsetoptions}\verb"{french={n-illiard upto="\meta{n-illiard upto}\verb'}}'
%\end{definition}
%Cette option n'a de sens que si \texttt{scale} vaut
%\texttt{long}. Certaines personnes préfèrent dire ``mille
%\meta{$n$}illions'' qu'un ``\meta{$n$}illiard''. Mettre l'option
%\texttt{n-illiard upto} à:\newline
%\begin{tabularx}{\linewidth}{lX}
%  \pkgopt{infinity}&  pour que \(10^{6\times n +3}\) donne
%  \meta{$n$}illiards pour tout \(n>0\),\\
%  \pkgopt{infty}&  même effet que \texttt{infinity}, \\
%  \(k\)&  où \(k\) est un entier quelconque strictement positif, dans
%  ce cas \(10^{6\times n +3}\) donne ``mille \meta{\(n\)}illions''
%  lorsque \(n>k\), et donne ``\meta{\(n\)}illiard'' sinon\\
%\end{tabularx}
%
%\begin{definition}[\DescribeOption{mil plural mark}]
%\cs{fmtcountsetoptions}\verb"{french={mil plural mark="\meta{any text}\verb'}}'
%\end{definition}
%La valeur par défaut de cette option est \og\texttt{le}\fg. Il s'agit de la terminaison ajoutée à \og
%mil\fg\ pour former le pluriel, c'est à dire \og mille\fg, cette option ne sert pas à grand chose sauf dans
%l'éventualité où ce pluriel serait francisé un jour --- à dire vrai si cela se produisait une alternance
%mille/milles est plus vraisemblable, car \og mille\fg\ est plus fréquent que \og mille\fg\ et que les
%pluriels francisés sont formés en ajoutant \og s\fg\ à la forme la plus fréquente, par exemple \og
%blini/blinis\fg, alors que \og blini\fg\ veut dire \og crêpes\fg\ (au pluriel).
%
%
%\selectlanguage{english}
%
%%\subsection{Prefixes}
%%\label{sec:latin-prefixes}
%%
%%\begin{definition}[\DescribeMacro{\latinnumeralstring}]
%%\cs{latinnumeralstring}\marg{counter}\oarg{prefix options}
%%\end{definition}
%%
%%\begin{definition}[\DescribeMacro{\latinnumeralstringnum}]
%%\cs{latinnumeralstringnum}\marg{number}\oarg{prefix options}
%%\end{definition}
%
%
%\section{Configuration File \texttt{fmtcount.cfg}}
%
%You can save your preferred default settings to a file called
%\texttt{fmtcount.cfg}, and place it on the \TeX\ path.  These
%settings will then be loaded by the \sty{fmtcount}
%package.
%
%Note that if you are using the \sty{datetime} package,
%the \texttt{datetime.cfg} configuration file will override
%the \texttt{fmtcount.cfg} configuration file.
%For example, if \texttt{datetime.cfg} has the line:
%\begin{verbatim}
%\renewcommand{\fmtord}[1]{\textsuperscript{\underline{#1}}}
%\end{verbatim}
%and if \texttt{fmtcount.cfg} has the line:
%\begin{verbatim}
%\fmtcountsetoptions{fmtord=level}
%\end{verbatim}
%then the former definition of \cs{fmtord} will take
%precedence.
%
%\section{LaTeX2HTML style}
%
%The \LaTeX2HTML\ style file \texttt{fmtcount.perl} is provided.
%The following limitations apply:
%
%\begin{itemize}
%\item \cs{padzeroes} only has an effect in the preamble.
%
%\item The configuration file 
%\texttt{fmtcount.cfg} is currently ignored. (This is because
%I can't work out the correct code to do this.  If you
%know how to do this, please let me know.)  You can however
%do:
%\begin{verbatim}
%\usepackage{fmtcount}
%\html{\input{fmtcount.cfg}}
%\end{verbatim}
%This, I agree, is an unpleasant cludge.
%
%\end{itemize}
%
%\section{Acknowledgements}
%
%I would like to thank all the people who have provided translations.
%
%\section{Troubleshooting}
%
%There is a FAQ available at: 
%\url{http://theoval.cmp.uea.ac.uk/~nlct/latex/packages/faq/}.
%
%Bug reporting should be done via the Github issue manager at: 
%\url{https://github.com/nlct/fmtcount/issues/}.
%
%
%% Local Variables:
%% coding: utf-8
%% End:
%
%\StopEventually{}
%\section{The Code}
%\iffalse
%    \begin{macrocode}
%<*fc-american.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-american.def}
% American English definitions
%    \begin{macrocode}
\ProvidesFCLanguage{american}[2013/08/17]%
%    \end{macrocode}
% Loaded fc-USenglish.def if not already loaded
%    \begin{macrocode}
\FCloadlang{USenglish}%
%    \end{macrocode}
% These are all just synonyms for the commands provided by
% fc-USenglish.def.
%    \begin{macrocode}
\global\let\@ordinalMamerican\@ordinalMUSenglish
\global\let\@ordinalFamerican\@ordinalMUSenglish
\global\let\@ordinalNamerican\@ordinalMUSenglish
\global\let\@numberstringMamerican\@numberstringMUSenglish
\global\let\@numberstringFamerican\@numberstringMUSenglish
\global\let\@numberstringNamerican\@numberstringMUSenglish
\global\let\@NumberstringMamerican\@NumberstringMUSenglish
\global\let\@NumberstringFamerican\@NumberstringMUSenglish
\global\let\@NumberstringNamerican\@NumberstringMUSenglish
\global\let\@ordinalstringMamerican\@ordinalstringMUSenglish
\global\let\@ordinalstringFamerican\@ordinalstringMUSenglish
\global\let\@ordinalstringNamerican\@ordinalstringMUSenglish
\global\let\@OrdinalstringMamerican\@OrdinalstringMUSenglish
\global\let\@OrdinalstringFamerican\@OrdinalstringMUSenglish
\global\let\@OrdinalstringNamerican\@OrdinalstringMUSenglish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-american.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-british.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-british.def}
% British definitions
%    \begin{macrocode}
\ProvidesFCLanguage{british}[2013/08/17]%
%    \end{macrocode}
% Load fc-english.def, if not already loaded
%    \begin{macrocode}
\FCloadlang{english}%
%    \end{macrocode}
% These are all just synonyms for the commands provided by
% fc-english.def.
%    \begin{macrocode}
\global\let\@ordinalMbritish\@ordinalMenglish
\global\let\@ordinalFbritish\@ordinalMenglish
\global\let\@ordinalNbritish\@ordinalMenglish
\global\let\@numberstringMbritish\@numberstringMenglish
\global\let\@numberstringFbritish\@numberstringMenglish
\global\let\@numberstringNbritish\@numberstringMenglish
\global\let\@NumberstringMbritish\@NumberstringMenglish
\global\let\@NumberstringFbritish\@NumberstringMenglish
\global\let\@NumberstringNbritish\@NumberstringMenglish
\global\let\@ordinalstringMbritish\@ordinalstringMenglish
\global\let\@ordinalstringFbritish\@ordinalstringMenglish
\global\let\@ordinalstringNbritish\@ordinalstringMenglish
\global\let\@OrdinalstringMbritish\@OrdinalstringMenglish
\global\let\@OrdinalstringFbritish\@OrdinalstringMenglish
\global\let\@OrdinalstringNbritish\@OrdinalstringMenglish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-british.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-english.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-english.def}
% English definitions
%    \begin{macrocode}
\ProvidesFCLanguage{english}[2013/08/17]%
%    \end{macrocode}
% Define macro that converts a number or count register (first 
% argument) to an ordinal, and stores the result in the 
% second argument, which should be a control sequence.
%    \begin{macrocode}
\newcommand*\@ordinalMenglish[2]{%
\def\@fc@ord{}%
\@orgargctr=#1\relax
\@ordinalctr=#1%
\@FCmodulo{\@ordinalctr}{100}%
\ifnum\@ordinalctr=11\relax
  \def\@fc@ord{th}%
\else
  \ifnum\@ordinalctr=12\relax
    \def\@fc@ord{th}%
  \else
    \ifnum\@ordinalctr=13\relax
      \def\@fc@ord{th}%
    \else
      \@FCmodulo{\@ordinalctr}{10}%
      \ifcase\@ordinalctr
        \def\@fc@ord{th}%      case 0
        \or \def\@fc@ord{st}%  case 1
        \or \def\@fc@ord{nd}%  case 2
        \or \def\@fc@ord{rd}%  case 3
      \else
        \def\@fc@ord{th}%      default case
      \fi
    \fi
  \fi
\fi
\edef#2{\number#1\relax\noexpand\fmtord{\@fc@ord}}%
}%
\global\let\@ordinalMenglish\@ordinalMenglish
%    \end{macrocode}
% There is no gender difference in English, so make feminine and
% neuter the same as the masculine.
%    \begin{macrocode}
\global\let\@ordinalFenglish=\@ordinalMenglish
\global\let\@ordinalNenglish=\@ordinalMenglish
%    \end{macrocode}
% Define the macro that prints the value of a \TeX\ count register
% as text. To make it easier, break it up into units, teens and
% tens. First, the units: the argument should be between 0 and 9
% inclusive.
%    \begin{macrocode}
\newcommand*\@@unitstringenglish[1]{%
  \ifcase#1\relax
    zero%
    \or one%
    \or two%
    \or three%
    \or four%
    \or five%
    \or six%
    \or seven%
    \or eight%
    \or nine%
\fi
}%
\global\let\@@unitstringenglish\@@unitstringenglish
%    \end{macrocode}
% Next the tens, again the argument should be between 0 and 9
% inclusive.
%    \begin{macrocode}
\newcommand*\@@tenstringenglish[1]{%
  \ifcase#1\relax
    \or ten%
    \or twenty%
    \or thirty%
    \or forty%
    \or fifty%
    \or sixty%
    \or seventy%
    \or eighty%
    \or ninety%
  \fi
}%
\global\let\@@tenstringenglish\@@tenstringenglish
%    \end{macrocode}
% Finally the teens, again the argument should be between 0 and 9
% inclusive.
%    \begin{macrocode}
\newcommand*\@@teenstringenglish[1]{%
  \ifcase#1\relax
    ten%
    \or eleven%
    \or twelve%
    \or thirteen%
    \or fourteen%
    \or fifteen%
    \or sixteen%
    \or seventeen%
    \or eighteen%
    \or nineteen%
  \fi
}%
\global\let\@@teenstringenglish\@@teenstringenglish
%    \end{macrocode}
% As above, but with the initial letter in uppercase. The units:
%    \begin{macrocode}
\newcommand*\@@Unitstringenglish[1]{%
  \ifcase#1\relax
    Zero%
    \or One%
    \or Two%
    \or Three%
    \or Four%
    \or Five%
    \or Six%
    \or Seven%
    \or Eight%
    \or Nine%
  \fi
}%
\global\let\@@Unitstringenglish\@@Unitstringenglish
%    \end{macrocode}
% The tens:
%    \begin{macrocode}
\newcommand*\@@Tenstringenglish[1]{%
  \ifcase#1\relax
    \or Ten%
    \or Twenty%
    \or Thirty%
    \or Forty%
    \or Fifty%
    \or Sixty%
    \or Seventy%
    \or Eighty%
    \or Ninety%
  \fi
}%
\global\let\@@Tenstringenglish\@@Tenstringenglish
%    \end{macrocode}
% The teens:
%    \begin{macrocode}
\newcommand*\@@Teenstringenglish[1]{%
  \ifcase#1\relax
    Ten%
    \or Eleven%
    \or Twelve%
    \or Thirteen%
    \or Fourteen%
    \or Fifteen%
    \or Sixteen%
    \or Seventeen%
    \or Eighteen%
    \or Nineteen%
  \fi
}%
\global\let\@@Teenstringenglish\@@Teenstringenglish
%    \end{macrocode}
% This has changed in version 1.09, so that it now stores
% the result in the second argument, but doesn't display anything.
% Since it only affects internal macros, it shouldn't affect
% documents created with older versions. (These internal macros are
% not meant for use in documents.)
%    \begin{macrocode}
\newcommand*\@@numberstringenglish[2]{%
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9
  \divide\@strctr by 10
  \ifnum\@strctr>1\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
    \@strctr=#1 \divide\@strctr by 1000\relax
    \@FCmodulo{\@strctr}{10}%
    \ifnum\@strctr>0\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr-\@unitstring{\@strctr}}%
    \fi
  \else
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@FCmodulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\ \@thousand}%
\else
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ \@thousand}%
  \fi
\fi
\@strctr=#1\relax \@FCmodulo{\@strctr}{1000}%
\divide\@strctr by 100
\ifnum\@strctr>0\relax
   \ifnum#1>1000\relax
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\ }%
   \fi
   \let\@@fc@numstr#2\relax
   \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ \@hundred}%
\fi
\@strctr=#1\relax \@FCmodulo{\@strctr}{100}%
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ \@andname\ }%
  \fi
\fi
\ifnum\@strctr>19\relax
  \divide\@strctr by 10\relax
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
  \@strctr=#1\relax \@FCmodulo{\@strctr}{10}%
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr-\@unitstring{\@strctr}}%
  \fi
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
       \ifnum#1<100\relax
          \let\@@fc@numstr#2\relax
          \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
       \fi
    \else
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
    \fi
  \else
    \@FCmodulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
\fi
}%
\global\let\@@numberstringenglish\@@numberstringenglish
%    \end{macrocode}
% All lower case version, the second argument must be a 
% control sequence.
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMenglish}[2]{%
  \let\@unitstring=\@@unitstringenglish
  \let\@teenstring=\@@teenstringenglish
  \let\@tenstring=\@@tenstringenglish
  \def\@hundred{hundred}\def\@thousand{thousand}%
  \def\@andname{and}%
  \@@numberstringenglish{#1}{#2}%
}%
\global\let\@numberstringMenglish\@numberstringMenglish
%    \end{macrocode}
% There is no gender in English, so make feminine and neuter the
% same
% as the masculine.
%    \begin{macrocode}
\global\let\@numberstringFenglish=\@numberstringMenglish
\global\let\@numberstringNenglish=\@numberstringMenglish
%    \end{macrocode}
% This version makes the first letter of each word an uppercase
% character (except ``and''). The second argument must be a control 
% sequence.
%    \begin{macrocode}
\newcommand*\@NumberstringMenglish[2]{%
  \let\@unitstring=\@@Unitstringenglish
  \let\@teenstring=\@@Teenstringenglish
  \let\@tenstring=\@@Tenstringenglish
  \def\@hundred{Hundred}\def\@thousand{Thousand}%
  \def\@andname{and}%
  \@@numberstringenglish{#1}{#2}%
}%
\global\let\@NumberstringMenglish\@NumberstringMenglish
%    \end{macrocode}
% There is no gender in English, so make feminine and neuter the
% same
% as the masculine.
%    \begin{macrocode}
\global\let\@NumberstringFenglish=\@NumberstringMenglish
\global\let\@NumberstringNenglish=\@NumberstringMenglish
%    \end{macrocode}
% Define a macro that produces an ordinal as a string. Again, break
% it up into units, teens and tens. First the units:
%    \begin{macrocode}
\newcommand*\@@unitthstringenglish[1]{%
  \ifcase#1\relax
    zeroth%
    \or first%
    \or second%
    \or third%
    \or fourth%
    \or fifth%
    \or sixth%
    \or seventh%
    \or eighth%
    \or ninth%
  \fi
}%
\global\let\@@unitthstringenglish\@@unitthstringenglish
%    \end{macrocode}
% Next the tens:
%    \begin{macrocode}
\newcommand*\@@tenthstringenglish[1]{%
  \ifcase#1\relax
    \or tenth%
    \or twentieth%
    \or thirtieth%
    \or fortieth%
    \or fiftieth%
    \or sixtieth%
    \or seventieth%
    \or eightieth%
    \or ninetieth%
  \fi
}%
\global\let\@@tenthstringenglish\@@tenthstringenglish
%    \end{macrocode}
% The teens:
%    \begin{macrocode}
\newcommand*\@@teenthstringenglish[1]{%
  \ifcase#1\relax
    tenth%
    \or eleventh%
    \or twelfth%
    \or thirteenth%
    \or fourteenth%
    \or fifteenth%
    \or sixteenth%
    \or seventeenth%
    \or eighteenth%
    \or nineteenth%
  \fi
}%
\global\let\@@teenthstringenglish\@@teenthstringenglish
%    \end{macrocode}
% As before, but with the first letter in upper case. The units:
%    \begin{macrocode}
\newcommand*\@@Unitthstringenglish[1]{%
  \ifcase#1\relax
    Zeroth%
    \or First%
    \or Second%
    \or Third%
    \or Fourth%
    \or Fifth%
    \or Sixth%
    \or Seventh%
    \or Eighth%
    \or Ninth%
  \fi
}%
\global\let\@@Unitthstringenglish\@@Unitthstringenglish
%    \end{macrocode}
% The tens:
%    \begin{macrocode}
\newcommand*\@@Tenthstringenglish[1]{%
  \ifcase#1\relax
    \or Tenth%
    \or Twentieth%
    \or Thirtieth%
    \or Fortieth%
    \or Fiftieth%
    \or Sixtieth%
    \or Seventieth%
    \or Eightieth%
    \or Ninetieth%
  \fi
}%
\global\let\@@Tenthstringenglish\@@Tenthstringenglish
%    \end{macrocode}
% The teens:
%    \begin{macrocode}
\newcommand*\@@Teenthstringenglish[1]{%
  \ifcase#1\relax
    Tenth%
    \or Eleventh%
    \or Twelfth%
    \or Thirteenth%
    \or Fourteenth%
    \or Fifteenth%
    \or Sixteenth%
    \or Seventeenth%
    \or Eighteenth%
    \or Nineteenth%
  \fi
}%
\global\let\@@Teenthstringenglish\@@Teenthstringenglish
%    \end{macrocode}
% Again, as from version 1.09, this has been changed to take two
% arguments, where the second argument is a control sequence.
% The resulting text is stored in the control sequence, and nothing
% is displayed.
%    \begin{macrocode}
\newcommand*\@@ordinalstringenglish[2]{%
\@strctr=#1\relax
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000 (value given: \number\@strctr)}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\fi
\def#2{}%
\fi
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9\relax
%    \end{macrocode}
% \#1 is greater or equal to 10000
%    \begin{macrocode}
  \divide\@strctr by 10
  \ifnum\@strctr>1\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@tenstring{\@strctr}}%
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@FCmodulo{\@strctr}{10}%
    \ifnum\@strctr>0\relax
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr-\@unitstring{\@strctr}}%
    \fi
  \else
    \@strctr=#1\relax \divide\@strctr by 1000\relax
    \@FCmodulo{\@strctr}{10}%
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@teenstring{\@strctr}}%
  \fi
  \@strctr=#1\relax \@FCmodulo{\@strctr}{1000}%
  \ifnum\@strctr=0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@thousandth}%
  \else
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@thousand}%
  \fi
\else
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
    \@strctr=#1\relax \@FCmodulo{\@strctr}{1000}%
    \let\@@fc@ordstr#2\relax
    \ifnum\@strctr=0\relax
      \edef#2{\@@fc@ordstr\ \@thousandth}%
    \else
      \edef#2{\@@fc@ordstr\ \@thousand}%
    \fi
  \fi
\fi
\@strctr=#1\relax \@FCmodulo{\@strctr}{1000}%
\divide\@strctr by 100
\ifnum\@strctr>0\relax
  \ifnum#1>1000\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ }%
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
  \@strctr=#1\relax \@FCmodulo{\@strctr}{100}%
  \let\@@fc@ordstr#2\relax
  \ifnum\@strctr=0\relax
    \edef#2{\@@fc@ordstr\ \@hundredth}%
  \else
    \edef#2{\@@fc@ordstr\ \@hundred}%
  \fi
\fi
\@strctr=#1\relax \@FCmodulo{\@strctr}{100}%
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@andname\ }%
  \fi
\fi
\ifnum\@strctr>19\relax
  \@tmpstrctr=\@strctr
  \divide\@strctr by 10\relax
  \@FCmodulo{\@tmpstrctr}{10}%
  \let\@@fc@ordstr#2\relax
  \ifnum\@tmpstrctr=0\relax
    \edef#2{\@@fc@ordstr\@tenthstring{\@strctr}}%
  \else
    \edef#2{\@@fc@ordstr\@tenstring{\@strctr}}%
  \fi
  \@strctr=#1\relax \@FCmodulo{\@strctr}{10}%
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr-\@unitthstring{\@strctr}}%
  \fi
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
      \ifnum#1<100\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
      \fi
    \else
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
    \fi
  \else
    \@FCmodulo{\@strctr}{10}%
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@teenthstring{\@strctr}}%
  \fi
\fi
}%
\global\let\@@ordinalstringenglish\@@ordinalstringenglish
%    \end{macrocode}
% All lower case version. Again, the second argument must be a
% control sequence in which the resulting text is stored.
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMenglish}[2]{%
  \let\@unitthstring=\@@unitthstringenglish
  \let\@teenthstring=\@@teenthstringenglish
  \let\@tenthstring=\@@tenthstringenglish
  \let\@unitstring=\@@unitstringenglish
  \let\@teenstring=\@@teenstringenglish
  \let\@tenstring=\@@tenstringenglish
  \def\@andname{and}%
  \def\@hundred{hundred}\def\@thousand{thousand}%
  \def\@hundredth{hundredth}\def\@thousandth{thousandth}%
  \@@ordinalstringenglish{#1}{#2}%
}%
\global\let\@ordinalstringMenglish\@ordinalstringMenglish
%    \end{macrocode}
% No gender in English, so make feminine and neuter same as
% masculine:
%    \begin{macrocode}
\global\let\@ordinalstringFenglish=\@ordinalstringMenglish
\global\let\@ordinalstringNenglish=\@ordinalstringMenglish
%    \end{macrocode}
% First letter of each word in upper case:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMenglish}[2]{%
  \let\@unitthstring=\@@Unitthstringenglish
  \let\@teenthstring=\@@Teenthstringenglish
  \let\@tenthstring=\@@Tenthstringenglish
  \let\@unitstring=\@@Unitstringenglish
  \let\@teenstring=\@@Teenstringenglish
  \let\@tenstring=\@@Tenstringenglish
  \def\@andname{and}%
  \def\@hundred{Hundred}\def\@thousand{Thousand}%
  \def\@hundredth{Hundredth}\def\@thousandth{Thousandth}%
  \@@ordinalstringenglish{#1}{#2}%
}%
\global\let\@OrdinalstringMenglish\@OrdinalstringMenglish
%    \end{macrocode}
% No gender in English, so make feminine and neuter same as
% masculine:
%    \begin{macrocode}
\global\let\@OrdinalstringFenglish=\@OrdinalstringMenglish
\global\let\@OrdinalstringNenglish=\@OrdinalstringMenglish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-english.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-francais.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-francais.def}
%    \begin{macrocode}
\ProvidesFCLanguage{francais}[2013/08/17]%
\FCloadlang{french}%
%    \end{macrocode}
% Set |francais| to be equivalent to |french|.
%    \begin{macrocode}
\global\let\@ordinalMfrancais=\@ordinalMfrench
\global\let\@ordinalFfrancais=\@ordinalFfrench
\global\let\@ordinalNfrancais=\@ordinalNfrench
\global\let\@numberstringMfrancais=\@numberstringMfrench
\global\let\@numberstringFfrancais=\@numberstringFfrench
\global\let\@numberstringNfrancais=\@numberstringNfrench
\global\let\@NumberstringMfrancais=\@NumberstringMfrench
\global\let\@NumberstringFfrancais=\@NumberstringFfrench
\global\let\@NumberstringNfrancais=\@NumberstringNfrench
\global\let\@ordinalstringMfrancais=\@ordinalstringMfrench
\global\let\@ordinalstringFfrancais=\@ordinalstringFfrench
\global\let\@ordinalstringNfrancais=\@ordinalstringNfrench
\global\let\@OrdinalstringMfrancais=\@OrdinalstringMfrench
\global\let\@OrdinalstringFfrancais=\@OrdinalstringFfrench
\global\let\@OrdinalstringNfrancais=\@OrdinalstringNfrench
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-francais.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-french.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-french.def}
% Definitions for French.
%    \begin{macrocode}
\ProvidesFCLanguage{french}[2012/10/24]%
%    \end{macrocode}
% Package \styfmt{fcprefix} is needed to format the prefix \meta{$n$} in \meta{$n$}illion or
% \meta{$n$}illiard.  Big numbers were developped based on reference:
% \uref{http://www.alain.be/boece/noms\_de\_nombre.html}
% (Package now loaded by \styfmt{fmtcount})
%
% Options for controlling plural mark. First of all we define some temporary macro \cs{fc@french@set@plural}
% in order to factorize code that defines an plural mark option:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&key name,\\
% \#2&key value,\\
% \#3&configuration index for `\texttt{reformed}', \\
% \#4&configuration index for `\texttt{traditional}',\\
% \#5&configuration index for `\texttt{reformed o}', and\\
% \#6&configuration index for `\texttt{traditional o}'.
% \end{tabularx}
%    \begin{macrocode}
\def\fc@french@set@plural#1#2#3#4#5#6{%
  \ifthenelse{\equal{#2}{reformed}}{%
    \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{#3}%
  }{%
    \ifthenelse{\equal{#2}{traditional}}{%
      \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{#4}%
    }{%
      \ifthenelse{\equal{#2}{reformed o}}{%
        \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{#5}%
      }{%
        \ifthenelse{\equal{#2}{traditional o}}{%
          \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{#6}%
        }{%
          \ifthenelse{\equal{#2}{always}}{%
            \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{0}%
          }{%
            \ifthenelse{\equal{#2}{never}}{%
              \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{1}%
            }{%
              \ifthenelse{\equal{#2}{multiple}}{%
                \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{2}%
              }{%
                \ifthenelse{\equal{#2}{multiple g-last}}{%
                  \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{3}%
                }{%
                  \ifthenelse{\equal{#2}{multiple l-last}}{%
                    \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{4}%
                  }{%
                    \ifthenelse{\equal{#2}{multiple lng-last}}{%
                      \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{5}%
                    }{%
                      \ifthenelse{\equal{#2}{multiple ng-last}}{%
                        \expandafter\def\csname fc@frenchoptions@#1@plural\endcsname{6}%
                      }{%
                        \PackageError{fmtcount}{Unexpected argument}{%
                          `#2' was unexpected: french option `#1 plural' expects `reformed', `traditional',
                          `reformed o', `traditional o', `always', `never', `multiple', `multiple g-last',
                          `multiple l-last', `multiple lng-last', or `multiple ng-last'.%
                        }}}}}}}}}}}}}
%    \end{macrocode}
% Now a shorthand \cs{@tempa} is defined just to define all the options controlling plural mark. This
% shorthand takes into account that `\texttt{reformed}' and `\texttt{traditional}' have the same effect, and
% so do `\texttt{reformed o}' and `\texttt{traditional o}'.
%    \begin{macrocode}
\def\@tempa#1#2#3{%
  \define@key{fcfrench}{#1 plural}[reformed]{%
    \fc@french@set@plural{#1}{##1}{#2}{#2}{#3}{#3}%
  }%
}
\@tempa{vingt}{4}{5}
\@tempa{cent}{4}{5}
\@tempa{mil}{0}{0}
\@tempa{n-illion}{2}{6}
\@tempa{n-illiard}{2}{6}
%    \end{macrocode}
% For option `\texttt{all plural}' we cannot use the \cs{@tempa} shorthand, because `\texttt{all plural}'
% is just a multiplexer.
%    \begin{macrocode}
\define@key{fcfrench}{all plural}[reformed]{%
  \csname KV@fcfrench@vingt plural\endcsname{#1}%
  \csname KV@fcfrench@cent plural\endcsname{#1}%
  \csname KV@fcfrench@mil plural\endcsname{#1}%
  \csname KV@fcfrench@n-illion plural\endcsname{#1}%
  \csname KV@fcfrench@n-illiard plural\endcsname{#1}%
}
%    \end{macrocode}
% Now options `\texttt{dash or space}', we have three possible key values:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% traditional& use dash for numbers below 100, except when `et' is used, and space otherwise\\
% reformed& reform of 1990, use dash except with million \& milliard, and suchlikes,
%   i.e. \meta{$n$}illion and \meta{$n$}illiard,\\
% always& always use dashes to separate all words
% \end{tabularx}
%    \begin{macrocode}
\define@key{fcfrench}{dash or space}[reformed]{%
  \ifthenelse{\equal{#1}{traditional}}{%
    \let\fc@frenchoptions@supermillion@dos\space%
    \let\fc@frenchoptions@submillion@dos\space
  }{%
    \ifthenelse{\equal{#1}{reformed}\or\equal{#1}{1990}}{%
      \let\fc@frenchoptions@supermillion@dos\space
      \def\fc@frenchoptions@submillion@dos{-}%
    }{%
      \ifthenelse{\equal{#1}{always}}{%
        \def\fc@frenchoptions@supermillion@dos{-}%
        \def\fc@frenchoptions@submillion@dos{-}%
      }{%
        \PackageError{fmtcount}{Unexpected argument}{%
          French option `dash or space' expects `always', `reformed' or `traditional'
        }
      }%
    }%
  }%
}
%    \end{macrocode}
% Option `\texttt{scale}', can take 3 possible values:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%  long& for which \meta{\(n\)}illions \& \meta{\(n\)}illiards are used with \(10^{6\times n} = 1
%   \textrm{\meta{$n$}}illion\), and \(10^{6\times n+3} = 1 \textrm{\meta{$n$}}illiard\)\\
% short& for which \meta{$n$}illions only are used with \(10^{3\times n+3} = 1
%   \textrm{\meta{$n$}illion}\)\\
% recursive& for which \(10^{18} = \textrm{un milliard de milliards}\)
% \end{tabularx}
%    \begin{macrocode}
\define@key{fcfrench}{scale}[recursive]{%
  \ifthenelse{\equal{#1}{long}}{%
      \let\fc@poweroften\fc@@pot@longscalefrench
  }{%
    \ifthenelse{\equal{#1}{recursive}}{%
      \let\fc@poweroften\fc@@pot@recursivefrench
    }{%
      \ifthenelse{\equal{#1}{short}}{%
        \let\fc@poweroften\fc@@pot@shortscalefrench
      }{%
        \PackageError{fmtcount}{Unexpected argument}{%
          French option `scale' expects `long', `recursive' or `short'
        }
      }%
    }%
  }%
}
%    \end{macrocode}
% Option `\texttt{n-illiard upto}' is ignored if `\texttt{scale}' is different from `\texttt{long}'. It can
% take the following values:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% infinity&in that case \meta{$n$}illard are never disabled,\\
% infty&this is just a shorthand for `\texttt{infinity}', and\\
% \textrm{\(n\)}& any integer that is such that \(n>0\), and that \(\forall k\in\mathbb{N}, k\geq n\),
%   number \(10^{6\times k+3}\) will be formatted as ``mille \meta{$n$}illions''
% \end{tabularx}
%    \begin{macrocode}
\define@key{fcfrench}{n-illiard upto}[infinity]{%
  \ifthenelse{\equal{#1}{infinity}}{%
      \def\fc@longscale@nilliard@upto{0}%
  }{%
    \ifthenelse{\equal{#1}{infty}}{%
      \def\fc@longscale@nilliard@upto{0}%
    }{%
      \if Q\ifnum9<1#1Q\fi\else
      \PackageError{fmtcount}{Unexpected argument}{%
        French option `milliard threshold' expects `infinity', or equivalently `infty', or a non negative
        integer.}%
      \fi
      \def\fc@longscale@nilliard@upto{#1}%
    }}%
}
%    \end{macrocode}
% Now, the options `\texttt{france}', `\texttt{swiss}' and `\texttt{belgian}' are defined to select the
% dialect to use. Macro \cs{@tempa} is just a local shorthand to define each one of this option.
%    \begin{macrocode}
\def\@tempa#1{%
  \define@key{fcfrench}{#1}[]{%
    \PackageError{fmtcount}{Unexpected argument}{French option with key `#1' does not take
      any value}}%
  \expandafter\def\csname KV@fcfrench@#1@default\endcsname{%
    \def\fmtcount@french{#1}}%
}%
\@tempa{france}\@tempa{swiss}\@tempa{belgian}%
%    \end{macrocode}
% Make `\texttt{france}' the default dialect for `\texttt{french}' language
% \changes{3.01}{2014-12-18}{Move French specific stuff from \styfmt{fmtcount.sty} to \styfmt{fc-french.def}.}
%    \begin{macrocode}
\def\fmtcount@french{france}%
%    \end{macrocode}
% Now, option `\texttt{dialect}' is now defined so that `\texttt{france}', `\texttt{swiss}' and
% `\texttt{belgian}' can also be used as key values, which is more conventional although less concise.
%    \begin{macrocode}
\define@key{fcfrench}{dialect}[france]{%
  \ifthenelse{\equal{#1}{france}
    \or\equal{#1}{swiss}
    \or\equal{#1}{belgian}}{%
    \def\fmtcount@french{#1}}{%
    \PackageError{fmtcount}{Invalid value `#1' to french option dialect key}
    {Option `french' can only take the values `france',
      `belgian' or `swiss'}}}
%    \end{macrocode}
% The option \texttt{mil plural mark} allows to make the plural of \texttt{mil} to be regular,
% i.e. \texttt{mils}, instead of \texttt{mille}. By default it is `\texttt{le}'.
%    \begin{macrocode}
\define@key{fcfrench}{mil plural mark}[le]{%
  \def\fc@frenchoptions@mil@plural@mark{#1}}
%    \end{macrocode}
% Definition of case handling macros. This should be moved somewhere else to be commonalized between all
% languages.
%    \begin{macrocode}
\def\fc@UpperCaseFirstLetter#1#2\@nil{%
  \uppercase{#1}#2}

\def\fc@CaseIden#1\@nil{%
  #1%
}
\def\fc@UpperCaseAll#1\@nil{%
  \uppercase{#1}%
}

\let\fc@case\fc@CaseIden

%    \end{macrocode}
% \DescribeMacro{\@ordinalMfrench}
% \changes{3.01}{2014-11-12}{Protect \cs{`}, for solving
%   \uref{http://github.com/nlct/fmtcount/issues/15}{Issue \#15}, and
%   correct non abbreviated ordinal finals}
% \changes{3.01}{2014-11-20}{Add a package warning about non
%   abbreviated ordinals in French being incorrect. Change ``i\`eme''
%   to ``\`eme'' which is the most frequent non abbreviated form.}
%    \begin{macrocode}
\newcommand*{\@ordinalMfrench}[2]{%
\iffmtord@abbrv
  \ifnum#1=1 %
    \edef#2{\number#1\relax\noexpand\fmtord{er}}%
  \else
    \edef#2{\number#1\relax\noexpand\fmtord{e}}%
  \fi
\else
  \PackageWarning{fmtcount}{Non abbreviated ordinal finals (`eme) are
    considered incorrect in French.}%
  \ifnum#1=1 %
    \edef#2{\number#1\relax\noexpand\fmtord{er}}%
  \else
    \protected@edef#2{\number#1\relax\noexpand\fmtord{\protect\`eme}}%
  \fi
\fi}
%    \end{macrocode}
% \DescribeMacro{\@ordinalFfrench}
% \changes{3.01}{2014-11-10}{Protect \cs{`}, for solving
% \uref{http://github.com/nlct/fmtcount/issues/15}{Issue \#15}}
% \changes{3.01}{2014-11-20}{Add a package warning about non
%   abbreviated ordinals in French being incorrect. Change ``i\`eme''
%   to ``\`eme'' which is the most frequent non abbreviated form.}
%    \begin{macrocode}
\newcommand*{\@ordinalFfrench}[2]{%
\iffmtord@abbrv
  \ifnum#1=1 %
     \edef#2{\number#1\relax\noexpand\fmtord{re}}%
  \else
     \edef#2{\number#1\relax\noexpand\fmtord{e}}%
  \fi
\else
  \PackageWarning{fmtcount}{Non abbreviated ordinal finals (`eme) are
    considered incorrect in French.}%
  \ifnum#1=1 %
     \protected@edef#2{\number#1\relax\noexpand\fmtord{\protect\`ere}}%
  \else
     \protected@edef#2{\number#1\relax\noexpand\fmtord{\protect\`eme}}%
  \fi
\fi}
%    \end{macrocode}
% In French neutral gender and masculine gender are formally identical.
%    \begin{macrocode}
\let\@ordinalNfrench\@ordinalMfrench
%    \end{macrocode}
% \DescribeMacro{\@@unitstringfrench}
%    \begin{macrocode}
\newcommand*{\@@unitstringfrench}[1]{%
\noexpand\fc@case
\ifcase#1 %
z\'ero%
\or un%
\or deux%
\or trois%
\or quatre%
\or cinq%
\or six%
\or sept%
\or huit%
\or neuf%
\fi
\noexpand\@nil
}
%    \end{macrocode}
% \DescribeMacro{\@@tenstringfrench}
%    \begin{macrocode}
\newcommand*{\@@tenstringfrench}[1]{%
\noexpand\fc@case
\ifcase#1 %
\or dix%
\or vingt%
\or trente%
\or quarante%
\or cinquante%
\or soixante%
\or septante%
\or huitante%
\or nonante%
\or cent%
\fi
\noexpand\@nil
}
%    \end{macrocode}
% \DescribeMacro{\@@teenstringfrench}
%    \begin{macrocode}
\newcommand*{\@@teenstringfrench}[1]{%
\noexpand\fc@case
\ifcase#1 %
    dix%
\or onze%
\or douze%
\or treize%
\or quatorze%
\or quinze%
\or seize%
\or dix\noexpand\@nil-\noexpand\fc@case sept%
\or dix\noexpand\@nil-\noexpand\fc@case huit%
\or dix\noexpand\@nil-\noexpand\fc@case neuf%
\fi
\noexpand\@nil
}
%    \end{macrocode}
% \DescribeMacro{\@@seventiesfrench}
%    \begin{macrocode}
\newcommand*{\@@seventiesfrench}[1]{%
\@tenstring{6}%
\ifnum#1=1 %
\fc@frenchoptions@submillion@dos\@andname\fc@frenchoptions@submillion@dos
\else
-%
\fi
\@teenstring{#1}%
}
%    \end{macrocode}
% \DescribeMacro{\@@eightiesfrench}Macro \cs{@@eightiesfrench} is used to format numbers in the interval
% \([80\intv 89]\). Argument as follows:\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#1&digit \(d_{w}\) such that the number to be formatted is \(80 + d_{w}\)\\
% \end{tabularx}
% Implicit arguments as:\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \cs{count0}&weight \(w\) of the number \(d_{w+1}d_{w}\) to be formatted\\
%   \cs{count1}&same as \cs{\#1}\\
%   \cs{count6}&input, counter giving the least weight of non zero digits in top level formatted number
%   integral part, with rounding down to a multiple of 3,\\
%   \cs{count9}&input, counter giving the power type of the power of ten following the eighties to be
%   formatted; that is `1' for ``mil'' and `2' for ``\meta{$n$}illion\textbar \meta{$n$}illiard''.
% \end{tabularx}
%    \begin{macrocode}
\newcommand*\@@eightiesfrench[1]{%
\fc@case quatre\@nil-\noexpand\fc@case vingt%
\ifnum#1>0 %
  \ifnum\fc@frenchoptions@vingt@plural=0 % vingt plural=always
  s%
  \fi
  \noexpand\@nil
  -\@unitstring{#1}%
\else
  \ifcase\fc@frenchoptions@vingt@plural\space
    s% 0: always
  \or
    % 1: never
  \or
    s% 2: multiple
  \or
    % 3: multiple g-last
    \ifnum\count0=\count6\ifnum\count9=0 s\fi\fi
  \or
    % 4: multiple l-last
    \ifnum\count9=1 %
    \else
      s%
    \fi
  \or
    % 5: multiple lng-last
    \ifnum\count9=1 %
    \else
      \ifnum\count0>0 %
        s%
      \fi
    \fi
  \or
    % or 6: multiple ng-last
    \ifnum\count0>0 %
      s%
    \fi
  \fi
  \noexpand\@nil
\fi
}
\newcommand*{\@@ninetiesfrench}[1]{%
\fc@case quatre\@nil-\noexpand\fc@case vingt%
\ifnum\fc@frenchoptions@vingt@plural=0 % vingt plural=always
  s%
\fi
\noexpand\@nil
-\@teenstring{#1}%
}
\newcommand*{\@@seventiesfrenchswiss}[1]{%
\@tenstring{7}%
\ifnum#1=1\ \@andname\ \fi
\ifnum#1>1-\fi
\ifnum#1>0 \@unitstring{#1}\fi
}
\newcommand*{\@@eightiesfrenchswiss}[1]{%
\@tenstring{8}%
\ifnum#1=1\ \@andname\ \fi
\ifnum#1>1-\fi
\ifnum#1>0 \@unitstring{#1}\fi
}
\newcommand*{\@@ninetiesfrenchswiss}[1]{%
\@tenstring{9}%
\ifnum#1=1\ \@andname\ \fi
\ifnum#1>1-\fi
\ifnum#1>0 \@unitstring{#1}\fi
}
%    \end{macrocode}
% \DescribeMacro{\fc@french@common}Macro \cs{fc@french@common} does all the preliminary settings common to all
% French dialects \& formatting options.
%    \begin{macrocode}
\newcommand*\fc@french@common{%
  \let\@unitstring=\@@unitstringfrench
  \let\@teenstring=\@@teenstringfrench
  \let\@tenstring=\@@tenstringfrench
  \def\@hundred{cent}%
  \def\@andname{et}%
}
%    \end{macrocode}
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMfrenchswiss}[2]{%
\let\fc@case\fc@CaseIden
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\let\fc@nbrstr@preamble\@empty
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@numberstringMfrenchfrance}[2]{%
\let\fc@case\fc@CaseIden
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\@empty
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@numberstringMfrenchbelgian}[2]{%
\let\fc@case\fc@CaseIden
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\@empty
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\let\@numberstringMfrench=\@numberstringMfrenchfrance
\DeclareRobustCommand{\@numberstringFfrenchswiss}[2]{%
\let\fc@case\fc@CaseIden
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\let\fc@nbrstr@preamble\fc@@nbrstr@Fpreamble
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@numberstringFfrenchfrance}[2]{%
\let\fc@case\fc@CaseIden
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\fc@@nbrstr@Fpreamble
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@numberstringFfrenchbelgian}[2]{%
\let\fc@case\fc@CaseIden
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\fc@@nbrstr@Fpreamble
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\let\@numberstringFfrench=\@numberstringFfrenchfrance
\let\@ordinalstringNfrench\@ordinalstringMfrench
\DeclareRobustCommand{\@NumberstringMfrenchswiss}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\let\fc@nbrstr@preamble\@empty
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@NumberstringMfrenchfrance}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\@empty
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@NumberstringMfrenchbelgian}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\@empty
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\let\@NumberstringMfrench=\@NumberstringMfrenchfrance
\DeclareRobustCommand{\@NumberstringFfrenchswiss}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\let\fc@nbrstr@preamble\fc@@nbrstr@Fpreamble
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@NumberstringFfrenchfrance}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\fc@@nbrstr@Fpreamble
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\DeclareRobustCommand{\@NumberstringFfrenchbelgian}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\let\fc@nbrstr@preamble\fc@@nbrstr@Fpreamble
\let\fc@nbrstr@postamble\@empty
\@@numberstringfrench{#1}{#2}}
\let\@NumberstringFfrench=\@NumberstringFfrenchfrance
\let\@NumberstringNfrench\@NumberstringMfrench
\DeclareRobustCommand{\@ordinalstringMfrenchswiss}[2]{%
\let\fc@case\fc@CaseIden
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\@@ordinalstringfrench{#1}{#2}%
}
\newcommand*\fc@@firstfrench{premier}
%    \end{macrocode}
% \changes{3.01}{2014-11-10}{Protect \cs{`}, for solving
% \uref{http://github.com/nlct/fmtcount/issues/15}{Issue \#15}}
%    \begin{macrocode}
\newcommand*\fc@@firstFfrench{premi\protect\`ere}
\DeclareRobustCommand{\@ordinalstringMfrenchfrance}[2]{%
\let\fc@case\fc@CaseIden
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}}
\DeclareRobustCommand{\@ordinalstringMfrenchbelgian}[2]{%
\let\fc@case\fc@CaseIden
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\let\@ordinalstringMfrench=\@ordinalstringMfrenchfrance
\DeclareRobustCommand{\@ordinalstringFfrenchswiss}[2]{%
\let\fc@case\fc@CaseIden
\let\fc@first=\fc@@firstFfrench
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\@@ordinalstringfrench{#1}{#2}%
}
\DeclareRobustCommand{\@ordinalstringFfrenchfrance}[2]{%
\let\fc@case\fc@CaseIden
\let\fc@first=\fc@@firstFfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\DeclareRobustCommand{\@ordinalstringFfrenchbelgian}[2]{%
\let\fc@case\fc@CaseIden
\let\fc@first=\fc@@firstFfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\let\@ordinalstringFfrench=\@ordinalstringFfrenchfrance
\let\@ordinalstringNfrench\@ordinalstringMfrench
\DeclareRobustCommand{\@OrdinalstringMfrenchswiss}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\@@ordinalstringfrench{#1}{#2}%
}
\DeclareRobustCommand{\@OrdinalstringMfrenchfrance}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\DeclareRobustCommand{\@OrdinalstringMfrenchbelgian}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\let\@OrdinalstringMfrench=\@OrdinalstringMfrenchfrance
\DeclareRobustCommand{\@OrdinalstringFfrenchswiss}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\let\fc@first=\fc@@firstfrench
\fc@french@common
\let\@seventies=\@@seventiesfrenchswiss
\let\@eighties=\@@eightiesfrenchswiss
\let\@nineties=\@@ninetiesfrenchswiss
\@@ordinalstringfrench{#1}{#2}%
}
\DeclareRobustCommand{\@OrdinalstringFfrenchfrance}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\let\fc@first=\fc@@firstFfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\DeclareRobustCommand{\@OrdinalstringFfrenchbelgian}[2]{%
\let\fc@case\fc@UpperCaseFirstLetter
\let\fc@first=\fc@@firstFfrench
\fc@french@common
\let\@seventies=\@@seventiesfrench
\let\@eighties=\@@eightiesfrench
\let\@nineties=\@@ninetiesfrench
\@@ordinalstringfrench{#1}{#2}%
}
\let\@OrdinalstringFfrench=\@OrdinalstringFfrenchfrance
\let\@OrdinalstringNfrench\@OrdinalstringMfrench
%    \end{macrocode}
% \DescribeMacro{\fc@@do@plural@mark}Macro \cs{fc@@do@plural@mark} will expand to the plural mark of
% \meta{$n$}illiard, \meta{$n$}illion, mil, cent or vingt, whichever is applicable. First check that the macro
% is not yet defined.
%    \begin{macrocode}
\ifcsundef{fc@@do@plural@mark}{}%
{\PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@@do@plural@mark'}}
%    \end{macrocode}
% Arguments as follows:\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#1&plural mark, `s' in general, but for mil it is \cs{fc@frenchoptions@mil@plural@mark}\\
% \end{tabularx}
% Implicit arguments as follows:\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \cs{count0}&input, counter giving the weight \(w\), this is expected to be multiple of 3,\\
%   \cs{count1}&input, counter giving the plural value of multiplied object \meta{$n$}illiard,
%   \meta{$n$}illion, mil, cent or vingt, whichever is applicable, that is to say it is 1 when the considered
%   objet is not multiplied, and 2 or more when it is multiplied,\\
%   \cs{count6}&input, counter giving the least weight of non zero digits in top level formatted number
%   integral part, with rounding down to a multiple of 3,\\
%   \cs{count10}&input, counter giving the plural mark control option.\\
% \end{tabularx}
%    \begin{macrocode}
\def\fc@@do@plural@mark#1{%
  \ifcase\count10 %
    #1% 0=always
   \or% 1=never
   \or% 2=multiple
     \ifnum\count1>1 %
       #1%
     \fi
  \or% 3= multiple g-last
     \ifnum\count1>1 %
       \ifnum\count0=\count6 %
         #1%
       \fi
     \fi
  \or% 4= multiple l-last
     \ifnum\count1>1 %
       \ifnum\count9=1 %
       \else
         #1%
       \fi
     \fi
  \or% 5= multiple lng-last
     \ifnum\count1>1 %
       \ifnum\count9=1 %
       \else
         \if\count0>\count6 %
           #1%
         \fi
       \fi
     \fi
  \or% 6= multiple ng-last
     \ifnum\count1>1 %
       \ifnum\count0>\count6 %
         #1%
       \fi
     \fi
  \fi
}
%    \end{macrocode}
% \DescribeMacro{\fc@@nbrstr@Fpreamble}Macro \cs{fc@@nbrstr@Fpreamble} do the necessary preliminaries before
% formatting a cardinal with feminine gender.
%    \begin{macrocode}
\ifcsundef{fc@@nbrstr@Fpreamble}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@@nbrstr@Fpreamble'}}
%    \end{macrocode}
% \DescribeMacro{\fc@@nbrstr@Fpreamble}
%    \begin{macrocode}
\def\fc@@nbrstr@Fpreamble{%
  \fc@read@unit{\count1}{0}%
  \ifnum\count1=1 %
      \let\fc@case@save\fc@case
      \def\fc@case{\noexpand\fc@case}%
      \def\@nil{\noexpand\@nil}%
     \let\fc@nbrstr@postamble\fc@@nbrstr@Fpostamble
  \fi
}
%    \end{macrocode}
% \DescribeMacro{\fc@@nbrstr@Fpostamble}
%    \begin{macrocode}
\def\fc@@nbrstr@Fpostamble{%
  \let\fc@case\fc@case@save
  \expandafter\fc@get@last@word\expandafter{\@tempa}\@tempb\@tempc
  \def\@tempd{un}%
  \ifx\@tempc\@tempd
    \let\@tempc\@tempa
    \edef\@tempa{\@tempb\fc@case une\@nil}%
  \fi
}
%    \end{macrocode}
% \DescribeMacro{\fc@@pot@longscalefrench}Macro \cs{fc@@pot@longscalefrench} is used to produce
% powers of ten with long scale convention. The long scale convention is correct for French and elsewhere in
% Europe. First we check that the macro is not yet defined.
%    \begin{macrocode}
\ifcsundef{fc@@pot@longscalefrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@@pot@longscalefrench'}}
%    \end{macrocode}
% Argument are as follows:\def\interface{\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#1&input, plural value of \(d\), that is to say: let \(d\) be the number multiplying the considered power
%   of ten, then the plural value \texttt{\#2} is expected to be \(0\) if \(d=0\), \(1\) if \(d=1\), or \(>1\)
%   if \(d>1\)\\
%   \#2&output, counter, maybe \(0\) when power of ten is \(1\), \(1\) when power of ten starts with
%   ``mil(le)'', or \(2\) when power of ten is a ``\meta{$n$}illion(s)\textbar\meta{$n$}illiard(s)''\\
%   \#3&output, macro into which to place the formatted power of ten
% \end{tabularx}
% Implicit arguments as follows:\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \cs{count0}&input, counter giving the weight \(w\), this is expected to be multiple of 3\\
% \end{tabularx}
% }\interface
%    \begin{macrocode}
\def\fc@@pot@longscalefrench#1#2#3{%
  {%
%    \end{macrocode}
% First the input arguments are saved into local objects: \texttt{\#1} and \texttt{\#1} are respectively saved
% into \cs{@tempa} and \cs{@tempb}.
%    \begin{macrocode}
    \edef\@tempb{\number#1}%
%    \end{macrocode}
% Let \cs{count1} be the plural value.
%    \begin{macrocode}
    \count1=\@tempb
%    \end{macrocode}
% Let \(n\) and \(r\) the the quotient and remainder of division of weight \(w\) by \(6\), that is to say \(w
% = n\times 6 + r\) and \(0\leq r < 6\), then \cs{count2} is set to \(n\) and \cs{count3} is set to \(r\).
%    \begin{macrocode}
    \count2\count0 %
    \divide\count2 by 6 %
    \count3\count2 %
    \multiply\count3 by 6 %
    \count3-\count3 %
    \advance\count3 by \count0 %
    \ifnum\count0>0 %
%    \end{macrocode}
% If weight \(w\) (a.k.a. \cs{count0}) is such that \(w>0\), then \(w\geq 3\) because \(w\) is a multiple of
% \(3\). So we \emph{may} have to append ``mil(le)'' or ``\meta{$n$}illion(s)'' or ``\meta{$n$}illiard(s)''.
%    \begin{macrocode}
      \ifnum\count1>0 %
%    \end{macrocode}
% Plural value is \(>0\) so have at least one ``mil(le)'' or ``\meta{$n$}illion(s)'' or
% ``\meta{$n$}illiard(s)''. We need to distinguish between the case of ``mil(le)'' and that of
% ``\meta{$n$}illion(s)'' or ``\meta{$n$}illiard(s)'', so we \cs{def}ine \cs{@temph} to `\texttt{1}' for
% ``mil(le)'', and to `\texttt{2}' otherwise.
%    \begin{macrocode}
        \edef\@temph{%
          \ifnum\count2=0 % weight=3
%    \end{macrocode}
% Here \(n=0\), with \(n=w\div 6\),but we also know that \(w\geq 3\), so we have \(w=3\) which means we are in
% the ``mil(le)'' case.
%    \begin{macrocode}
            1%
          \else
            \ifnum\count3>2 %
%    \end{macrocode}
% Here we are in the case of \(3\leq r < 6\), with \(r\) the remainder of division of weight \(w\) by \(6\),
% we should have ``\meta{$n$}illiard(s)'', but that may also be ``mil(le)'' instead depending on
% option `\texttt{n-illiard upto}', known as \cs{fc@longscale@nilliard@upto}.
%    \begin{macrocode}
              \ifnum\fc@longscale@nilliard@upto=0 %
%    \end{macrocode}
% Here option `\texttt{n-illiard upto}' is `\texttt{infinity}', so we always use ``\meta{$n$}illiard(s)''.
%    \begin{macrocode}
                2%
              \else
%    \end{macrocode}
% Here option `\texttt{n-illiard upto}' indicate some threshold to which to compare \(n\)
% (a.k.a. \cs{count2}).
%    \begin{macrocode}
                \ifnum\count2>\fc@longscale@nilliard@upto
                  1%
                \else
                  2%
                \fi
              \fi
            \else
              2%
            \fi
          \fi
        }%
        \ifnum\@temph=1 %
%    \end{macrocode}
% Here \(10^w\) is formatted as ``mil(le)''.
%    \begin{macrocode}
          \count10=\fc@frenchoptions@mil@plural\space
          \edef\@tempe{%
            \noexpand\fc@case
             mil%
             \fc@@do@plural@mark\fc@frenchoptions@mil@plural@mark
            \noexpand\@nil
          }%
        \else
          % weight >= 6
          \expandafter\fc@@latin@cardinal@pefix\expandafter{\the\count2}\@tempg
          % now form the xxx-illion(s) or xxx-illiard(s) word
          \ifnum\count3>2 %
             \toks10{illiard}%
             \count10=\csname fc@frenchoptions@n-illiard@plural\endcsname\space
          \else
             \toks10{illion}%
             \count10=\csname fc@frenchoptions@n-illion@plural\endcsname\space
          \fi
          \edef\@tempe{%
            \noexpand\fc@case
            \@tempg
            \the\toks10 %
            \fc@@do@plural@mark s%
            \noexpand\@nil
          }%
        \fi
      \else
%    \end{macrocode}
% Here plural indicator of \(d\) indicates that \(d = 0\), so we have \(0\times10^{w}\), and it is not worth
% to format \(10^{w}\), because there are none of them.
%    \begin{macrocode}
         \let\@tempe\@empty
         \def\@temph{0}%
      \fi
    \else
%    \end{macrocode}
% Case of \(w=0\).
%    \begin{macrocode}
      \let\@tempe\@empty
      \def\@temph{0}%
    \fi
%    \end{macrocode}
% Now place into \@cs{@tempa} the assignment of results \cs{@temph} and \cs{@tempe} to \texttt{\#2} and
% \texttt{\#3} for further propagation after closing brace.
%    \begin{macrocode}
    \expandafter\toks\expandafter1\expandafter{\@tempe}%
    \toks0{#2}%
    \edef\@tempa{\the\toks0 \@temph \def\noexpand#3{\the\toks1}}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro{\fc@@pot@shortscalefrench}Macro \cs{fc@@pot@shortscalefrench} is used to produce
% powers of ten with short scale convention. This convention is the US convention and is not correct for
% French and elsewhere in Europe. First we check that the macro is not yet defined.
%    \begin{macrocode}
\ifcsundef{fc@@pot@shortscalefrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@@pot@shortscalefrench'}}
%    \end{macrocode}
% Arguments as follows --- same interface as for \cs{fc@@pot@longscalefrench}:\interface
%    \begin{macrocode}
\def\fc@@pot@shortscalefrench#1#2#3{%
  {%
%    \end{macrocode}
% First save input arguments \texttt{\#1}, \texttt{\#2}, and \texttt{\#3} into local macros
% respectively \cs{@tempa}, \cs{@tempb}, \cs{@tempc} and \cs{@tempd}.
%    \begin{macrocode}
    \edef\@tempb{\number#1}%
%    \end{macrocode}
% And let \cs{count1} be the plural value.
%    \begin{macrocode}
    \count1=\@tempb
%    \end{macrocode}
% Now, let \cs{count2} be the integer \(n\) generating the pseudo latin prefix, i.e. \(n\) is such that \(w =
% 3\times n + 3\).
%    \begin{macrocode}
    \count2\count0 %
    \divide\count2 by 3 %
    \advance\count2 by -1 %
%    \end{macrocode}
% Here is the real job, the formatted power of ten will go to \cs{@tempe}, and its power type will go to
% \cs{@temph}. Please remember that the power type is an index in \([0\intv 2]\) indicating whether \(10^w\)
% is formatted as \meta{nothing}, ``mil(le)'' or ``\meta{$n$}illion(s)\textbar\meta{$n$}illiard(s)''.
%    \begin{macrocode}
    \ifnum\count0>0 % If weight>=3, i.e we do have to append thousand or n-illion(s)/n-illiard(s)
      \ifnum\count1>0 % we have at least one thousand/n-illion/n-illiard
         \ifnum\count2=0 %
           \def\@temph{1}%
           \count1=\fc@frenchoptions@mil@plural\space
           \edef\@tempe{%
             mil%
             \fc@@do@plural@mark\fc@frenchoptions@mil@plural@mark
           }%
         \else
           \def\@temph{2}%
           % weight >= 6
           \expandafter\fc@@latin@cardinal@pefix\expandafter{\the\count2}\@tempg
           \count10=\csname fc@frenchoptions@n-illion@plural\endcsname\space
           \edef\@tempe{%
             \noexpand\fc@case
             \@tempg
             illion%
             \fc@@do@plural@mark s%
             \noexpand\@nil
           }%
         \fi
      \else
%    \end{macrocode}
% Here we have \(d=0\), so nothing is to be formatted for \(d\times 10^w\).
%    \begin{macrocode}
        \def\@temph{0}%
        \let\@tempe\@empty
      \fi
    \else
%    \end{macrocode}
% Here \(w=0\).
%    \begin{macrocode}
      \def\@temph{0}%
      \let\@tempe\@empty
    \fi
% now place into \@cs{@tempa} the assignment of results \cs{@temph} and \cs{@tempe} to to \texttt{\#2} and
% \texttt{\#3} for further propagation after closing brace.
%    \begin{macrocode}
    \expandafter\toks\expandafter1\expandafter{\@tempe}%
    \toks0{#2}%
    \edef\@tempa{\the\toks0 \@temph \def\noexpand#3{\the\toks1}}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro{\fc@@pot@recursivefrench}Macro \cs{fc@@pot@recursivefrench} is used to produce
% power of tens that are of the form ``million de milliards de milliards'' for \(10^{24}\). First we check
% that the macro is not yet defined.
%    \begin{macrocode}
\ifcsundef{fc@@pot@recursivefrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@@pot@recursivefrench'}}
%    \end{macrocode}
% The arguments are as follows --- same interface as for \cs{fc@@pot@longscalefrench}:\interface
%    \begin{macrocode}
\def\fc@@pot@recursivefrench#1#2#3{%
  {%
%    \end{macrocode}
% First the input arguments are saved into local objects: \texttt{\#1} and \texttt{\#1} are respectively saved
% into \cs{@tempa} and \cs{@tempb}.
%    \begin{macrocode}
    \edef\@tempb{\number#1}%
    \let\@tempa\@@tempa
%    \end{macrocode}
% New get the inputs \texttt{\#1} and \texttt{\#1} into counters \cs{count0} and \cs{count1} as this is more
% practical.
%    \begin{macrocode}
    \count1=\@tempb\space
%    \end{macrocode}
% Now compute into \cs{count2} how many times ``de milliards'' has to be repeated.
%    \begin{macrocode}
    \ifnum\count1>0 %
      \count2\count0 %
      \divide\count2 by 9 %
      \advance\count2 by -1 %
      \let\@tempe\@empty
      \edef\@tempf{\fc@frenchoptions@supermillion@dos
        de\fc@frenchoptions@supermillion@dos\fc@case milliards\@nil}%
      \count11\count0 %
      \ifnum\count2>0 %
        \count3\count2 %
        \count3-\count3 %
        \multiply\count3 by 9 %
        \advance\count11 by \count3 %
        \loop
           % (\count2, \count3) <- (\count2 div 2, \count2 mod 2)
           \count3\count2 %
           \divide\count3 by 2 %
           \multiply\count3 by 2 %
           \count3-\count3 %
           \advance\count3 by \count2 %
           \divide\count2 by 2 %
           \ifnum\count3=1 %
             \let\@tempg\@tempe
             \edef\@tempe{\@tempg\@tempf}%
           \fi
           \let\@tempg\@tempf
           \edef\@tempf{\@tempg\@tempg}%
           \ifnum\count2>0 %
        \repeat
      \fi
      \divide\count11 by 3 %
      \ifcase\count11 % 0 .. 5
        % 0 => d milliard(s) (de milliards)*
        \def\@temph{2}%
        \count10=\csname fc@frenchoptions@n-illiard@plural\endcsname\space
      \or  % 1 => d mille milliard(s) (de milliards)*
        \def\@temph{1}%
        \count10=\fc@frenchoptions@mil@plural\space
      \or % 2 => d million(s) (de milliards)*
        \def\@temph{2}%
        \count10=\csname fc@frenchoptions@n-illion@plural\endcsname\space
      \or % 3 => d milliard(s) (de milliards)*
        \def\@temph{2}%
        \count10=\csname fc@frenchoptions@n-illiard@plural\endcsname\space
      \or % 4 => d mille milliards (de milliards)*
        \def\@temph{1}%
        \count10=\fc@frenchoptions@mil@plural\space
      \else % 5 => d million(s) (de milliards)*
        \def\@temph{2}%
        \count10=\csname fc@frenchoptions@n-illion@plural\endcsname\space
      \fi
      \let\@tempg\@tempe
      \edef\@tempf{%
        \ifcase\count11 % 0 .. 5
        \or
          mil\fc@@do@plural@mark \fc@frenchoptions@mil@plural@mark
        \or
          million\fc@@do@plural@mark s%
        \or
          milliard\fc@@do@plural@mark s%
        \or
          mil\fc@@do@plural@mark\fc@frenchoptions@mil@plural@mark
          \noexpand\@nil\fc@frenchoptions@supermillion@dos
          \noexpand\fc@case milliards% 4
        \or
          million\fc@@do@plural@mark s%
          \noexpand\@nil\fc@frenchoptions@supermillion@dos
          de\fc@frenchoptions@supermillion@dos\noexpand\fc@case  milliards% 5
        \fi
      }%
      \edef\@tempe{%
        \ifx\@tempf\@empty\else
         \expandafter\fc@case\@tempf\@nil
        \fi
        \@tempg
      }%
    \else
       \def\@temph{0}%
       \let\@tempe\@empty
    \fi
%    \end{macrocode}
% now place into \@cs{@tempa} the assignment of results \cs{@temph} and \cs{@tempe} to to \texttt{\#2} and
% \texttt{\#3} for further propagation after closing brace.
%    \begin{macrocode}
    \expandafter\toks\expandafter1\expandafter{\@tempe}%
    \toks0{#2}%
    \edef\@tempa{\the\toks0 \@temph \def\noexpand#3{\the\toks1}}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro{\fc@muladdfrench}Macro \cs{fc@muladdfrench} is used to format the sum of a number \(a\) and
% the product of a number \(d\) by a power of ten \(10^w\). Number \(d\) is made of three consecutive digits
% \(d_{w+2}d_{w+1}d_w\) of respective weights \(w+2\), \(w+1\), and \(w\), while number \(a\) is made of all
% digits with weight \(w' > w+2\) that have already been formatted. First check that the macro is not yet
% defined.
%    \begin{macrocode}
\ifcsundef{fc@muladdfrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@muladdfrench'}}
%    \end{macrocode}
% Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#2&input, plural indicator for number \(d\)\\
%   \#3&input, formatted number \(d\)\\
%   \#5&input, formatted number \(10^w\), i.e. power of ten which is multiplied by \(d\)\\
% \end{tabularx}
% Implicit arguments from context:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \cs{@tempa}&input, formatted number \(a\)\\
%              &output, macro to which place the mul-add result\\
%   \cs{count8}&input, power type indicator for \(10^{w'}\), where \(w'\) is a weight of \(a\), this is an
%   index in \([0\intv 2]\) that reflects whether \(10^{w'}\) is formatted by ``mil(le)'' --- for index \(=1\)
%   --- or by ``\meta{$n$}illion(s)\textbar\meta{$n$}illiard(s)'' --- for index \(=2\)\\
%   \cs{count9}&input, power type indicator for \(10^w\), this is an index in \([0\intv 2]\) that reflect
%   whether the weight \(w\) of \(d\) is formatted by ``meta{nothing}'' --- for index \(=0\), ``mil(le)'' ---
%   for index
%   \(=1\) --- or by ``\meta{$n$}illion(s)\textbar \meta{$n$}illiard(s)'' --- for index \(=2\)\\
% \end{tabularx}
%    \begin{macrocode}
\def\fc@muladdfrench#1#2#3{%
  {%
%    \end{macrocode}
% First we save input arguments \texttt{\#1} -- \texttt{\#3} to local macros \cs{@tempc}, \cs{@tempd} and
% \cs{@tempf}.
%    \begin{macrocode}
    \edef\@@tempc{#1}%
    \edef\@@tempd{#2}%
    \edef\@tempf{#3}%
    \let\@tempc\@@tempc
    \let\@tempd\@@tempd
%    \end{macrocode}
% First we want to do the ``multiplication'' of \(d \Rightarrow \cs{@tempd}\) and of \(10^w \Rightarrow
% \cs{@tempf}\). So, prior to this we do some preprocessing of \(d \Rightarrow \cs{@tempd}\): we force
% \cs{@tempd} to \meta{empty} if both \(d=1\) and \(10^w\Rightarrow\) ``mil(le)'', this is because we,
% French, we do not say ``un mil'', but just ``mil''.
%    \begin{macrocode}
    \ifnum\@tempc=1 %
      \ifnum\count9=1 %
        \let\@tempd\@empty
      \fi
    \fi
%    \end{macrocode}
% Now we do the ``multiplication'' of \(d = \cs{@tempd}\) and of \(10^w = \cs{@tempf}\), and place the result
% into \cs{@tempg}.
%    \begin{macrocode}
    \edef\@tempg{%
      \@tempd
      \ifx\@tempd\@empty\else
        \ifx\@tempf\@empty\else
           \ifcase\count9 %
           \or
             \fc@frenchoptions@submillion@dos
           \or
              \fc@frenchoptions@supermillion@dos
           \fi
         \fi
       \fi
     \@tempf
   }%
%    \end{macrocode}
% Now to the ``addition'' of \(a\Rightarrow \cs{@tempa}\) and \(d\times 10^w\Rightarrow \cs{@tempg}\), and
% place the results into \cs{@temph}.
%    \begin{macrocode}
   \edef\@temph{%
     \@tempa
     \ifx\@tempa\@empty\else
       \ifx\@tempg\@empty\else
         \ifcase\count8 %
         \or
           \fc@frenchoptions@submillion@dos
         \or
           \fc@frenchoptions@supermillion@dos
         \fi
       \fi
     \fi
     \@tempg
   }%
%    \end{macrocode}
% Now propagate the result --- i.e. the expansion of \cs{@temph} --- into macro \cs{@tempa} after closing
% brace.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def\@tempa{##1}}}%
    \expandafter\@tempb\expandafter{\@temph}%
    \expandafter
  }\@tempa
}%
%    \end{macrocode}
% \DescribeMacro{\fc@lthundredstringfrench}Macro \cs{fc@lthundredstringfrench} is used to format a number in
% interval \([0 \intv 99]\). First we check that it is not already defined.
%    \begin{macrocode}
\ifcsundef{fc@lthundredstringfrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@lthundredstringfrench'}}
%    \end{macrocode}
% The number to format is not passed as an argument to this macro, instead each digits of it is in a
% \cs{fc@digit@\meta{w}} macro after this number has been parsed. So the only thing that
% \cs{fc@lthundredstringfrench} needs is to know \meta{w} which is passed as \cs{count0} for the less
% significant digit.\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&intput/output macro to which append the result
% \end{tabularx}
% Implicit input arguments as follows:\newline
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \cs{count0}&weight \(w\) of least significant digit \(d_{w}\).
% \end{tabularx}
% The formatted number is appended to the content of \#1, and the result is placed into \#1.
%    \begin{macrocode}
\def\fc@lthundredstringfrench#1{%
  {%
%    \end{macrocode}
% First save arguments into local temporary macro.
%    \begin{macrocode}
    \let\@tempc#1%
%    \end{macrocode}
% Read units \(d_w\) to \cs{count1}.
%    \begin{macrocode}
    \fc@read@unit{\count1}{\count0}%
%    \end{macrocode}
% Read tens \(d_{w+1}\) to \cs{count2}.
%    \begin{macrocode}
    \count3\count0 %
    \advance\count3 1 %
    \fc@read@unit{\count2}{\count3}%
%    \end{macrocode}
% Now do the real job, set macro \cs{@tempa} to \texttt{\#1} followed by \(d_{w+1}d_w\) formatted.
%    \begin{macrocode}
    \edef\@tempa{%
      \@tempc
      \ifnum\count2>1 %
        % 20 .. 99
        \ifnum\count2>6 %
          % 70 .. 99
          \ifnum\count2<8 %
             % 70 .. 79
             \@seventies{\count1}%
          \else
            % 80..99
            \ifnum\count2<9 %
              % 80 .. 89
              \@eighties{\count1}%
            \else
              % 90 .. 99
              \@nineties{\count1}%
            \fi
          \fi
        \else
          % 20..69
          \@tenstring{\count2}%
          \ifnum\count1>0 %
             % x1 .. x0
             \ifnum\count1=1 %
               % x1
               \fc@frenchoptions@submillion@dos\@andname\fc@frenchoptions@submillion@dos
             \else
               % x2 .. x9
               -%
             \fi
             \@unitstring{\count1}%
          \fi
        \fi
      \else
        % 0 .. 19
        \ifnum\count2=0 % when tens = 0
          % 0 .. 9
          \ifnum\count1=0 % when units = 0
            % \count3=1 when #1 = 0, i.e. only for the unit of the top level number
            \ifnum\count3=1 %
              \ifnum\fc@max@weight=0 %
                \@unitstring{0}%
              \fi
            \fi
          \else
            % 1 .. 9
            \@unitstring{\count1}%
          \fi
        \else
          % 10 .. 19
          \@teenstring{\count1}%
        \fi
      \fi
    }%
%    \end{macrocode}
% Now propagate the expansion of \cs{@tempa} into \texttt{\#1} after closing brace.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def#1{##1}}}%
    \expandafter\@tempb\expandafter{\@tempa}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro{\fc@ltthousandstringfrench}Macro \cs{fc@ltthousandstringfrench} is used to format a number in
% interval \([0 \intv 999]\). First we check that it is not already defined.
%    \begin{macrocode}
\ifcsundef{fc@ltthousandstringfrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `fc@ltthousandstringfrench'}}
%    \end{macrocode}
% Output is empty for 0. Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#2&output, macro, formatted number \(d = d_{w+2}d_{w+1}d_w\)
% \end{tabularx}
% Implicit input arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \cs{count0}&input weight \(10^{w}\) of number \(d_{w+2}d_{w+1}d_w\) to be formatted.\\
%   \cs{count5}&least weight of formatted number with a non null digit.\\
%   \cs{count9}&input, power type indicator of \(10^{w}\) \(0\Rightarrow\varnothing\), \(1\Rightarrow\textrm {
%   ``mil(le)''}\), \(2\Rightarrow\textrm {\meta{$n$}illion(s)\textbar\meta{$n$}illiard(s)}\)\\
% \end{tabularx}
%    \begin{macrocode}
\def\fc@ltthousandstringfrench#1{%
  {%
%    \end{macrocode}
%  Set counter \cs{count2} to digit \(d_{w+2}\), i.e. hundreds.
%    \begin{macrocode}
    \count4\count0 %
    \advance\count4 by 2 %
    \fc@read@unit{\count2 }{\count4 }%
%    \end{macrocode}
% Check that the two subsequent digits \(d_{w+1}d_w\) are non zero, place check-result into \cs{@tempa}.
%    \begin{macrocode}
    \advance\count4 by -1 %
    \count3\count4 %
    \advance\count3 by -1 %
    \fc@check@nonzeros{\count3 }{\count4 }\@tempa
%    \end{macrocode}
% Compute plural mark of `cent' into \cs{@temps}.
%    \begin{macrocode}
    \edef\@temps{%
      \ifcase\fc@frenchoptions@cent@plural\space
      % 0 => always
      s%
      \or
      % 1 => never
      \or
      % 2 => multiple
      \ifnum\count2>1s\fi
      \or
      % 3 => multiple g-last
        \ifnum\count2>1 \ifnum\@tempa=0 \ifnum\count0=\count6s\fi\fi\fi
      \or
      % 4 => multiple l-last
        \ifnum\count2>1 \ifnum\@tempa=0 \ifnum\count9=0s\else\ifnum\count9=2s\fi\fi\fi\fi
      \fi
    }%
    % compute spacing after cent(s?) into \@tempb
    \expandafter\let\expandafter\@tempb
       \ifnum\@tempa>0 \fc@frenchoptions@submillion@dos\else\@empty\fi
    % now place into \@tempa the hundreds
    \edef\@tempa{%
       \ifnum\count2=0 %
       \else
         \ifnum\count2=1 %
           \expandafter\fc@case\@hundred\@nil
         \else
           \@unitstring{\count2}\fc@frenchoptions@submillion@dos
           \noexpand\fc@case\@hundred\@temps\noexpand\@nil
         \fi
         \@tempb
       \fi
    }%
    % now append to \@tempa the ten and unit
    \fc@lthundredstringfrench\@tempa
%    \end{macrocode}
% Propagate expansion of \cs{@tempa} into macro \texttt{\#1} after closing brace.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def#1{##1}}}%
    \expandafter\@tempb\expandafter{\@tempa}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro{\@@numberstringfrench}Macro \cs{@@numberstringfrench} is the main engine for formatting
% cadinal numbers in French. First we check that the control sequence is not yet defined.
%    \begin{macrocode}
\ifcsundef{@@numberstringfrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro `@@numberstringfrench'}}
%    \end{macrocode}
% Arguments are as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&number to convert to string\\
% \#2&macro into which to place the result
% \end{tabularx}
%    \begin{macrocode}
\def\@@numberstringfrench#1#2{%
  {%
%    \end{macrocode}
% First parse input number to be formatted and do some error handling.
%    \begin{macrocode}
    \edef\@tempa{#1}%
    \expandafter\fc@number@parser\expandafter{\@tempa}%
    \ifnum\fc@min@weight<0 %
       \PackageError{fmtcount}{Out of range}%
          {This macro does not work with fractional numbers}%
    \fi
%    \end{macrocode}
% In the sequel, \cs{@tempa} is used to accumulate the formatted number.  Please note that \cs{space} after
% \cs{fc@sign@case} is eaten by preceding number collection. This \cs{space} is needed so that when
% \cs{fc@sign@case} expands to `\texttt{0}', then \cs{@tempa} is defined to `' (i.e. empty) rather than to
% `\cs{relax}'.
%    \begin{macrocode}
    \edef\@tempa{\ifcase\fc@sign@case\space\or\fc@case plus\@nil\or\fc@case moins\@nil\fi}%
    \fc@nbrstr@preamble
    \fc@@nbrstrfrench@inner
    \fc@nbrstr@postamble
%    \end{macrocode}
% Propagate the result --- i.e. expansion of \cs{@tempa} --- into macro \texttt{\#2} after closing brace.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def#2{##1}}}%
    \expandafter\@tempb\expandafter{\@tempa}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro{\fc@@nbrstrfrench@inner}Common part of \cs{@@numberstringfrench} and \cs
% {@@ordinalstringfrench}. Arguments are as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \cs{@tempa}&input/output, macro to which the result is to be aggregated, initially empty or contains the
% sign indication.\\
% \end{tabularx}
%    \begin{macrocode}
\def\fc@@nbrstrfrench@inner{%
%    \end{macrocode}
% Now loop, first we compute starting weight as
% \(3\times\left\lfloor\frac{\cs{fc@max@weight}}{3}\right\rfloor\) into \cs{count0}.
%    \begin{macrocode}
    \count0=\fc@max@weight
    \divide\count0 by 3 %
    \multiply\count0 by 3 %
%    \end{macrocode}
% Now we compute final weight into \cs{count5}, and round down to multiple of \(3\) into
% \cs{count6}. Warning: \cs{count6} is an implicit input argument to macro \cs{fc@ltthousandstringfrench}.
%    \begin{macrocode}
    \fc@intpart@find@last{\count5 }%
    \count6\count5 %
    \divide\count6 3 %
    \multiply\count6 3 %
    \count8=0 %
    \loop
%    \end{macrocode}
% First we check whether digits in weight interval \([w \intv (w+2)]\) are all zero and place check result
% into macro \cs{@tempt}.
%    \begin{macrocode}
       \count1\count0 %
       \advance\count1 by 2 %
       \fc@check@nonzeros{\count0 }{\count1 }\@tempt
%    \end{macrocode}
% Now we generate the power of ten \(10^w\), formatted power of ten goes to \cs{@tempb}, while power type
% indicator goes to \cs{count9}.
%    \begin{macrocode}
       \fc@poweroften\@tempt{\count9 }\@tempb
%    \end{macrocode}
% Now we generate the formatted number \(d\) into macro \cs{@tempd} by which we need to multiply
% \(10^w\). Implicit input argument is \cs{count9} for power type of \(10^9\), and \cs{count6}
%    \begin{macrocode}
       \fc@ltthousandstringfrench\@tempd
%    \end{macrocode}
% Finally do the multiplication-addition. Implicit arguments are \cs{@tempa} for input/output growing
% formatted number, \cs{count8} for input previous power type, i.e. power type of \(10^{w+3}\), \cs{count9}
% for input current power type, i.e. power type of \(10^w\).
%    \begin{macrocode}
       \fc@muladdfrench\@tempt\@tempd\@tempb
%    \end{macrocode}
% Then iterate.
%    \begin{macrocode}
       \count8\count9 %
       \advance\count0 by -3 %
       \ifnum\count6>\count0 \else
    \repeat
}
%    \end{macrocode}
% \DescribeMacro{\@@ordinalstringfrench}Macro \cs{@@ordinalstringfrench} is the main engine for formatting
% ordinal numbers in French. First check it is not yet defined.
%    \begin{macrocode}
\ifcsundef{@@ordinalstringfrench}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro
    `@@ordinalstringfrench'}}
%    \end{macrocode}
% Arguments are as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&number to convert to string\\
% \#2&macro into which to place the result
% \end{tabularx}
%    \begin{macrocode}
\def\@@ordinalstringfrench#1#2{%
  {%
%    \end{macrocode}
% First parse input number to be formatted and do some error handling.
%    \begin{macrocode}
    \edef\@tempa{#1}%
    \expandafter\fc@number@parser\expandafter{\@tempa}%
    \ifnum\fc@min@weight<0 %
       \PackageError{fmtcount}{Out of range}%
          {This macro does not work with fractional numbers}%
    \fi
    \ifnum\fc@sign@case>0 %
       \PackageError{fmtcount}{Out of range}%
          {This macro does with negative or explicitly marked as positive numbers}%
    \fi
%    \end{macrocode}
% Now handle the special case of first. We set \cs{count0} to \texttt{1} if we are in this case, and to
% \texttt{0} otherwise
%    \begin{macrocode}
    \ifnum\fc@max@weight=0 %
      \ifnum\csname fc@digit@0\endcsname=1 %
        \count0=1 %
      \else
        \count0=0 % 
      \fi
    \else
      \count0=0 % 
    \fi
    \ifnum\count0=1 %
%    \end{macrocode}
% \changes{3.01}{2014-11-10}{Protect \cs{`}, for solving
% \uref{http://github.com/nlct/fmtcount/issues/15}{Issue \#15}}
%    \begin{macrocode}
      \protected@edef\@tempa{\expandafter\fc@case\fc@first\@nil}%
    \else
%    \end{macrocode}
% Now we tamper a little bit with the plural handling options to ensure that there is no final plural mark.
%    \begin{macrocode}
      \def\@tempa##1{%
        \expandafter\edef\csname fc@frenchoptions@##1@plural\endcsname{%
          \ifcase\csname fc@frenchoptions@##1@plural\endcsname\space
          0% 0: always => always
          \or
          1% 1: never => never
          \or
          6% 2: multiple => multiple  ng-last
          \or
          1% 3: multiple g-last => never
          \or
          5% 4: multiple l-last => multiple lng-last
          \or
          5% 5: multiple lng-last => multiple lng-last
          \or
          6% 6: multiple ng-last => multiple ng-last
          \fi
        }%
      }%
      \@tempa{vingt}%
      \@tempa{cent}%
      \@tempa{mil}%
      \@tempa{n-illion}%
      \@tempa{n-illiard}%
%    \end{macrocode}
% Now make \cs{fc@case} and \cs{@nil} non expandable
%    \begin{macrocode}
      \let\fc@case@save\fc@case
      \def\fc@case{\noexpand\fc@case}%
      \def\@nil{\noexpand\@nil}%
%    \end{macrocode}
% In the sequel, \cs{@tempa} is used to accumulate the formatted number.
%    \begin{macrocode}
      \let\@tempa\@empty
      \fc@@nbrstrfrench@inner
%    \end{macrocode}
% Now restore \cs{fc@case}
%    \begin{macrocode}
     \let\fc@case\fc@case@save
%    \end{macrocode}
% Now we add the ``i\`eme'' ending
% \changes{3.01}{2014-11-10}{Protect \cs{`}, for solving
% \uref{http://github.com/nlct/fmtcount/issues/15}{Issue \#15}}
%    \begin{macrocode}
      \expandafter\fc@get@last@word\expandafter{\@tempa}\@tempb\@tempc
      \expandafter\fc@get@last@letter\expandafter{\@tempc}\@tempd\@tempe
      \def\@tempf{e}%
      \ifx\@tempe\@tempf
        \protected@edef\@tempa{\@tempb\expandafter\fc@case\@tempd i\protect\`eme\@nil}%
      \else
        \def\@tempf{q}%
        \ifx\@tempe\@tempf
          \protected@edef\@tempa{\@tempb\expandafter\fc@case\@tempd qui\protect\`eme\@nil}%
        \else
          \def\@tempf{f}%
          \ifx\@tempe\@tempf
            \protected@edef\@tempa{\@tempb\expandafter\fc@case\@tempd vi\protect\`eme\@nil}%
          \else
            \protected@edef\@tempa{\@tempb\expandafter\fc@case\@tempc i\protect\`eme\@nil}%
          \fi
        \fi
      \fi
    \fi
%    \end{macrocode}
% Propagate the result --- i.e. expansion of \cs{@tempa} --- into macro \texttt{\#2} after closing brace.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def#2{##1}}}%
    \expandafter\@tempb\expandafter{\@tempa}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% Macro \cs{fc@frenchoptions@setdefaults} allows to set all options to default for the French.
%    \begin{macrocode}
\newcommand*\fc@frenchoptions@setdefaults{%
  \csname KV@fcfrench@all plural\endcsname{reformed}%
  \def\fc@frenchoptions@submillion@dos{-}%
  \let\fc@frenchoptions@supermillion@dos\space
  \let\fc@u@in@duo\@empty% Could be `u'
  % \let\fc@poweroften\fc@@pot@longscalefrench
  \let\fc@poweroften\fc@@pot@recursivefrench
  \def\fc@longscale@nilliard@upto{0}% infinity
  \def\fc@frenchoptions@mil@plural@mark{le}%
}
\fc@frenchoptions@setdefaults
%    \end{macrocode}
% Make some indirection to call the current French dialect corresponding macro.
% \changes{3.01}{2014-12-18}{Move French specific stuff from \styfmt{fmtcount.sty} to \styfmt{fc-french.def}.}
%    \begin{macrocode}
\def\@ordinalstringMfrench{\csuse{@ordinalstringMfrench\fmtcount@french}}%
\def\@ordinalstringFfrench{\csuse{@ordinalstringFfrench\fmtcount@french}}%
\def\@OrdinalstringMfrench{\csuse{@OrdinalstringMfrench\fmtcount@french}}%
\def\@OrdinalstringFfrench{\csuse{@OrdinalstringFfrench\fmtcount@french}}%
\def\@numberstringMfrench{\csuse{@numberstringMfrench\fmtcount@french}}%
\def\@numberstringFfrench{\csuse{@numberstringFfrench\fmtcount@french}}%
\def\@NumberstringMfrench{\csuse{@NumberstringMfrench\fmtcount@french}}%
\def\@NumberstringFfrench{\csuse{@NumberstringFfrench\fmtcount@french}}%
%    \end{macrocode}
\iffalse Local variables: \fi
\iffalse mode: docTeX     \fi
\iffalse End:             \fi
%\iffalse
%    \begin{macrocode}
%</fc-french.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-frenchb.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-frenchb.def}
%    \begin{macrocode}
\ProvidesFCLanguage{frenchb}[2013/08/17]%
\FCloadlang{french}%
%    \end{macrocode}
% Set |frenchb| to be equivalent to |french|.
%    \begin{macrocode}
\global\let\@ordinalMfrenchb=\@ordinalMfrench
\global\let\@ordinalFfrenchb=\@ordinalFfrench
\global\let\@ordinalNfrenchb=\@ordinalNfrench
\global\let\@numberstringMfrenchb=\@numberstringMfrench
\global\let\@numberstringFfrenchb=\@numberstringFfrench
\global\let\@numberstringNfrenchb=\@numberstringNfrench
\global\let\@NumberstringMfrenchb=\@NumberstringMfrench
\global\let\@NumberstringFfrenchb=\@NumberstringFfrench
\global\let\@NumberstringNfrenchb=\@NumberstringNfrench
\global\let\@ordinalstringMfrenchb=\@ordinalstringMfrench
\global\let\@ordinalstringFfrenchb=\@ordinalstringFfrench
\global\let\@ordinalstringNfrenchb=\@ordinalstringNfrench
\global\let\@OrdinalstringMfrenchb=\@OrdinalstringMfrench
\global\let\@OrdinalstringFfrenchb=\@OrdinalstringFfrench
\global\let\@OrdinalstringNfrenchb=\@OrdinalstringNfrench
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-frenchb.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-german.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-german.def}
% German definitions (thank you to K. H. Fricke for supplying
% this information)
%    \begin{macrocode}
\ProvidesFCLanguage{german}[2014/06/09]%
%    \end{macrocode}
% Define macro that converts a number or count register (first
% argument) to an ordinal, and stores the result in the
% second argument, which must be a control sequence.
% Masculine:
%    \begin{macrocode}
\newcommand{\@ordinalMgerman}[2]{%
  \edef#2{\number#1\relax.}%
}%
\global\let\@ordinalMgerman\@ordinalMgerman
%    \end{macrocode}
% Feminine:
%    \begin{macrocode}
\newcommand{\@ordinalFgerman}[2]{%
  \edef#2{\number#1\relax.}%
}%
\global\let\@ordinalFgerman\@ordinalFgerman
%    \end{macrocode}
% Neuter:
%    \begin{macrocode}
\newcommand{\@ordinalNgerman}[2]{%
  \edef#2{\number#1\relax.}%
}%
\global\let\@ordinalNgerman\@ordinalNgerman
%    \end{macrocode}
% Convert a number to text. The easiest way to do this is to
% break it up into units, tens and teens.
% Units (argument must be a number from 0 to 9, 1 on its own (eins)
% is dealt with separately):
%    \begin{macrocode}
\newcommand*\@@unitstringgerman[1]{%
  \ifcase#1%
    null%
    \or ein%
    \or zwei%
    \or drei%
    \or vier%
    \or f\"unf%
    \or sechs%
    \or sieben%
    \or acht%
    \or neun%
  \fi
}%
\global\let\@@unitstringgerman\@@unitstringgerman
%    \end{macrocode}
% Tens (argument must go from 1 to 10):
%    \begin{macrocode}
\newcommand*\@@tenstringgerman[1]{%
  \ifcase#1%
    \or zehn%
    \or zwanzig%
    \or drei{\ss}ig%
    \or vierzig%
    \or f\"unfzig%
    \or sechzig%
    \or siebzig%
    \or achtzig%
    \or neunzig%
    \or einhundert%
  \fi
}%
\global\let\@@tenstringgerman\@@tenstringgerman
%    \end{macrocode}
% |\einhundert| is set to |einhundert| by default, user can
% redefine this command to just |hundert| if required, similarly
% for |\eintausend|.
%    \begin{macrocode}
\providecommand*{\einhundert}{einhundert}%
\providecommand*{\eintausend}{eintausend}%
\global\let\einhundert\einhundert
\global\let\eintausend\eintausend
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand*\@@teenstringgerman[1]{%
  \ifcase#1%
    zehn%
    \or elf%
    \or zw\"olf%
    \or dreizehn%
    \or vierzehn%
    \or f\"unfzehn%
    \or sechzehn%
    \or siebzehn%
    \or achtzehn%
    \or neunzehn%
  \fi
}%
\global\let\@@teenstringgerman\@@teenstringgerman
%    \end{macrocode}
% The results are stored in the second argument, but doesn't 
% display anything.
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMgerman}[2]{%
  \let\@unitstring=\@@unitstringgerman
  \let\@teenstring=\@@teenstringgerman
  \let\@tenstring=\@@tenstringgerman
  \@@numberstringgerman{#1}{#2}%
}%
\global\let\@numberstringMgerman\@numberstringMgerman
%    \end{macrocode}
% Feminine and neuter forms:
%    \begin{macrocode}
\global\let\@numberstringFgerman=\@numberstringMgerman
\global\let\@numberstringNgerman=\@numberstringMgerman
%    \end{macrocode}
% As above, but initial letters in upper case:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringMgerman}[2]{%
  \@numberstringMgerman{#1}{\@@num@str}%
  \edef#2{\noexpand\MakeUppercase\expandonce\@@num@str}%
}%
\global\let\@NumberstringMgerman\@NumberstringMgerman
%    \end{macrocode}
% Feminine and neuter form:
%    \begin{macrocode}
\global\let\@NumberstringFgerman=\@NumberstringMgerman
\global\let\@NumberstringNgerman=\@NumberstringMgerman
%    \end{macrocode}
% As above, but for ordinals.
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMgerman}[2]{%
  \let\@unitthstring=\@@unitthstringMgerman
  \let\@teenthstring=\@@teenthstringMgerman
  \let\@tenthstring=\@@tenthstringMgerman
  \let\@unitstring=\@@unitstringgerman
  \let\@teenstring=\@@teenstringgerman
  \let\@tenstring=\@@tenstringgerman
  \def\@thousandth{tausendster}%
  \def\@hundredth{hundertster}%
  \@@ordinalstringgerman{#1}{#2}%
}%
\global\let\@ordinalstringMgerman\@ordinalstringMgerman
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringFgerman}[2]{%
  \let\@unitthstring=\@@unitthstringFgerman
  \let\@teenthstring=\@@teenthstringFgerman
  \let\@tenthstring=\@@tenthstringFgerman
  \let\@unitstring=\@@unitstringgerman
  \let\@teenstring=\@@teenstringgerman
  \let\@tenstring=\@@tenstringgerman
  \def\@thousandth{tausendste}%
  \def\@hundredth{hundertste}%
  \@@ordinalstringgerman{#1}{#2}%
}%
\global\let\@ordinalstringFgerman\@ordinalstringFgerman
%    \end{macrocode}
% Neuter form:
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringNgerman}[2]{%
  \let\@unitthstring=\@@unitthstringNgerman
  \let\@teenthstring=\@@teenthstringNgerman
  \let\@tenthstring=\@@tenthstringNgerman
  \let\@unitstring=\@@unitstringgerman
  \let\@teenstring=\@@teenstringgerman
  \let\@tenstring=\@@tenstringgerman
  \def\@thousandth{tausendstes}%
  \def\@hundredth{hunderstes}%
  \@@ordinalstringgerman{#1}{#2}%
}%
\global\let\@ordinalstringNgerman\@ordinalstringNgerman
%    \end{macrocode}
% As above, but with initial letters in upper case.
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMgerman}[2]{%
 \@ordinalstringMgerman{#1}{\@@num@str}%
 \edef#2{\noexpand\MakeUppercase\expandonce\@@num@str}%
}%
\global\let\@OrdinalstringMgerman\@OrdinalstringMgerman
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringFgerman}[2]{%
 \@ordinalstringFgerman{#1}{\@@num@str}%
 \edef#2{\noexpand\MakeUppercase\expandonce\@@num@str}%
}%
\global\let\@OrdinalstringFgerman\@OrdinalstringFgerman
%    \end{macrocode}
% Neuter form:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringNgerman}[2]{%
 \@ordinalstringNgerman{#1}{\@@num@str}%
 \edef#2{\noexpand\MakeUppercase\expandonce\@@num@str}%
}%
\global\let\@OrdinalstringNgerman\@OrdinalstringNgerman
%    \end{macrocode}
% Code for converting numbers into textual ordinals. As before,
% it is easier to split it into units, tens and teens.
% Units:
%\changes{2.0}{2012-09-25}{fixed spelling mistake (correction
%provided by Dominik Wa\ss enhoven)}
%    \begin{macrocode}
\newcommand*\@@unitthstringMgerman[1]{%
  \ifcase#1%
    nullter%
    \or erster%
    \or zweiter%
    \or dritter%
    \or vierter%
    \or f\"unfter%
    \or sechster%
    \or siebter%
    \or achter%
    \or neunter%
  \fi
}%
\global\let\@@unitthstringMgerman\@@unitthstringMgerman
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand*\@@tenthstringMgerman[1]{%
  \ifcase#1%
    \or zehnter%
    \or zwanzigster%
    \or drei{\ss}igster%
    \or vierzigster%
    \or f\"unfzigster%
    \or sechzigster%
    \or siebzigster%
    \or achtzigster%
    \or neunzigster%
  \fi
}%
\global\let\@@tenthstringMgerman\@@tenthstringMgerman
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand*\@@teenthstringMgerman[1]{%
  \ifcase#1%
    zehnter%
    \or elfter%
    \or zw\"olfter%
    \or dreizehnter%
    \or vierzehnter%
    \or f\"unfzehnter%
    \or sechzehnter%
    \or siebzehnter%
    \or achtzehnter%
    \or neunzehnter%
  \fi
}%
\global\let\@@teenthstringMgerman\@@teenthstringMgerman
%    \end{macrocode}
% Units (feminine):
%    \begin{macrocode}
\newcommand*\@@unitthstringFgerman[1]{%
  \ifcase#1%
    nullte%
    \or erste%
    \or zweite%
    \or dritte%
    \or vierte%
    \or f\"unfte%
    \or sechste%
    \or siebte%
    \or achte%
    \or neunte%
  \fi
}%
\global\let\@@unitthstringFgerman\@@unitthstringFgerman
%    \end{macrocode}
% Tens (feminine):
%    \begin{macrocode}
\newcommand*\@@tenthstringFgerman[1]{%
  \ifcase#1%
    \or zehnte%
    \or zwanzigste%
    \or drei{\ss}igste%
    \or vierzigste%
    \or f\"unfzigste%
    \or sechzigste%
    \or siebzigste%
    \or achtzigste%
    \or neunzigste%
  \fi
}%
\global\let\@@tenthstringFgerman\@@tenthstringFgerman
%    \end{macrocode}
% Teens (feminine)
%    \begin{macrocode}
\newcommand*\@@teenthstringFgerman[1]{%
  \ifcase#1%
    zehnte%
    \or elfte%
    \or zw\"olfte%
    \or dreizehnte%
    \or vierzehnte%
    \or f\"unfzehnte%
    \or sechzehnte%
    \or siebzehnte%
    \or achtzehnte%
    \or neunzehnte%
  \fi
}%
\global\let\@@teenthstringFgerman\@@teenthstringFgerman
%    \end{macrocode}
% Units (neuter):
%\changes{2.0}{2012-09-25}{fixed spelling mistake (correction
%provided by Dominik Wa\ss enhoven)}
%    \begin{macrocode}
\newcommand*\@@unitthstringNgerman[1]{%
  \ifcase#1%
    nulltes%
    \or erstes%
    \or zweites%
    \or drittes%
    \or viertes%
    \or f\"unftes%
    \or sechstes%
    \or siebtes%
    \or achtes%
    \or neuntes%
  \fi
}%
\global\let\@@unitthstringNgerman\@@unitthstringNgerman
%    \end{macrocode}
% Tens (neuter):
%    \begin{macrocode}
\newcommand*\@@tenthstringNgerman[1]{%
  \ifcase#1%
    \or zehntes%
    \or zwanzigstes%
    \or drei{\ss}igstes%
    \or vierzigstes%
    \or f\"unfzigstes%
    \or sechzigstes%
    \or siebzigstes%
    \or achtzigstes%
    \or neunzigstes%
  \fi
}%
\global\let\@@tenthstringNgerman\@@tenthstringNgerman
%    \end{macrocode}
% Teens (neuter)
%    \begin{macrocode}
\newcommand*\@@teenthstringNgerman[1]{%
  \ifcase#1%
    zehntes%
    \or elftes%
    \or zw\"olftes%
    \or dreizehntes%
    \or vierzehntes%
    \or f\"unfzehntes%
    \or sechzehntes%
    \or siebzehntes%
    \or achtzehntes%
    \or neunzehntes%
  \fi
}%
\global\let\@@teenthstringNgerman\@@teenthstringNgerman
%    \end{macrocode}
% This appends the results to |\#2| for number |\#2| (in range 0 to
% 100.)
% null and eins are dealt with separately in
% |\@@numberstringgerman|.
%    \begin{macrocode}
\newcommand*\@@numberunderhundredgerman[2]{%
\ifnum#1<10\relax
  \ifnum#1>0\relax
    \eappto#2{\@unitstring{#1}}%
  \fi
\else
  \@tmpstrctr=#1\relax
  \@FCmodulo{\@tmpstrctr}{10}%
  \ifnum#1<20\relax
    \eappto#2{\@teenstring{\@tmpstrctr}}%
  \else
    \ifnum\@tmpstrctr=0\relax
    \else
      \eappto#2{\@unitstring{\@tmpstrctr}und}%
    \fi
    \@tmpstrctr=#1\relax
    \divide\@tmpstrctr by 10\relax
    \eappto#2{\@tenstring{\@tmpstrctr}}%
  \fi
\fi
}%
\global\let\@@numberunderhundredgerman\@@numberunderhundredgerman
%    \end{macrocode}
% This stores the results in the second argument 
% (which must be a control
% sequence), but it doesn't display anything.
%    \begin{macrocode}
\newcommand*\@@numberstringgerman[2]{%
\ifnum#1>99999\relax
  \PackageError{fmtcount}{Out of range}%
  {This macro only works for values less than 100000}%
\else
  \ifnum#1<0\relax
    \PackageError{fmtcount}{Negative numbers not permitted}%
    {This macro does not work for negative numbers, however
    you can try typing "minus" first, and then pass the modulus of
    this number}%
  \fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>1\relax
%    \end{macrocode}
% \#1 is $\geq 2000$, \cs{@strctr} now contains the number of thousands
%    \begin{macrocode}
 \@@numberunderhundredgerman{\@strctr}{#2}%
  \appto#2{tausend}%
\else
%    \end{macrocode}
% \#1 lies in range [1000,1999]
%    \begin{macrocode}
  \ifnum\@strctr=1\relax
    \eappto#2{\eintausend}%
  \fi
\fi
\@strctr=#1\relax
\@FCmodulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>1\relax
%    \end{macrocode}
% now dealing with number in range [200,999]
%    \begin{macrocode}
  \eappto#2{\@unitstring{\@strctr}hundert}%
\else
   \ifnum\@strctr=1\relax
%    \end{macrocode}
% dealing with number in range [100,199]
%    \begin{macrocode}
     \ifnum#1>1000\relax
%    \end{macrocode}
% if original number $> 1000$, use einhundert
%    \begin{macrocode}
        \appto#2{einhundert}%
     \else
%    \end{macrocode}
% otherwise use \cs{einhundert}
%    \begin{macrocode}
        \eappto#2{\einhundert}%
      \fi
   \fi
\fi
\@strctr=#1\relax
\@FCmodulo{\@strctr}{100}%
\ifnum#1=0\relax
  \def#2{null}%
\else
  \ifnum\@strctr=1\relax
    \appto#2{eins}%
  \else
    \@@numberunderhundredgerman{\@strctr}{#2}%
  \fi
\fi
}%
\global\let\@@numberstringgerman\@@numberstringgerman
%    \end{macrocode}
% As above, but for ordinals
%    \begin{macrocode}
\newcommand*\@@numberunderhundredthgerman[2]{%
\ifnum#1<10\relax
 \eappto#2{\@unitthstring{#1}}%
\else
  \@tmpstrctr=#1\relax
  \@FCmodulo{\@tmpstrctr}{10}%
  \ifnum#1<20\relax
    \eappto#2{\@teenthstring{\@tmpstrctr}}%
  \else
    \ifnum\@tmpstrctr=0\relax
    \else
      \eappto#2{\@unitstring{\@tmpstrctr}und}%
    \fi
    \@tmpstrctr=#1\relax
    \divide\@tmpstrctr by 10\relax
    \eappto#2{\@tenthstring{\@tmpstrctr}}%
  \fi
\fi
}%
\global\let\@@numberunderhundredthgerman\@@numberunderhundredthgerman
%    \end{macrocode}
%    \begin{macrocode}
\newcommand*\@@ordinalstringgerman[2]{%
\ifnum#1>99999\relax
  \PackageError{fmtcount}{Out of range}%
  {This macro only works for values less than 100000}%
\else
  \ifnum#1<0\relax
    \PackageError{fmtcount}{Negative numbers not permitted}%
    {This macro does not work for negative numbers, however
    you can try typing "minus" first, and then pass the modulus of
    this number}%
  \fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>1\relax
%    \end{macrocode}
% \#1 is $\geq 2000$, \cs{@strctr} now contains the number of thousands
%    \begin{macrocode}
\@@numberunderhundredgerman{\@strctr}{#2}%
%    \end{macrocode}
% is that it, or is there more?
%    \begin{macrocode}
  \@tmpstrctr=#1\relax \@FCmodulo{\@tmpstrctr}{1000}%
  \ifnum\@tmpstrctr=0\relax
    \eappto#2{\@thousandth}%
  \else
    \appto#2{tausend}%
  \fi
\else
%    \end{macrocode}
% \#1 lies in range [1000,1999]
%    \begin{macrocode}
  \ifnum\@strctr=1\relax
    \ifnum#1=1000\relax
      \eappto#2{\@thousandth}%
    \else
      \eappto#2{\eintausend}%
    \fi
  \fi
\fi
\@strctr=#1\relax
\@FCmodulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>1\relax
%    \end{macrocode}
% now dealing with number in range [200,999]
% is that it, or is there more?
%    \begin{macrocode}
  \@tmpstrctr=#1\relax \@FCmodulo{\@tmpstrctr}{100}%
  \ifnum\@tmpstrctr=0\relax
     \ifnum\@strctr=1\relax
       \eappto#2{\@hundredth}%
     \else
       \eappto#2{\@unitstring{\@strctr}\@hundredth}%
     \fi
  \else
     \eappto#2{\@unitstring{\@strctr}hundert}%
  \fi
\else
   \ifnum\@strctr=1\relax
%    \end{macrocode}
% dealing with number in range [100,199]
% is that it, or is there more?
%    \begin{macrocode}
     \@tmpstrctr=#1\relax \@FCmodulo{\@tmpstrctr}{100}%
     \ifnum\@tmpstrctr=0\relax
        \eappto#2{\@hundredth}%
     \else
     \ifnum#1>1000\relax
        \appto#2{einhundert}%
     \else
        \eappto#2{\einhundert}%
     \fi
     \fi
   \fi
\fi
\@strctr=#1\relax
\@FCmodulo{\@strctr}{100}%
\ifthenelse{\@strctr=0 \and #1>0}{}{%
\@@numberunderhundredthgerman{\@strctr}{#2}%
}%
}%
\global\let\@@ordinalstringgerman\@@ordinalstringgerman
%    \end{macrocode}
% Load fc-germanb.def if not already loaded
%    \begin{macrocode}
\FCloadlang{germanb}%
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-german.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-germanb.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-germanb.def}
%    \begin{macrocode}
\ProvidesFCLanguage{germanb}[2013/08/17]%
%    \end{macrocode}
% Load fc-german.def if not already loaded
%    \begin{macrocode}
\FCloadlang{german}%
%    \end{macrocode}
% Set |germanb| to be equivalent to |german|.
%    \begin{macrocode}
\global\let\@ordinalMgermanb=\@ordinalMgerman
\global\let\@ordinalFgermanb=\@ordinalFgerman
\global\let\@ordinalNgermanb=\@ordinalNgerman
\global\let\@numberstringMgermanb=\@numberstringMgerman
\global\let\@numberstringFgermanb=\@numberstringFgerman
\global\let\@numberstringNgermanb=\@numberstringNgerman
\global\let\@NumberstringMgermanb=\@NumberstringMgerman
\global\let\@NumberstringFgermanb=\@NumberstringFgerman
\global\let\@NumberstringNgermanb=\@NumberstringNgerman
\global\let\@ordinalstringMgermanb=\@ordinalstringMgerman
\global\let\@ordinalstringFgermanb=\@ordinalstringFgerman
\global\let\@ordinalstringNgermanb=\@ordinalstringNgerman
\global\let\@OrdinalstringMgermanb=\@OrdinalstringMgerman
\global\let\@OrdinalstringFgermanb=\@OrdinalstringFgerman
\global\let\@OrdinalstringNgermanb=\@OrdinalstringNgerman
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-germanb.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-italian.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-italian}
% Italian support is now handled by interfacing to Enrico Gregorio's
% itnumpar package.
%    \begin{macrocode}
\ProvidesFCLanguage{italian}[2013/08/17]

\RequirePackage{itnumpar}

\newcommand{\@numberstringMitalian}[2]{%
  \edef#2{\noexpand\printnumeroinparole{#1}}%
}
\global\let\@numberstringMitalian\@numberstringMitalian

\newcommand{\@numberstringFitalian}[2]{%
  \edef#2{\noexpand\printnumeroinparole{#1}}}

\global\let\@numberstringFitalian\@numberstringFitalian

\newcommand{\@NumberstringMitalian}[2]{%
  \edef#2{\noexpand\printNumeroinparole{#1}}%
}
\global\let\@NumberstringMitalian\@NumberstringMitalian

\newcommand{\@NumberstringFitalian}[2]{%
  \edef#2{\noexpand\printNumeroinparole{#1}}%
}
\global\let\@NumberstringFitalian\@NumberstringFitalian

\newcommand{\@ordinalstringMitalian}[2]{%
  \edef#2{\noexpand\printordinalem{#1}}%
}
\global\let\@ordinalstringMitalian\@ordinalstringMitalian

\newcommand{\@ordinalstringFitalian}[2]{%
  \edef#2{\noexpand\printordinalef{#1}}%
}
\global\let\@ordinalstringFitalian\@ordinalstringFitalian

\newcommand{\@OrdinalstringMitalian}[2]{%
  \edef#2{\noexpand\printOrdinalem{#1}}%
}
\global\let\@OrdinalstringMitalian\@OrdinalstringMitalian

\newcommand{\@OrdinalstringFitalian}[2]{%
  \edef#2{\noexpand\printOrdinalef{#1}}%
}
\global\let\@OrdinalstringFitalian\@OrdinalstringFitalian

\newcommand{\@ordinalMitalian}[2]{%
  \edef#2{#1\relax\noexpand\fmtord{o}}}

\global\let\@ordinalMitalian\@ordinalMitalian

\newcommand{\@ordinalFitalian}[2]{%
  \edef#2{#1\relax\noexpand\fmtord{a}}}
\global\let\@ordinalFitalian\@ordinalFitalian
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-italian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-ngerman.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-ngerman.def}
%    \begin{macrocode}
\ProvidesFCLanguage{ngerman}[2012/06/18]%
\FCloadlang{german}%
\FCloadlang{ngermanb}%
%    \end{macrocode}
% Set |ngerman| to be equivalent to |german|. Is it okay to do
% this? (I don't know the difference between the two.)
%    \begin{macrocode}
\global\let\@ordinalMngerman=\@ordinalMgerman
\global\let\@ordinalFngerman=\@ordinalFgerman
\global\let\@ordinalNngerman=\@ordinalNgerman
\global\let\@numberstringMngerman=\@numberstringMgerman
\global\let\@numberstringFngerman=\@numberstringFgerman
\global\let\@numberstringNngerman=\@numberstringNgerman
\global\let\@NumberstringMngerman=\@NumberstringMgerman
\global\let\@NumberstringFngerman=\@NumberstringFgerman
\global\let\@NumberstringNngerman=\@NumberstringNgerman
\global\let\@ordinalstringMngerman=\@ordinalstringMgerman
\global\let\@ordinalstringFngerman=\@ordinalstringFgerman
\global\let\@ordinalstringNngerman=\@ordinalstringNgerman
\global\let\@OrdinalstringMngerman=\@OrdinalstringMgerman
\global\let\@OrdinalstringFngerman=\@OrdinalstringFgerman
\global\let\@OrdinalstringNngerman=\@OrdinalstringNgerman
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-ngerman.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-ngermanb.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-ngermanb.def}
%    \begin{macrocode}
\ProvidesFCLanguage{ngermanb}[2013/08/17]%
\FCloadlang{german}%
%    \end{macrocode}
% Set |ngermanb| to be equivalent to |german|. Is it okay to do
% this? (I don't know the difference between the two.)
%    \begin{macrocode}
\global\let\@ordinalMngermanb=\@ordinalMgerman
\global\let\@ordinalFngermanb=\@ordinalFgerman
\global\let\@ordinalNngermanb=\@ordinalNgerman
\global\let\@numberstringMngermanb=\@numberstringMgerman
\global\let\@numberstringFngermanb=\@numberstringFgerman
\global\let\@numberstringNngermanb=\@numberstringNgerman
\global\let\@NumberstringMngermanb=\@NumberstringMgerman
\global\let\@NumberstringFngermanb=\@NumberstringFgerman
\global\let\@NumberstringNngermanb=\@NumberstringNgerman
\global\let\@ordinalstringMngermanb=\@ordinalstringMgerman
\global\let\@ordinalstringFngermanb=\@ordinalstringFgerman
\global\let\@ordinalstringNngermanb=\@ordinalstringNgerman
\global\let\@OrdinalstringMngermanb=\@OrdinalstringMgerman
\global\let\@OrdinalstringFngermanb=\@OrdinalstringFgerman
\global\let\@OrdinalstringNngermanb=\@OrdinalstringNgerman
%    \end{macrocode}
% Load fc-ngerman.def if not already loaded
%    \begin{macrocode}
\FCloadlang{ngerman}%
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-ngermanb.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-portuges.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-portuges.def}
% Portuguse definitions
%    \begin{macrocode}
\ProvidesFCLanguage{portuges}[2014/06/09]%
%    \end{macrocode}
% Define macro that converts a number or count register (first
% argument) to an ordinal, and stores the result in the second
% argument, which should be a control sequence. Masculine:
%    \begin{macrocode}
\newcommand*\@ordinalMportuges[2]{%
  \ifnum#1=0\relax
    \edef#2{\number#1}%
  \else
    \edef#2{\number#1\relax\noexpand\fmtord{o}}%
  \fi
}%
\global\let\@ordinalMportuges\@ordinalMportuges
%    \end{macrocode}
% Feminine:
%    \begin{macrocode}
\newcommand*\@ordinalFportuges[2]{%
  \ifnum#1=0\relax
    \edef#2{\number#1}%
  \else
    \edef#2{\number#1\relax\noexpand\fmtord{a}}%
  \fi
}%
\global\let\@ordinalFportuges\@ordinalFportuges
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\global\let\@ordinalNportuges\@ordinalMportuges
%    \end{macrocode}
% Convert a number to a textual representation. To make it easier,
% split it up into units, tens, teens and hundreds. Units (argument
% must
% be a number from 0 to 9):
%\changes{2.04}{2014-06-09}{Fixed bug that had incorrect number of
%parameters specified}
%    \begin{macrocode}
\newcommand*\@@unitstringportuges[1]{%
  \ifcase#1\relax
    zero%
    \or um%
    \or dois%
    \or tr\^es%
    \or quatro%
    \or cinco%
    \or seis%
    \or sete%
    \or oito%
    \or nove%
  \fi
}%
\global\let\@@unitstringportuges\@@unitstringportuges
%   \end{macrocode}
% As above, but for feminine:
%   \begin{macrocode}
\newcommand*\@@unitstringFportuges[1]{%
  \ifcase#1\relax
    zero%
    \or uma%
    \or duas%
    \or tr\^es%
    \or quatro%
    \or cinco%
    \or seis%
    \or sete%
    \or oito%
    \or nove%
  \fi
}%
\global\let\@@unitstringFportuges\@@unitstringFportuges
%    \end{macrocode}
% Tens (argument must be a number from 0 to 10):
%    \begin{macrocode}
\newcommand*\@@tenstringportuges[1]{%
  \ifcase#1\relax
    \or dez%
    \or vinte%
    \or trinta%
    \or quarenta%
    \or cinq\"uenta%
    \or sessenta%
    \or setenta%
    \or oitenta%
    \or noventa%
    \or cem%
  \fi
}%
\global\let\@@tenstringportuges\@@tenstringportuges
%    \end{macrocode}
% Teens (argument must be a number from 0 to 9):
%    \begin{macrocode}
\newcommand*\@@teenstringportuges[1]{%
  \ifcase#1\relax
    dez%
    \or onze%
    \or doze%
    \or treze%
    \or quatorze%
    \or quinze%
    \or dezesseis%
    \or dezessete%
    \or dezoito%
    \or dezenove%
  \fi
}%
\global\let\@@teenstringportuges\@@teenstringportuges
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand*\@@hundredstringportuges[1]{%
  \ifcase#1\relax
    \or cento%
    \or duzentos%
    \or trezentos%
    \or quatrocentos%
    \or quinhentos%
    \or seiscentos%
    \or setecentos%
    \or oitocentos%
    \or novecentos%
  \fi
}%
\global\let\@@hundredstringportuges\@@hundredstringportuges
%    \end{macrocode}
% Hundreds (feminine):
%    \begin{macrocode}
\newcommand*\@@hundredstringFportuges[1]{%
  \ifcase#1\relax
    \or cento%
    \or duzentas%
    \or trezentas%
    \or quatrocentas%
    \or quinhentas%
    \or seiscentas%
    \or setecentas%
    \or oitocentas%
    \or novecentas%
  \fi
}%
\global\let\@@hundredstringFportuges\@@hundredstringFportuges
%    \end{macrocode}
% Units (initial letter in upper case):
%    \begin{macrocode}
\newcommand*\@@Unitstringportuges[1]{%
  \ifcase#1\relax
    Zero%
    \or Um%
    \or Dois%
    \or Tr\^es%
    \or Quatro%
    \or Cinco%
    \or Seis%
    \or Sete%
    \or Oito%
    \or Nove%
  \fi
}%
\global\let\@@Unitstringportuges\@@Unitstringportuges
%    \end{macrocode}
% As above, but feminine:
%    \begin{macrocode}
\newcommand*\@@UnitstringFportuges[1]{%
  \ifcase#1\relax
    Zera%
    \or Uma%
    \or Duas%
    \or Tr\^es%
    \or Quatro%
    \or Cinco%
    \or Seis%
    \or Sete%
    \or Oito%
    \or Nove%
  \fi
}%
\global\let\@@UnitstringFportuges\@@UnitstringFportuges
%    \end{macrocode}
% Tens (with initial letter in upper case):
%    \begin{macrocode}
\newcommand*\@@Tenstringportuges[1]{%
  \ifcase#1\relax
    \or Dez%
    \or Vinte%
    \or Trinta%
    \or Quarenta%
    \or Cinq\"uenta%
    \or Sessenta%
    \or Setenta%
    \or Oitenta%
    \or Noventa%
    \or Cem%
  \fi
}%
\global\let\@@Tenstringportuges\@@Tenstringportuges
%    \end{macrocode}
% Teens (with initial letter in upper case):
%    \begin{macrocode}
\newcommand*\@@Teenstringportuges[1]{%
  \ifcase#1\relax
    Dez%
    \or Onze%
    \or Doze%
    \or Treze%
    \or Quatorze%
    \or Quinze%
    \or Dezesseis%
    \or Dezessete%
    \or Dezoito%
    \or Dezenove%
  \fi
}%
\global\let\@@Teenstringportuges\@@Teenstringportuges
%    \end{macrocode}
% Hundreds (with initial letter in upper case):
%    \begin{macrocode}
\newcommand*\@@Hundredstringportuges[1]{%
  \ifcase#1\relax
    \or Cento%
    \or Duzentos%
    \or Trezentos%
    \or Quatrocentos%
    \or Quinhentos%
    \or Seiscentos%
    \or Setecentos%
    \or Oitocentos%
    \or Novecentos%
  \fi
}%
\global\let\@@Hundredstringportuges\@@Hundredstringportuges
%    \end{macrocode}
% As above, but feminine:
%    \begin{macrocode}
\newcommand*\@@HundredstringFportuges[1]{%
  \ifcase#1\relax
    \or Cento%
    \or Duzentas%
    \or Trezentas%
    \or Quatrocentas%
    \or Quinhentas%
    \or Seiscentas%
    \or Setecentas%
    \or Oitocentas%
    \or Novecentas%
  \fi
}%
\global\let\@@HundredstringFportuges\@@HundredstringFportuges
%    \end{macrocode}
% This has changed in version 1.08, so that it now stores
% the result in the second argument, but doesn't display
% anything. Since it only affects internal macros, it shouldn't
% affect documents created with older versions. (These internal
% macros are not meant for use in documents.)
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMportuges}[2]{%
  \let\@unitstring=\@@unitstringportuges
  \let\@teenstring=\@@teenstringportuges
  \let\@tenstring=\@@tenstringportuges
  \let\@hundredstring=\@@hundredstringportuges
  \def\@hundred{cem}\def\@thousand{mil}%
  \def\@andname{e}%
  \@@numberstringportuges{#1}{#2}%
}%
\global\let\@numberstringMportuges\@numberstringMportuges
%    \end{macrocode}
% As above, but feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringFportuges}[2]{%
  \let\@unitstring=\@@unitstringFportuges
  \let\@teenstring=\@@teenstringportuges
  \let\@tenstring=\@@tenstringportuges
  \let\@hundredstring=\@@hundredstringFportuges
  \def\@hundred{cem}\def\@thousand{mil}%
  \def\@andname{e}%
  \@@numberstringportuges{#1}{#2}%
}%
\global\let\@numberstringFportuges\@numberstringFportuges
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\global\let\@numberstringNportuges\@numberstringMportuges
%    \end{macrocode}
% As above, but initial letters in upper case:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringMportuges}[2]{%
  \let\@unitstring=\@@Unitstringportuges
  \let\@teenstring=\@@Teenstringportuges
  \let\@tenstring=\@@Tenstringportuges
  \let\@hundredstring=\@@Hundredstringportuges
  \def\@hundred{Cem}\def\@thousand{Mil}%
  \def\@andname{e}%
  \@@numberstringportuges{#1}{#2}%
}%
\global\let\@NumberstringMportuges\@NumberstringMportuges
%    \end{macrocode}
% As above, but feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringFportuges}[2]{%
  \let\@unitstring=\@@UnitstringFportuges
  \let\@teenstring=\@@Teenstringportuges
  \let\@tenstring=\@@Tenstringportuges
  \let\@hundredstring=\@@HundredstringFportuges
  \def\@hundred{Cem}\def\@thousand{Mil}%
  \def\@andname{e}%
  \@@numberstringportuges{#1}{#2}%
}%
\global\let\@NumberstringFportuges\@NumberstringFportuges
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\global\let\@NumberstringNportuges\@NumberstringMportuges
%    \end{macrocode}
% As above, but for ordinals.
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMportuges}[2]{%
  \let\@unitthstring=\@@unitthstringportuges
  \let\@unitstring=\@@unitstringportuges
  \let\@teenthstring=\@@teenthstringportuges
  \let\@tenthstring=\@@tenthstringportuges
  \let\@hundredthstring=\@@hundredthstringportuges
  \def\@thousandth{mil\'esimo}%
  \@@ordinalstringportuges{#1}{#2}%
}%
\global\let\@ordinalstringMportuges\@ordinalstringMportuges
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringFportuges}[2]{%
  \let\@unitthstring=\@@unitthstringFportuges
  \let\@unitstring=\@@unitstringFportuges
  \let\@teenthstring=\@@teenthstringportuges
  \let\@tenthstring=\@@tenthstringFportuges
  \let\@hundredthstring=\@@hundredthstringFportuges
  \def\@thousandth{mil\'esima}%
  \@@ordinalstringportuges{#1}{#2}%
}%
\global\let\@ordinalstringFportuges\@ordinalstringFportuges
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\global\let\@ordinalstringNportuges\@ordinalstringMportuges
%    \end{macrocode}
% As above, but initial letters in upper case (masculine):
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMportuges}[2]{%
  \let\@unitthstring=\@@Unitthstringportuges
  \let\@unitstring=\@@Unitstringportuges
  \let\@teenthstring=\@@teenthstringportuges
  \let\@tenthstring=\@@Tenthstringportuges
  \let\@hundredthstring=\@@Hundredthstringportuges
  \def\@thousandth{Mil\'esimo}%
  \@@ordinalstringportuges{#1}{#2}%
}%
\global\let\@OrdinalstringMportuges\@OrdinalstringMportuges
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringFportuges}[2]{%
  \let\@unitthstring=\@@UnitthstringFportuges
  \let\@unitstring=\@@UnitstringFportuges
  \let\@teenthstring=\@@teenthstringportuges
  \let\@tenthstring=\@@TenthstringFportuges
  \let\@hundredthstring=\@@HundredthstringFportuges
  \def\@thousandth{Mil\'esima}%
  \@@ordinalstringportuges{#1}{#2}%
}%
\global\let\@OrdinalstringFportuges\@OrdinalstringFportuges
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\global\let\@OrdinalstringNportuges\@OrdinalstringMportuges
%    \end{macrocode}
% In order to do the ordinals, split into units, teens, tens
% and hundreds. Units:
%    \begin{macrocode}
\newcommand*\@@unitthstringportuges[1]{%
  \ifcase#1\relax
    zero%
    \or primeiro%
    \or segundo%
    \or terceiro%
    \or quarto%
    \or quinto%
    \or sexto%
    \or s\'etimo%
    \or oitavo%
    \or nono%
  \fi
}%
\global\let\@@unitthstringportuges\@@unitthstringportuges
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand*\@@tenthstringportuges[1]{%
  \ifcase#1\relax
    \or d\'ecimo%
    \or vig\'esimo%
    \or trig\'esimo%
    \or quadrag\'esimo%
    \or q\"uinquag\'esimo%
    \or sexag\'esimo%
    \or setuag\'esimo%
    \or octog\'esimo%
    \or nonag\'esimo%
  \fi
}%
\global\let\@@tenthstringportuges\@@tenthstringportuges
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand*\@@teenthstringportuges[1]{%
  \@tenthstring{1}%
  \ifnum#1>0\relax
    -\@unitthstring{#1}%
  \fi
}%
\global\let\@@teenthstringportuges\@@teenthstringportuges
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand*\@@hundredthstringportuges[1]{%
  \ifcase#1\relax
    \or cent\'esimo%
    \or ducent\'esimo%
    \or trecent\'esimo%
    \or quadringent\'esimo%
    \or q\"uingent\'esimo%
    \or seiscent\'esimo%
    \or setingent\'esimo%
    \or octingent\'esimo%
    \or nongent\'esimo%
  \fi
}%
\global\let\@@hundredthstringportuges\@@hundredthstringportuges
%    \end{macrocode}
% Units (feminine):
%    \begin{macrocode}
\newcommand*\@@unitthstringFportuges[1]{%
  \ifcase#1\relax
    zero%
    \or primeira%
    \or segunda%
    \or terceira%
    \or quarta%
    \or quinta%
    \or sexta%
    \or s\'etima%
    \or oitava%
    \or nona%
  \fi
}%
\global\let\@@unitthstringFportuges\@@unitthstringFportuges
%    \end{macrocode}
% Tens (feminine):
%    \begin{macrocode}
\newcommand*\@@tenthstringFportuges[1]{%
  \ifcase#1\relax
    \or d\'ecima%
    \or vig\'esima%
    \or trig\'esima%
    \or quadrag\'esima%
    \or q\"uinquag\'esima%
    \or sexag\'esima%
    \or setuag\'esima%
    \or octog\'esima%
    \or nonag\'esima%
  \fi
}%
\global\let\@@tenthstringFportuges\@@tenthstringFportuges
%    \end{macrocode}
% Hundreds (feminine):
%    \begin{macrocode}
\newcommand*\@@hundredthstringFportuges[1]{%
  \ifcase#1\relax
    \or cent\'esima%
    \or ducent\'esima%
    \or trecent\'esima%
    \or quadringent\'esima%
    \or q\"uingent\'esima%
    \or seiscent\'esima%
    \or setingent\'esima%
    \or octingent\'esima%
    \or nongent\'esima%
  \fi
}%
\global\let\@@hundredthstringFportuges\@@hundredthstringFportuges
%    \end{macrocode}
% As above, but with initial letter in upper case. Units:
%    \begin{macrocode}
\newcommand*\@@Unitthstringportuges[1]{%
  \ifcase#1\relax
    Zero%
    \or Primeiro%
    \or Segundo%
    \or Terceiro%
    \or Quarto%
    \or Quinto%
    \or Sexto%
    \or S\'etimo%
    \or Oitavo%
    \or Nono%
  \fi
}%
\global\let\@@Unitthstringportuges\@@Unitthstringportuges
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand*\@@Tenthstringportuges[1]{%
  \ifcase#1\relax
    \or D\'ecimo%
    \or Vig\'esimo%
    \or Trig\'esimo%
    \or Quadrag\'esimo%
    \or Q\"uinquag\'esimo%
    \or Sexag\'esimo%
    \or Setuag\'esimo%
    \or Octog\'esimo%
    \or Nonag\'esimo%
  \fi
}%
\global\let\@@Tenthstringportuges\@@Tenthstringportuges
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand*\@@Hundredthstringportuges[1]{%
  \ifcase#1\relax
    \or Cent\'esimo%
    \or Ducent\'esimo%
    \or Trecent\'esimo%
    \or Quadringent\'esimo%
    \or Q\"uingent\'esimo%
    \or Seiscent\'esimo%
    \or Setingent\'esimo%
    \or Octingent\'esimo%
    \or Nongent\'esimo%
  \fi
}%
\global\let\@@Hundredthstringportuges\@@Hundredthstringportuges
%    \end{macrocode}
% As above, but feminine. Units:
%    \begin{macrocode}
\newcommand*\@@UnitthstringFportuges[1]{%
  \ifcase#1\relax
    Zera%
    \or Primeira%
    \or Segunda%
    \or Terceira%
    \or Quarta%
    \or Quinta%
    \or Sexta%
    \or S\'etima%
    \or Oitava%
    \or Nona%
  \fi
}%
\global\let\@@UnitthstringFportuges\@@UnitthstringFportuges
%    \end{macrocode}
% Tens (feminine);
%    \begin{macrocode}
\newcommand*\@@TenthstringFportuges[1]{%
  \ifcase#1\relax
    \or D\'ecima%
    \or Vig\'esima%
    \or Trig\'esima%
    \or Quadrag\'esima%
    \or Q\"uinquag\'esima%
    \or Sexag\'esima%
    \or Setuag\'esima%
    \or Octog\'esima%
    \or Nonag\'esima%
  \fi
}%
\global\let\@@TenthstringFportuges\@@TenthstringFportuges
%    \end{macrocode}
% Hundreds (feminine):
%    \begin{macrocode}
\newcommand*\@@HundredthstringFportuges[1]{%
  \ifcase#1\relax
    \or Cent\'esima%
    \or Ducent\'esima%
    \or Trecent\'esima%
    \or Quadringent\'esima%
    \or Q\"uingent\'esima%
    \or Seiscent\'esima%
    \or Setingent\'esima%
    \or Octingent\'esima%
    \or Nongent\'esima%
  \fi
}%
\global\let\@@HundredthstringFportuges\@@HundredthstringFportuges
%    \end{macrocode}
% This has changed in version 1.09, so that it now stores
% the result in the second argument (a control sequence), but it
% doesn't display anything. Since it only affects internal macros,
% it shouldn't affect documents created with older versions.
% (These internal macros are not meant for use in documents.)
%    \begin{macrocode}
\newcommand*\@@numberstringportuges[2]{%
\ifnum#1>99999\relax
  \PackageError{fmtcount}{Out of range}%
  {This macro only works for values less than 100000}%
\else
  \ifnum#1<0\relax
    \PackageError{fmtcount}{Negative numbers not permitted}%
    {This macro does not work for negative numbers, however
    you can try typing "minus" first, and then pass the modulus of
    this number}%
  \fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9\relax
%    \end{macrocode}
% \#1 is greater or equal to 10000
%    \begin{macrocode}
  \divide\@strctr by 10\relax
  \ifnum\@strctr>1\relax
    \let\@@fc@numstr#2\relax
    \protected@edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
    \@strctr=#1 \divide\@strctr by 1000\relax
    \@FCmodulo{\@strctr}{10}%
    \ifnum\@strctr>0
      \ifnum\@strctr=1\relax
        \let\@@fc@numstr#2\relax
        \protected@edef#2{\@@fc@numstr\ \@andname}%
      \fi
      \let\@@fc@numstr#2\relax
      \protected@edef#2{\@@fc@numstr\ \@unitstring{\@strctr}}%
    \fi
  \else
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@FCmodulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \protected@edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
  \let\@@fc@numstr#2\relax
  \protected@edef#2{\@@fc@numstr\ \@thousand}%
\else
  \ifnum\@strctr>0\relax
    \ifnum\@strctr>1\relax
      \let\@@fc@numstr#2\relax
      \protected@edef#2{\@@fc@numstr\@unitstring{\@strctr}\ }%
    \fi
    \let\@@fc@numstr#2\relax
    \protected@edef#2{\@@fc@numstr\@thousand}%
  \fi
\fi
\@strctr=#1\relax \@FCmodulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>0\relax
  \ifnum#1>1000 \relax
    \let\@@fc@numstr#2\relax
    \protected@edef#2{\@@fc@numstr\ }%
  \fi
  \@tmpstrctr=#1\relax
  \@FCmodulo{\@tmpstrctr}{1000}%
  \let\@@fc@numstr#2\relax
  \ifnum\@tmpstrctr=100\relax
    \protected@edef#2{\@@fc@numstr\@tenstring{10}}%
  \else
    \protected@edef#2{\@@fc@numstr\@hundredstring{\@strctr}}%
  \fi%
\fi
\@strctr=#1\relax \@FCmodulo{\@strctr}{100}%
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \protected@edef#2{\@@fc@numstr\ \@andname\ }%
  \fi
\fi
\ifnum\@strctr>19\relax
  \divide\@strctr by 10\relax
  \let\@@fc@numstr#2\relax
  \protected@edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
  \@strctr=#1\relax \@FCmodulo{\@strctr}{10}%
  \ifnum\@strctr>0
    \ifnum\@strctr=1\relax
      \let\@@fc@numstr#2\relax
      \protected@edef#2{\@@fc@numstr\ \@andname}%
    \else
      \ifnum#1>100\relax
        \let\@@fc@numstr#2\relax
        \protected@edef#2{\@@fc@numstr\ \@andname}%
      \fi
    \fi
    \let\@@fc@numstr#2\relax
    \protected@edef#2{\@@fc@numstr\ \@unitstring{\@strctr}}%
  \fi
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
      \ifnum#1<100\relax
        \let\@@fc@numstr#2\relax
        \protected@edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
      \fi
    \else %(>0,<10)
      \let\@@fc@numstr#2\relax
      \protected@edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
    \fi
  \else%>10
    \@FCmodulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \protected@edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
\fi
}%
\global\let\@@numberstringportuges\@@numberstringportuges
%    \end{macrocode}
% As above, but for ordinals.
%    \begin{macrocode}
\newcommand*\@@ordinalstringportuges[2]{%
\@strctr=#1\relax
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\else
\def#2{}%
\ifnum\@strctr>999\relax
  \divide\@strctr by 1000\relax
  \ifnum\@strctr>1\relax
    \ifnum\@strctr>9\relax
      \@tmpstrctr=\@strctr
      \ifnum\@strctr<20
        \@FCmodulo{\@tmpstrctr}{10}%
        \let\@@fc@ordstr#2\relax
        \protected@edef#2{\@@fc@ordstr\@teenthstring{\@tmpstrctr}}%
      \else
        \divide\@tmpstrctr by 10\relax
        \let\@@fc@ordstr#2\relax
        \protected@edef#2{\@@fc@ordstr\@tenthstring{\@tmpstrctr}}%
        \@tmpstrctr=\@strctr
        \@FCmodulo{\@tmpstrctr}{10}%
        \ifnum\@tmpstrctr>0\relax
          \let\@@fc@ordstr#2\relax
          \protected@edef#2{\@@fc@ordstr\@unitthstring{\@tmpstrctr}}%
        \fi
      \fi
    \else
      \let\@@fc@ordstr#2\relax
      \protected@edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
    \fi
  \fi
  \let\@@fc@ordstr#2\relax
  \protected@edef#2{\@@fc@ordstr\@thousandth}%
\fi
\@strctr=#1\relax
\@FCmodulo{\@strctr}{1000}%
\ifnum\@strctr>99\relax
  \@tmpstrctr=\@strctr
  \divide\@tmpstrctr by 100\relax
  \ifnum#1>1000\relax
    \let\@@fc@ordstr#2\relax
    \protected@edef#2{\@@fc@ordstr-}%
  \fi
  \let\@@fc@ordstr#2\relax
  \protected@edef#2{\@@fc@ordstr\@hundredthstring{\@tmpstrctr}}%
\fi
\@FCmodulo{\@strctr}{100}%
\ifnum#1>99\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \protected@edef#2{\@@fc@ordstr-}%
  \fi
\fi
\ifnum\@strctr>9\relax
  \@tmpstrctr=\@strctr
  \divide\@tmpstrctr by 10\relax
  \let\@@fc@ordstr#2\relax
  \protected@edef#2{\@@fc@ordstr\@tenthstring{\@tmpstrctr}}%
  \@tmpstrctr=\@strctr
  \@FCmodulo{\@tmpstrctr}{10}%
  \ifnum\@tmpstrctr>0\relax
    \let\@@fc@ordstr#2\relax
    \protected@edef#2{\@@fc@ordstr-\@unitthstring{\@tmpstrctr}}%
  \fi
\else
  \ifnum\@strctr=0\relax
    \ifnum#1=0\relax
      \let\@@fc@ordstr#2\relax
      \protected@edef#2{\@@fc@ordstr\@unitstring{0}}%
    \fi
  \else
    \let\@@fc@ordstr#2\relax
    \protected@edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
  \fi
\fi
\fi
\fi
}%
\global\let\@@ordinalstringportuges\@@ordinalstringportuges
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-portuges.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-portuguese.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-portuguese.def}
%    \begin{macrocode}
\ProvidesFCLanguage{portuguese}[2014/06/09]%
%    \end{macrocode}
% Load fc-portuges.def if not already loaded
%    \begin{macrocode}
\FCloadlang{portuges}%
%    \end{macrocode}
% Set |portuguese| to be equivalent to |portuges|.
%    \begin{macrocode}
\global\let\@ordinalMportuguese=\@ordinalMportuges
\global\let\@ordinalFportuguese=\@ordinalFportuges
\global\let\@ordinalNportuguese=\@ordinalNportuges
\global\let\@numberstringMportuguese=\@numberstringMportuges
\global\let\@numberstringFportuguese=\@numberstringFportuges
\global\let\@numberstringNportuguese=\@numberstringNportuges
\global\let\@NumberstringMportuguese=\@NumberstringMportuges
\global\let\@NumberstringFportuguese=\@NumberstringFportuges
\global\let\@NumberstringNportuguese=\@NumberstringNportuges
\global\let\@ordinalstringMportuguese=\@ordinalstringMportuges
\global\let\@ordinalstringFportuguese=\@ordinalstringFportuges
\global\let\@ordinalstringNportuguese=\@ordinalstringNportuges
\global\let\@OrdinalstringMportuguese=\@OrdinalstringMportuges
\global\let\@OrdinalstringFportuguese=\@OrdinalstringFportuges
\global\let\@OrdinalstringNportuguese=\@OrdinalstringNportuges
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-portuguese.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-spanish.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-spanish.def}
% Spanish definitions
%    \begin{macrocode}
\ProvidesFCLanguage{spanish}[2013/08/17]%
%    \end{macrocode}
% Define macro that converts a number or count register (first
% argument) to an ordinal, and stores the result in the
% second argument, which must be a control sequence.
% Masculine:
%    \begin{macrocode}
\newcommand*\@ordinalMspanish[2]{%
  \edef#2{\number#1\relax\noexpand\fmtord{o}}%
}%
\global\let\@ordinalMspanish\@ordinalMspanish
%    \end{macrocode}
% Feminine:
%    \begin{macrocode}
\newcommand{\@ordinalFspanish}[2]{%
  \edef#2{\number#1\relax\noexpand\fmtord{a}}%
}%
\global\let\@ordinalFspanish\@ordinalFspanish
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\global\let\@ordinalNspanish\@ordinalMspanish
%    \end{macrocode}
% Convert a number to text. The easiest way to do this is to
% break it up into units, tens, teens, twenties and hundreds.
% Units (argument must be a number from 0 to 9):
%    \begin{macrocode}
\newcommand*\@@unitstringspanish[1]{%
  \ifcase#1\relax
    cero%
    \or uno%
    \or dos%
    \or tres%
    \or cuatro%
    \or cinco%
    \or seis%
    \or siete%
    \or ocho%
    \or nueve%
  \fi
}%
\global\let\@@unitstringspanish\@@unitstringspanish
%    \end{macrocode}
% Feminine:
%    \begin{macrocode}
\newcommand*\@@unitstringFspanish[1]{%
  \ifcase#1\relax
    cera%
    \or una%
    \or dos%
    \or tres%
    \or cuatro%
    \or cinco%
    \or seis%
    \or siete%
    \or ocho%
    \or nueve%
  \fi
}%
\global\let\@@unitstringFspanish\@@unitstringFspanish
%    \end{macrocode}
% Tens (argument must go from 1 to 10):
%\changes{2.0}{2012-06-18}{fixed spelling mistake (correction
%provided by Fernando Maldonado)}
%    \begin{macrocode}
\newcommand*\@@tenstringspanish[1]{%
  \ifcase#1\relax
    \or diez%
    \or veinte%
    \or treinta%
    \or cuarenta%
    \or cincuenta%
    \or sesenta%
    \or setenta%
    \or ochenta%
    \or noventa%
    \or cien%
  \fi
}%
\global\let\@@tenstringspanish\@@tenstringspanish
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand*\@@teenstringspanish[1]{%
  \ifcase#1\relax
    diez%
    \or once%
    \or doce%
    \or trece%
    \or catorce%
    \or quince%
    \or diecis\'eis%
    \or diecisiete%
    \or dieciocho%
    \or diecinueve%
  \fi
}%
\global\let\@@teenstringspanish\@@teenstringspanish
%    \end{macrocode}
% Twenties:
%    \begin{macrocode}
\newcommand*\@@twentystringspanish[1]{%
  \ifcase#1\relax
    veinte%
    \or veintiuno%
    \or veintid\'os%
    \or veintitr\'es%
    \or veinticuatro%
    \or veinticinco%
    \or veintis\'eis%
    \or veintisiete%
    \or veintiocho%
    \or veintinueve%
  \fi
}%
\global\let\@@twentystringspanish\@@twentystringspanish
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand*\@@twentystringFspanish[1]{%
  \ifcase#1\relax
    veinte%
    \or veintiuna%
    \or veintid\'os%
    \or veintitr\'es%
    \or veinticuatro%
    \or veinticinco%
    \or veintis\'eis%
    \or veintisiete%
    \or veintiocho%
    \or veintinueve%
  \fi
}%
\global\let\@@twentystringFspanish\@@twentystringFspanish
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand*\@@hundredstringspanish[1]{%
  \ifcase#1\relax
    \or ciento%
    \or doscientos%
    \or trescientos%
    \or cuatrocientos%
    \or quinientos%
    \or seiscientos%
    \or setecientos%
    \or ochocientos%
    \or novecientos%
  \fi
}%
\global\let\@@hundredstringspanish\@@hundredstringspanish
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand*\@@hundredstringFspanish[1]{%
  \ifcase#1\relax
    \or cienta%
    \or doscientas%
    \or trescientas%
    \or cuatrocientas%
    \or quinientas%
    \or seiscientas%
    \or setecientas%
    \or ochocientas%
    \or novecientas%
  \fi
}%
\global\let\@@hundredstringFspanish\@@hundredstringFspanish
%    \end{macrocode}
% As above, but with initial letter uppercase:
%    \begin{macrocode}
\newcommand*\@@Unitstringspanish[1]{%
  \ifcase#1\relax
    Cero%
    \or Uno%
    \or Dos%
    \or Tres%
    \or Cuatro%
    \or Cinco%
    \or Seis%
    \or Siete%
    \or Ocho%
    \or Nueve%
  \fi
}%
\global\let\@@Unitstringspanish\@@Unitstringspanish
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand*\@@UnitstringFspanish[1]{%
  \ifcase#1\relax
    Cera%
    \or Una%
    \or Dos%
    \or Tres%
    \or Cuatro%
    \or Cinco%
    \or Seis%
    \or Siete%
    \or Ocho%
    \or Nueve%
  \fi
}%
\global\let\@@UnitstringFspanish\@@UnitstringFspanish
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
%\changes{2.0}{2012-06-18}{fixed spelling mistake (correction
%provided by Fernando Maldonado)}
\newcommand*\@@Tenstringspanish[1]{%
  \ifcase#1\relax
    \or Diez%
    \or Veinte%
    \or Treinta%
    \or Cuarenta%
    \or Cincuenta%
    \or Sesenta%
    \or Setenta%
    \or Ochenta%
    \or Noventa%
    \or Cien%
  \fi
}%
\global\let\@@Tenstringspanish\@@Tenstringspanish
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand*\@@Teenstringspanish[1]{%
  \ifcase#1\relax
    Diez%
    \or Once%
    \or Doce%
    \or Trece%
    \or Catorce%
    \or Quince%
    \or Diecis\'eis%
    \or Diecisiete%
    \or Dieciocho%
    \or Diecinueve%
  \fi
}%
\global\let\@@Teenstringspanish\@@Teenstringspanish
%    \end{macrocode}
% Twenties:
%    \begin{macrocode}
\newcommand*\@@Twentystringspanish[1]{%
  \ifcase#1\relax
    Veinte%
    \or Veintiuno%
    \or Veintid\'os%
    \or Veintitr\'es%
    \or Veinticuatro%
    \or Veinticinco%
    \or Veintis\'eis%
    \or Veintisiete%
    \or Veintiocho%
    \or Veintinueve%
  \fi
}%
\global\let\@@Twentystringspanish\@@Twentystringspanish
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand*\@@TwentystringFspanish[1]{%
  \ifcase#1\relax
    Veinte%
    \or Veintiuna%
    \or Veintid\'os%
    \or Veintitr\'es%
    \or Veinticuatro%
    \or Veinticinco%
    \or Veintis\'eis%
    \or Veintisiete%
    \or Veintiocho%
    \or Veintinueve%
  \fi
}%
\global\let\@@TwentystringFspanish\@@TwentystringFspanish
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand*\@@Hundredstringspanish[1]{%
  \ifcase#1\relax
    \or Ciento%
    \or Doscientos%
    \or Trescientos%
    \or Cuatrocientos%
    \or Quinientos%
    \or Seiscientos%
    \or Setecientos%
    \or Ochocientos%
    \or Novecientos%
  \fi
}%
\global\let\@@Hundredstringspanish\@@Hundredstringspanish
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\newcommand*\@@HundredstringFspanish[1]{%
  \ifcase#1\relax
    \or Cienta%
    \or Doscientas%
    \or Trescientas%
    \or Cuatrocientas%
    \or Quinientas%
    \or Seiscientas%
    \or Setecientas%
    \or Ochocientas%
    \or Novecientas%
  \fi
}%
\global\let\@@HundredstringFspanish\@@HundredstringFspanish
%    \end{macrocode}
% This has changed in version 1.09, so that it now stores the
% result in the second argument, but doesn't display anything.
% Since it only affects internal macros, it shouldn't affect
% documents created with older versions. (These internal macros
% are not meant for use in documents.)
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringMspanish}[2]{%
  \let\@unitstring=\@@unitstringspanish
  \let\@teenstring=\@@teenstringspanish
  \let\@tenstring=\@@tenstringspanish
  \let\@twentystring=\@@twentystringspanish
  \let\@hundredstring=\@@hundredstringspanish
  \def\@hundred{cien}\def\@thousand{mil}%
  \def\@andname{y}%
  \@@numberstringspanish{#1}{#2}%
}%
\global\let\@numberstringMspanish\@numberstringMspanish
%    \end{macrocode}
% Feminine form:
%\changes{2.0}{2012-06-18}{changed andname to `b' (correction
%provided by Fernando Maldonado)}
%    \begin{macrocode}
\DeclareRobustCommand{\@numberstringFspanish}[2]{%
  \let\@unitstring=\@@unitstringFspanish
  \let\@teenstring=\@@teenstringspanish
  \let\@tenstring=\@@tenstringspanish
  \let\@twentystring=\@@twentystringFspanish
  \let\@hundredstring=\@@hundredstringFspanish
  \def\@hundred{cien}\def\@thousand{mil}%
  \def\@andname{b}%
  \@@numberstringspanish{#1}{#2}%
}%
\global\let\@numberstringFspanish\@numberstringFspanish
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\global\let\@numberstringNspanish\@numberstringMspanish
%    \end{macrocode}
% As above, but initial letters in upper case:
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringMspanish}[2]{%
  \let\@unitstring=\@@Unitstringspanish
  \let\@teenstring=\@@Teenstringspanish
  \let\@tenstring=\@@Tenstringspanish
  \let\@twentystring=\@@Twentystringspanish
  \let\@hundredstring=\@@Hundredstringspanish
  \def\@andname{y}%
  \def\@hundred{Cien}\def\@thousand{Mil}%
  \@@numberstringspanish{#1}{#2}%
}%
\global\let\@NumberstringMspanish\@NumberstringMspanish
%    \end{macrocode}
% Feminine form:
%\changes{2.0}{2012-06-18}{changed andname to `b' (correction
%provided by Fernando Maldonado)}
%    \begin{macrocode}
\DeclareRobustCommand{\@NumberstringFspanish}[2]{%
  \let\@unitstring=\@@UnitstringFspanish
  \let\@teenstring=\@@Teenstringspanish
  \let\@tenstring=\@@Tenstringspanish
  \let\@twentystring=\@@TwentystringFspanish
  \let\@hundredstring=\@@HundredstringFspanish
  \def\@andname{b}%
  \def\@hundred{Cien}\def\@thousand{Mil}%
  \@@numberstringspanish{#1}{#2}%
}%
\global\let\@NumberstringFspanish\@NumberstringFspanish
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\global\let\@NumberstringNspanish\@NumberstringMspanish
%    \end{macrocode}
% As above, but for ordinals.
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringMspanish}[2]{%
  \let\@unitthstring=\@@unitthstringspanish
  \let\@unitstring=\@@unitstringspanish
  \let\@teenthstring=\@@teenthstringspanish
  \let\@tenthstring=\@@tenthstringspanish
  \let\@hundredthstring=\@@hundredthstringspanish
  \def\@thousandth{mil\'esimo}%
  \@@ordinalstringspanish{#1}{#2}%
}%
\global\let\@ordinalstringMspanish\@ordinalstringMspanish
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@ordinalstringFspanish}[2]{%
  \let\@unitthstring=\@@unitthstringFspanish
  \let\@unitstring=\@@unitstringFspanish
  \let\@teenthstring=\@@teenthstringFspanish
  \let\@tenthstring=\@@tenthstringFspanish
  \let\@hundredthstring=\@@hundredthstringFspanish
  \def\@thousandth{mil\'esima}%
  \@@ordinalstringspanish{#1}{#2}%
}%
\global\let\@ordinalstringFspanish\@ordinalstringFspanish
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\global\let\@ordinalstringNspanish\@ordinalstringMspanish
%    \end{macrocode}
% As above, but with initial letters in upper case.
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringMspanish}[2]{%
  \let\@unitthstring=\@@Unitthstringspanish
  \let\@unitstring=\@@Unitstringspanish
  \let\@teenthstring=\@@Teenthstringspanish
  \let\@tenthstring=\@@Tenthstringspanish
  \let\@hundredthstring=\@@Hundredthstringspanish
  \def\@thousandth{Mil\'esimo}%
  \@@ordinalstringspanish{#1}{#2}%
}
\global\let\@OrdinalstringMspanish\@OrdinalstringMspanish
%    \end{macrocode}
% Feminine form:
%    \begin{macrocode}
\DeclareRobustCommand{\@OrdinalstringFspanish}[2]{%
  \let\@unitthstring=\@@UnitthstringFspanish
  \let\@unitstring=\@@UnitstringFspanish
  \let\@teenthstring=\@@TeenthstringFspanish
  \let\@tenthstring=\@@TenthstringFspanish
  \let\@hundredthstring=\@@HundredthstringFspanish
  \def\@thousandth{Mil\'esima}%
  \@@ordinalstringspanish{#1}{#2}%
}%
\global\let\@OrdinalstringFspanish\@OrdinalstringFspanish
%    \end{macrocode}
% Make neuter same as masculine:
%    \begin{macrocode}
\global\let\@OrdinalstringNspanish\@OrdinalstringMspanish
%    \end{macrocode}
% Code for convert numbers into textual ordinals. As before,
% it is easier to split it into units, tens, teens and hundreds.
% Units:
%    \begin{macrocode}
\newcommand*\@@unitthstringspanish[1]{%
  \ifcase#1\relax
    cero%
    \or primero%
    \or segundo%
    \or tercero%
    \or cuarto%
    \or quinto%
    \or sexto%
    \or s\'eptimo%
    \or octavo%
    \or noveno%
  \fi
}%
\global\let\@@unitthstringspanish\@@unitthstringspanish
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand*\@@tenthstringspanish[1]{%
  \ifcase#1\relax
    \or d\'ecimo%
    \or vig\'esimo%
    \or trig\'esimo%
    \or cuadrag\'esimo%
    \or quincuag\'esimo%
    \or sexag\'esimo%
    \or septuag\'esimo%
    \or octog\'esimo%
    \or nonag\'esimo%
  \fi
}%
\global\let\@@tenthstringspanish\@@tenthstringspanish
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand*\@@teenthstringspanish[1]{%
  \ifcase#1\relax
    d\'ecimo%
    \or und\'ecimo%
    \or duod\'ecimo%
    \or decimotercero%
    \or decimocuarto%
    \or decimoquinto%
    \or decimosexto%
    \or decimos\'eptimo%
    \or decimoctavo%
    \or decimonoveno%
  \fi
}%
\global\let\@@teenthstringspanish\@@teenthstringspanish
%    \end{macrocode}
% Hundreds:
%    \begin{macrocode}
\newcommand*\@@hundredthstringspanish[1]{%
  \ifcase#1\relax
    \or cent\'esimo%
    \or ducent\'esimo%
    \or tricent\'esimo%
    \or cuadringent\'esimo%
    \or quingent\'esimo%
    \or sexcent\'esimo%
    \or septing\'esimo%
    \or octingent\'esimo%
    \or noningent\'esimo%
  \fi
}%
\global\let\@@hundredthstringspanish\@@hundredthstringspanish
%    \end{macrocode}
% Units (feminine):
%    \begin{macrocode}
\newcommand*\@@unitthstringFspanish[1]{%
  \ifcase#1\relax
    cera%
    \or primera%
    \or segunda%
    \or tercera%
    \or cuarta%
    \or quinta%
    \or sexta%
    \or s\'eptima%
    \or octava%
    \or novena%
  \fi
}%
\global\let\@@unitthstringFspanish\@@unitthstringFspanish
%    \end{macrocode}
% Tens (feminine):
%    \begin{macrocode}
\newcommand*\@@tenthstringFspanish[1]{%
  \ifcase#1\relax
    \or d\'ecima%
    \or vig\'esima%
    \or trig\'esima%
    \or cuadrag\'esima%
    \or quincuag\'esima%
    \or sexag\'esima%
    \or septuag\'esima%
    \or octog\'esima%
    \or nonag\'esima%
  \fi
}%
\global\let\@@tenthstringFspanish\@@tenthstringFspanish
%    \end{macrocode}
% Teens (feminine)
%    \begin{macrocode}
\newcommand*\@@teenthstringFspanish[1]{%
  \ifcase#1\relax
    d\'ecima%
    \or und\'ecima%
    \or duod\'ecima%
    \or decimotercera%
    \or decimocuarta%
    \or decimoquinta%
    \or decimosexta%
    \or decimos\'eptima%
    \or decimoctava%
    \or decimonovena%
  \fi
}%
\global\let\@@teenthstringFspanish\@@teenthstringFspanish
%    \end{macrocode}
% Hundreds (feminine)
%    \begin{macrocode}
\newcommand*\@@hundredthstringFspanish[1]{%
  \ifcase#1\relax
    \or cent\'esima%
    \or ducent\'esima%
    \or tricent\'esima%
    \or cuadringent\'esima%
    \or quingent\'esima%
    \or sexcent\'esima%
    \or septing\'esima%
    \or octingent\'esima%
    \or noningent\'esima%
  \fi
}%
\global\let\@@hundredthstringFspanish\@@hundredthstringFspanish
%    \end{macrocode}
% As above, but with initial letters in upper case
%    \begin{macrocode}
\newcommand*\@@Unitthstringspanish[1]{%
  \ifcase#1\relax
    Cero%
    \or Primero%
    \or Segundo%
    \or Tercero%
    \or Cuarto%
    \or Quinto%
    \or Sexto%
    \or S\'eptimo%
    \or Octavo%
    \or Noveno%
  \fi
}%
\global\let\@@Unitthstringspanish\@@Unitthstringspanish
%    \end{macrocode}
% Tens:
%    \begin{macrocode}
\newcommand*\@@Tenthstringspanish[1]{%
  \ifcase#1\relax
    \or D\'ecimo%
    \or Vig\'esimo%
    \or Trig\'esimo%
    \or Cuadrag\'esimo%
    \or Quincuag\'esimo%
    \or Sexag\'esimo%
    \or Septuag\'esimo%
    \or Octog\'esimo%
    \or Nonag\'esimo%
  \fi
}%
\global\let\@@Tenthstringspanish\@@Tenthstringspanish
%    \end{macrocode}
% Teens:
%    \begin{macrocode}
\newcommand*\@@Teenthstringspanish[1]{%
  \ifcase#1\relax
    D\'ecimo%
    \or Und\'ecimo%
    \or Duod\'ecimo%
    \or Decimotercero%
    \or Decimocuarto%
    \or Decimoquinto%
    \or Decimosexto%
    \or Decimos\'eptimo%
    \or Decimoctavo%
    \or Decimonoveno%
  \fi
}%
\global\let\@@Teenthstringspanish\@@Teenthstringspanish
%    \end{macrocode}
% Hundreds
%    \begin{macrocode}
\newcommand*\@@Hundredthstringspanish[1]{%
  \ifcase#1\relax
    \or Cent\'esimo%
    \or Ducent\'esimo%
    \or Tricent\'esimo%
    \or Cuadringent\'esimo%
    \or Quingent\'esimo%
    \or Sexcent\'esimo%
    \or Septing\'esimo%
    \or Octingent\'esimo%
    \or Noningent\'esimo%
  \fi
}%
\global\let\@@Hundredthstringspanish\@@Hundredthstringspanish
%    \end{macrocode}
% As above, but feminine.
%    \begin{macrocode}
\newcommand*\@@UnitthstringFspanish[1]{%
  \ifcase#1\relax
    Cera%
    \or Primera%
    \or Segunda%
    \or Tercera%
    \or Cuarta%
    \or Quinta%
    \or Sexta%
    \or S\'eptima%
    \or Octava%
    \or Novena%
  \fi
}%
\global\let\@@UnitthstringFspanish\@@UnitthstringFspanish
%    \end{macrocode}
% Tens (feminine)
%    \begin{macrocode}
\newcommand*\@@TenthstringFspanish[1]{%
  \ifcase#1\relax
    \or D\'ecima%
    \or Vig\'esima%
    \or Trig\'esima%
    \or Cuadrag\'esima%
    \or Quincuag\'esima%
    \or Sexag\'esima%
    \or Septuag\'esima%
    \or Octog\'esima%
    \or Nonag\'esima%
  \fi
}%
\global\let\@@TenthstringFspanish\@@TenthstringFspanish
%    \end{macrocode}
% Teens (feminine):
%    \begin{macrocode}
\newcommand*\@@TeenthstringFspanish[1]{%
  \ifcase#1\relax
    D\'ecima%
    \or Und\'ecima%
    \or Duod\'ecima%
    \or Decimotercera%
    \or Decimocuarta%
    \or Decimoquinta%
    \or Decimosexta%
    \or Decimos\'eptima%
    \or Decimoctava%
    \or Decimonovena%
  \fi
}%
\global\let\@@TeenthstringFspanish\@@TeenthstringFspanish
%    \end{macrocode}
% Hundreds (feminine):
%    \begin{macrocode}
\newcommand*\@@HundredthstringFspanish[1]{%
  \ifcase#1\relax
    \or Cent\'esima%
    \or Ducent\'esima%
    \or Tricent\'esima%
    \or Cuadringent\'esima%
    \or Quingent\'esima%
    \or Sexcent\'esima%
    \or Septing\'esima%
    \or Octingent\'esima%
    \or Noningent\'esima%
  \fi
}%
\global\let\@@HundredthstringFspanish\@@HundredthstringFspanish
%    \end{macrocode}
% This has changed in version 1.09, so that it now stores the
% results in the second argument (which must be a control
% sequence), but it doesn't display anything. Since it only
% affects internal macros, it shouldn't affect documnets created
% with older versions. (These internal macros are not meant for
% use in documents.)
%    \begin{macrocode}
\newcommand*\@@numberstringspanish[2]{%
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\fi
\fi
\def#2{}%
\@strctr=#1\relax \divide\@strctr by 1000\relax
\ifnum\@strctr>9
%    \end{macrocode}
% \#1 is greater or equal to 10000
%    \begin{macrocode}
  \divide\@strctr by 10
  \ifnum\@strctr>1
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
    \@strctr=#1 \divide\@strctr by 1000\relax
    \@FCmodulo{\@strctr}{10}%
    \ifnum\@strctr>0\relax
       \let\@@fc@numstr#2\relax
       \edef#2{\@@fc@numstr\ \@andname\ \@unitstring{\@strctr}}%
    \fi
  \else
    \@strctr=#1\relax
    \divide\@strctr by 1000\relax
    \@FCmodulo{\@strctr}{10}%
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
  \fi
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\ \@thousand}%
\else
  \ifnum\@strctr>0\relax
    \ifnum\@strctr>1\relax
       \let\@@fc@numstr#2\relax
       \edef#2{\@@fc@numstr\@unitstring{\@strctr}\ }%
    \fi
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@thousand}%
  \fi
\fi
\@strctr=#1\relax \@FCmodulo{\@strctr}{1000}%
\divide\@strctr by 100\relax
\ifnum\@strctr>0\relax
  \ifnum#1>1000\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ }%
  \fi
  \@tmpstrctr=#1\relax
  \@FCmodulo{\@tmpstrctr}{1000}%
  \ifnum\@tmpstrctr=100\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@tenstring{10}}%
  \else
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\@hundredstring{\@strctr}}%
  \fi
\fi
\@strctr=#1\relax \@FCmodulo{\@strctr}{100}%
\ifnum#1>100\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
%    \end{macrocode}
%\changes{2.0}{2012-06-18}{removed andname (correction
%provided by Fernando Maldonado)}
%    \begin{macrocode}
    \edef#2{\@@fc@numstr\ }%
  \fi
\fi
\ifnum\@strctr>29\relax
  \divide\@strctr by 10\relax
  \let\@@fc@numstr#2\relax
  \edef#2{\@@fc@numstr\@tenstring{\@strctr}}%
  \@strctr=#1\relax \@FCmodulo{\@strctr}{10}%
  \ifnum\@strctr>0\relax
    \let\@@fc@numstr#2\relax
    \edef#2{\@@fc@numstr\ \@andname\ \@unitstring{\@strctr}}%
  \fi
\else
  \ifnum\@strctr<10\relax
    \ifnum\@strctr=0\relax
      \ifnum#1<100\relax
        \let\@@fc@numstr#2\relax
        \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
      \fi
    \else
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@unitstring{\@strctr}}%
    \fi
  \else
    \ifnum\@strctr>19\relax
      \@FCmodulo{\@strctr}{10}%
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@twentystring{\@strctr}}%
    \else
      \@FCmodulo{\@strctr}{10}%
      \let\@@fc@numstr#2\relax
      \edef#2{\@@fc@numstr\@teenstring{\@strctr}}%
    \fi
  \fi
\fi
}%
\global\let\@@numberstringspanish\@@numberstringspanish
%    \end{macrocode}
% As above, but for ordinals
%    \begin{macrocode}
\newcommand*\@@ordinalstringspanish[2]{%
\@strctr=#1\relax
\ifnum#1>99999
\PackageError{fmtcount}{Out of range}%
{This macro only works for values less than 100000}%
\else
\ifnum#1<0
\PackageError{fmtcount}{Negative numbers not permitted}%
{This macro does not work for negative numbers, however
you can try typing "minus" first, and then pass the modulus of
this number}%
\else
\def#2{}%
\ifnum\@strctr>999\relax
  \divide\@strctr by 1000\relax
  \ifnum\@strctr>1\relax
    \ifnum\@strctr>9\relax
      \@tmpstrctr=\@strctr
      \ifnum\@strctr<20
        \@FCmodulo{\@tmpstrctr}{10}%
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@teenthstring{\@tmpstrctr}}%
      \else
        \divide\@tmpstrctr by 10\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@tenthstring{\@tmpstrctr}}%
        \@tmpstrctr=\@strctr
        \@FCmodulo{\@tmpstrctr}{10}%
        \ifnum\@tmpstrctr>0\relax
          \let\@@fc@ordstr#2\relax
          \edef#2{\@@fc@ordstr\@unitthstring{\@tmpstrctr}}%
        \fi
      \fi
    \else
       \let\@@fc@ordstr#2\relax
       \edef#2{\@@fc@ordstr\@unitstring{\@strctr}}%
    \fi
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@thousandth}%
\fi
\@strctr=#1\relax
\@FCmodulo{\@strctr}{1000}%
\ifnum\@strctr>99\relax
  \@tmpstrctr=\@strctr
  \divide\@tmpstrctr by 100\relax
  \ifnum#1>1000\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ }%
  \fi
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@hundredthstring{\@tmpstrctr}}%
\fi
\@FCmodulo{\@strctr}{100}%
\ifnum#1>99\relax
  \ifnum\@strctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ }%
  \fi
\fi
\ifnum\@strctr>19\relax
  \@tmpstrctr=\@strctr
  \divide\@tmpstrctr by 10\relax
  \let\@@fc@ordstr#2\relax
  \edef#2{\@@fc@ordstr\@tenthstring{\@tmpstrctr}}%
  \@tmpstrctr=\@strctr
  \@FCmodulo{\@tmpstrctr}{10}%
  \ifnum\@tmpstrctr>0\relax
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\ \@unitthstring{\@tmpstrctr}}%
  \fi
\else
  \ifnum\@strctr>9\relax
    \@FCmodulo{\@strctr}{10}%
    \let\@@fc@ordstr#2\relax
    \edef#2{\@@fc@ordstr\@teenthstring{\@strctr}}%
  \else
    \ifnum\@strctr=0\relax
      \ifnum#1=0\relax
        \let\@@fc@ordstr#2\relax
        \edef#2{\@@fc@ordstr\@unitstring{0}}%
      \fi
    \else
      \let\@@fc@ordstr#2\relax
      \edef#2{\@@fc@ordstr\@unitthstring{\@strctr}}%
    \fi
  \fi
\fi
\fi
\fi
}%
\global\let\@@ordinalstringspanish\@@ordinalstringspanish
%    \end{macrocode}

%\iffalse
%    \begin{macrocode}
%</fc-spanish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-UKenglish.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-UKenglish.def}
% English definitions
%    \begin{macrocode}
\ProvidesFCLanguage{UKenglish}[2013/08/17]%
%    \end{macrocode}
% Loaded fc-english.def if not already loaded
%    \begin{macrocode}
\FCloadlang{english}%
%    \end{macrocode}
% These are all just synonyms for the commands provided by
% fc-english.def.
%    \begin{macrocode}
\global\let\@ordinalMUKenglish\@ordinalMenglish
\global\let\@ordinalFUKenglish\@ordinalMenglish
\global\let\@ordinalNUKenglish\@ordinalMenglish
\global\let\@numberstringMUKenglish\@numberstringMenglish
\global\let\@numberstringFUKenglish\@numberstringMenglish
\global\let\@numberstringNUKenglish\@numberstringMenglish
\global\let\@NumberstringMUKenglish\@NumberstringMenglish
\global\let\@NumberstringFUKenglish\@NumberstringMenglish
\global\let\@NumberstringNUKenglish\@NumberstringMenglish
\global\let\@ordinalstringMUKenglish\@ordinalstringMenglish
\global\let\@ordinalstringFUKenglish\@ordinalstringMenglish
\global\let\@ordinalstringNUKenglish\@ordinalstringMenglish
\global\let\@OrdinalstringMUKenglish\@OrdinalstringMenglish
\global\let\@OrdinalstringFUKenglish\@OrdinalstringMenglish
\global\let\@OrdinalstringNUKenglish\@OrdinalstringMenglish
%    \end{macrocode} 
%\iffalse
%    \begin{macrocode}
%</fc-UKenglish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fc-USenglish.def>
%    \end{macrocode}
%\fi
% \subsubsection{fc-USenglish.def}
% US English definitions
%    \begin{macrocode}
\ProvidesFCLanguage{USenglish}[2013/08/17]%
%    \end{macrocode}
% Loaded fc-english.def if not already loaded
%    \begin{macrocode}
\FCloadlang{english}%
%    \end{macrocode}
% These are all just synonyms for the commands provided by
% fc-english.def. (This needs fixing as there are some differences
% between UK and US number strings.)
%    \begin{macrocode}
\global\let\@ordinalMUSenglish\@ordinalMenglish
\global\let\@ordinalFUSenglish\@ordinalMenglish
\global\let\@ordinalNUSenglish\@ordinalMenglish
\global\let\@numberstringMUSenglish\@numberstringMenglish
\global\let\@numberstringFUSenglish\@numberstringMenglish
\global\let\@numberstringNUSenglish\@numberstringMenglish
\global\let\@NumberstringMUSenglish\@NumberstringMenglish
\global\let\@NumberstringFUSenglish\@NumberstringMenglish
\global\let\@NumberstringNUSenglish\@NumberstringMenglish
\global\let\@ordinalstringMUSenglish\@ordinalstringMenglish
\global\let\@ordinalstringFUSenglish\@ordinalstringMenglish
\global\let\@ordinalstringNUSenglish\@ordinalstringMenglish
\global\let\@OrdinalstringMUSenglish\@OrdinalstringMenglish
\global\let\@OrdinalstringFUSenglish\@OrdinalstringMenglish
\global\let\@OrdinalstringNUSenglish\@OrdinalstringMenglish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</fc-USenglish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fcnumparser.sty>
%    \end{macrocode}
%\fi
%\subsection{fcnumparser.sty}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{fcnumparser}[2012/09/28]
%    \end{macrocode}
% \cs{fc@counter@parser} is just a shorthand to parse a number held in a counter.
%    \begin{macrocode}
\def\fc@counter@parser#1{%
  \expandafter\fc@number@parser\expandafter{\the#1.}%
}
%    \end{macrocode}
%    \begin{macrocode}
\newcount\fc@digit@counter

\def\fc@end@{\fc@end}
%    \end{macrocode}
% \DescribeMacro{\fc@number@analysis} First of all we need to separate the number between integer and fractional
% part. Number to be analysed is in `\texttt{\#1}'. Decimal separator may be . or , whichever first. At end of
% this macro, integer part goes to \cs{fc@integer@part} and fractional part goes to \cs{fc@fractional@part}.
%    \begin{macrocode}
\def\fc@number@analysis#1\fc@nil{%
%    \end{macrocode}
% First check for the presence of a decimal point in the number.
%    \begin{macrocode}
  \def\@tempb##1.##2\fc@nil{\def\fc@integer@part{##1}\def\@tempa{##2}}%
  \@tempb#1.\fc@end\fc@nil
  \ifx\@tempa\fc@end@
%    \end{macrocode}
% Here \cs{@tempa} is \cs{ifx}-equal to \cs{fc@end}, which means that the number does not contain any decimal
% point. So we do the same trick to search for a comma.
%    \begin{macrocode}
    \def\@tempb##1,##2\fc@nil{\def\fc@integer@part{##1}\def\@tempa{##2}}%
    \@tempb#1,\fc@end\fc@nil
    \ifx\@tempa\fc@end@
%    \end{macrocode}
% No comma either, so fractional part is set empty.
%    \begin{macrocode}
       \def\fc@fractional@part{}%
    \else
%    \end{macrocode}
% Comma has been found, so we just need to drop `\texttt{,}\cs{fc@end}' from the end of \cs{@tempa} to get the
% fractional part.
%    \begin{macrocode}
       \def\@tempb##1,\fc@end{\def\fc@fractional@part{##1}}%
       \expandafter\@tempb\@tempa
    \fi
  \else
%    \end{macrocode}
% Decimal point has been found, so we just need to drop `\texttt{.}\cs{fc@end}' from the end \cs{@tempa} to
% get the fractional part.
%    \begin{macrocode}
       \def\@tempb##1.\fc@end{\def\fc@fractional@part{##1}}%
       \expandafter\@tempb\@tempa
  \fi
}
%    \end{macrocode}
% \DescribeMacro{\fc@number@parser} Macro \cs{fc@number@parser} is the main engine to parse a number.  Argument
% `\#1' is input and contains the number to be parsed. At end of this macro, each digit is stored separately
% in a \cs{fc@digit@}\meta{$n$}, and macros \cs{fc@min@weight} and \cs{fc@max@weight} are set to the bounds
% for \meta{$n$}.
%    \begin{macrocode}
\def\fc@number@parser#1{%
%    \end{macrocode}
% First remove all the spaces in \texttt{\#1}, and place the result into \cs{@tempa}.
%    \begin{macrocode}
  \let\@tempa\@empty
  \def\@tempb##1##2\fc@nil{%
    \def\@tempc{##1}%
    \ifx\@tempc\space
    \else
      \expandafter\def\expandafter\@tempa\expandafter{\@tempa ##1}%
    \fi
    \def\@tempc{##2}%
    \ifx\@tempc\@empty
      \expandafter\@gobble
    \else
      \expandafter\@tempb
    \fi
    ##2\fc@nil
  }%
  \@tempb#1\fc@nil
%    \end{macrocode}
% Get the sign into \cs{fc@sign} and the unsigned number part into \cs{fc@number}.
%    \begin{macrocode}
  \def\@tempb##1##2\fc@nil{\def\fc@sign{##1}\def\fc@number{##2}}%
  \expandafter\@tempb\@tempa\fc@nil
  \expandafter\if\fc@sign+%
    \def\fc@sign@case{1}%
  \else
    \expandafter\if\fc@sign-%
      \def\fc@sign@case{2}%
    \else
      \def\fc@sign{}%
      \def\fc@sign@case{0}%
      \let\fc@number\@tempa
    \fi
  \fi
  \ifx\fc@number\@empty
    \PackageError{fcnumparser}{Invalid number}{Number must contain at least one non blank
      character after sign}%
  \fi
%    \end{macrocode}
% Now, split \cs{fc@number} into \cs{fc@integer@part} and \cs{fc@fractional@part}.
%    \begin{macrocode}
  \expandafter\fc@number@analysis\fc@number\fc@nil
%    \end{macrocode}
% Now, split \cs{fc@integer@part} into a sequence of \cs{fc@digit@}\meta{$n$} with \meta{$n$} ranging from
% \cs{fc@unit@weight} to \cs{fc@max@weight}. We will use macro \cs{fc@parse@integer@digits} for that, but that
% will place the digits into \cs{fc@digit@}\meta{$n$} with \meta{$n$} ranging from
% \(2\times\cs{fc@unit@weight}-\cs{fc@max@weight}\) upto \(\cs{fc@unit@weight}-1\).
%    \begin{macrocode}
  \expandafter\fc@digit@counter\fc@unit@weight
  \expandafter\fc@parse@integer@digits\fc@integer@part\fc@end\fc@nil
%    \end{macrocode}
% First we compute the weight of the most significant digit: after \cs{fc@parse@integer@digits},
% \cs{fc@digit@counter} is equal to \(\cs{fc@unit@weight} -\mathrm{mw} -1\) and we want to set
% \cs{fc@max@weight} to \(\cs{fc@unit@weight} +\mathrm{mw}\) so we do:
% \begin{equation*}
% \cs{fc@max@weight}\leftarrow (-\cs{fc@digit@counter}) + 2\times\cs{fc@unit@weight} -1
% \end{equation*}
%    \begin{macrocode}
  \fc@digit@counter -\fc@digit@counter
  \advance\fc@digit@counter by \fc@unit@weight
  \advance\fc@digit@counter by \fc@unit@weight
  \advance\fc@digit@counter by -1 %
  \edef\fc@max@weight{\the\fc@digit@counter}%
%    \end{macrocode}
% Now we loop for \(i = \cs{fc@unit@weight}\) to \cs{fc@max@weight} in order to copy all the digits from
% \cs{fc@digit@}\meta{\(i + \mathrm{offset}\)} to \cs{fc@digit@}\meta{\(i\)}. First we compute
% \(\mathrm{offset}\) into \cs{@tempi}.
%    \begin{macrocode}
  {%
    \count0 \fc@unit@weight\relax
    \count1 \fc@max@weight\relax
    \advance\count0 by -\count1 %
    \advance\count0 by -1 %
    \def\@tempa##1{\def\@tempb{\def\@tempi{##1}}}%
    \expandafter\@tempa\expandafter{\the\count0}%
    \expandafter
  }\@tempb
%    \end{macrocode}
% Now we loop to copy the digits. To do that we define a macro \cs{@templ} for terminal recursion.
%    \begin{macrocode}
  \expandafter\fc@digit@counter\fc@unit@weight
  \def\@templ{%
     \ifnum\fc@digit@counter>\fc@max@weight
        \let\next\relax
     \else
%    \end{macrocode}
% Here is the loop body:
%    \begin{macrocode}
        {%
          \count0 \@tempi
          \advance\count0 by \fc@digit@counter
          \expandafter\def\expandafter\@tempd\expandafter{\csname fc@digit@\the\count0\endcsname}%
          \expandafter\def\expandafter\@tempe\expandafter{\csname fc@digit@\the\fc@digit@counter\endcsname}%
          \def\@tempa####1####2{\def\@tempb{\let####1####2}}%
          \expandafter\expandafter\expandafter\@tempa\expandafter\@tempe\@tempd
          \expandafter
        }\@tempb
        \advance\fc@digit@counter by 1 %
     \fi
     \next
  }%
  \let\next\@templ
  \@templ
%    \end{macrocode}
% Split \cs{fc@fractional@part} into a sequence of \cs{fc@digit@}\meta{$n$} with \meta{$n$} ranging from
% \(\cs{fc@unit@weight}-1\) to \cs{fc@min@weight} by step of \(-1\). This is much more simpler because we get
% the digits with the final range of index, so no post-processing loop is needed.
%    \begin{macrocode}
  \expandafter\fc@digit@counter\fc@unit@weight
  \expandafter\fc@parse@integer@digits\fc@fractional@part\fc@end\fc@nil
  \edef\fc@min@weight{\the\fc@digit@counter}%
}
%    \end{macrocode}
% \DescribeMacro{\fc@parse@integer@digits} Macro \cs{fc@parse@integer@digits} is used to 
%    \begin{macrocode}
\ifcsundef{fc@parse@integer@digits}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of 
    macro `fc@parse@integer@digits'}}
\def\fc@parse@integer@digits#1#2\fc@nil{%
  \def\@tempa{#1}%
  \ifx\@tempa\fc@end@
     \def\next##1\fc@nil{}%
  \else
  \let\next\fc@parse@integer@digits
  \advance\fc@digit@counter by -1
  \expandafter\def\csname fc@digit@\the\fc@digit@counter\endcsname{#1}%
  \fi
  \next#2\fc@nil
}


\newcommand*{\fc@unit@weight}{0}

%    \end{macrocode}
% Now we have macros to read a few digits from the \cs{fc@digit@}\meta{$n$} array and form a correspoding
% number.\newline \DescribeMacro{\fc@read@unit} \cs{fc@read@unit} just reads one digit and form an integer in
% the range \([0 \intv 9]\). First we check that the macro is not yet defined.
%    \begin{macrocode}
\ifcsundef{fc@read@unit}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of macro `fc@read@unit'}}
%    \end{macrocode}
% Arguments as follows:\def\interface{\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&output counter: into which the read value is placed\\
% \#2&input number: unit weight at which reach the value is to be read
% \end{tabularx}}\interface
% \#2 does not need to be comprised between \cs{fc@min@weight} and {fc@min@weight}, if outside this interval,
% then a zero is read.
%    \begin{macrocode}
\def\fc@read@unit#1#2{%
  \ifnum#2>\fc@max@weight
     #1=0\relax
  \else
     \ifnum#2<\fc@min@weight
        #1=0\relax
     \else
         {%
           \edef\@tempa{\number#2}%
           \count0=\@tempa
           \edef\@tempa{\csname fc@digit@\the\count0\endcsname}%
           \def\@tempb##1{\def\@tempa{#1=##1\relax}}%
           \expandafter\@tempb\expandafter{\@tempa}%
           \expandafter
         }\@tempa
     \fi
  \fi
}
%    \end{macrocode}
% \DescribeMacro{\fc@read@hundred} Macro \cs{fc@read@hundred} is used to read a pair of digits and form an
% integer in the range \([0 \intv 99]\).  First we check that the macro is not yet defined.
%    \begin{macrocode}
\ifcsundef{fc@read@hundred}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of macro `fc@read@hundred'}}
%    \end{macrocode}
% Arguments as follows --- same interface as \cs{fc@read@unit}:\interface
%    \begin{macrocode}
\def\fc@read@hundred#1#2{%
  {%
    \fc@read@unit{\count0}{#2}%
    \def\@tempa##1{\fc@read@unit{\count1}{##1}}%
    \count2=#2%
    \advance\count2 by 1 %
    \expandafter\@tempa{\the\count2}%
    \multiply\count1 by 10 %
    \advance\count1 by \count0 %
    \def\@tempa##1{\def\@tempb{#1=##1\relax}}
    \expandafter\@tempa\expandafter{\the\count1}%
    \expandafter
  }\@tempb
}
%    \end{macrocode}
% \DescribeMacro{\fc@read@thousand} Macro \cs{fc@read@thousand} is used to read a trio of digits and form an
% integer in the range \([0 \intv 999]\).  First we check that the macro is not yet defined.
%    \begin{macrocode}
\ifcsundef{fc@read@thousand}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of macro
    `fc@read@thousand'}}
%    \end{macrocode}
% Arguments as follows --- same interface as \cs{fc@read@unit}:\interface
%    \begin{macrocode}
\def\fc@read@thousand#1#2{%
  {%
    \fc@read@unit{\count0}{#2}%
    \def\@tempa##1{\fc@read@hundred{\count1}{##1}}%
    \count2=#2%
    \advance\count2 by 1 %
    \expandafter\@tempa{\the\count2}%
    \multiply\count1 by 10 %
    \advance\count1 by \count0 %
    \def\@tempa##1{\def\@tempb{#1=##1\relax}}
    \expandafter\@tempa\expandafter{\the\count1}%
    \expandafter
  }\@tempb
}
%    \end{macrocode}
% Note: one myriad is ten thousand.
% \DescribeMacro{\fc@read@thousand} Macro \cs{fc@read@myriad} is used to read a quatuor of digits and form an
% integer in the range \([0 \intv 9999]\).  First we check that the macro is not yet defined.
%    \begin{macrocode}
\ifcsundef{fc@read@myriad}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of macro
    `fc@read@myriad'}}
%    \end{macrocode}
% Arguments as follows --- same interface as \cs{fc@read@unit}:\interface
%    \begin{macrocode}
\def\fc@read@myriad#1#2{%
  {%
    \fc@read@hundred{\count0}{#2}%
    \def\@tempa##1{\fc@read@hundred{\count1}{##1}}%
    \count2=#2
    \advance\count2 by 2
    \expandafter\@tempa{\the\count2}%
    \multiply\count1 by 100 %
    \advance\count1 by \count0 %
    \def\@tempa##1{\def\@tempb{#1=##1\relax}}%
    \expandafter\@tempa\expandafter{\the\count1}%
    \expandafter
  }\@tempb
}
%    \end{macrocode}
% \DescribeMacro{\fc@check@nonzeros} Macro \cs{fc@check@nonzeros} is used to check whether the number
% represented by digits \cs{fc@digit@}\meta{$n$}, with \(n\) in some interval, is zero, one, or more than one.
% First we check that the macro is not yet defined.
%    \begin{macrocode}
\ifcsundef{fc@check@nonzeros}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of macro
    `fc@check@nonzeros'}}
%    \end{macrocode}
% Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#1&input number: minimum unit unit weight at which start to search the non-zeros\\
%   \#2&input number: maximum unit weight at which end to seach the non-zeros\\
%   \#3&output macro: let \(n\) be the number represented by digits the weight of which span from \texttt{\#1}
%   to \texttt{\#2}, then \texttt{\#3} is set to the number min(n,9).\\
% \end{tabularx}
% Actually \cs{fc@check@nonzeros} is just a wrapper to collect arguments, and the real job is delegated to
% \cs{fc@@check@nonzeros@inner} which is called inside a group. 
%    \begin{macrocode}
\def\fc@check@nonzeros#1#2#3{%
  {%
%    \end{macrocode}
% So first we save inputs into local macros used by \cs{fc@@check@nonzeros@inner} as input arguments
%    \begin{macrocode}
    \edef\@@tempa{\number#1}%
    \edef\@tempb{\number#2}%
    \count0=\@@tempa
    \count1=\@tempb\relax
%    \end{macrocode}
% Then we do the real job
%    \begin{macrocode}
   \fc@@check@nonzeros@inner
%    \end{macrocode}
% And finally, we propagate the output after end of group --- i.e. closing brace.
%    \begin{macrocode}
   \def\@tempd##1{\def\@tempa{\def#3{##1}}}%
   \expandafter\@tempd\expandafter{\@tempc}%
   \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro{\fc@@check@nonzeros@inner} Macro \cs{fc@@check@nonzeros@inner} Check wehther some part of the
% parsed value contains some non-zero digit At the call of this macro we expect that:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash}rX@{}}
%   \cs{@tempa}&input/output macro:\newline\noindent
%   \settowidth{\tabcolwidth}{output}%
%   \begin{tabular*}{\hsize}{@{}>{\raggedleft\arraybackslash\itshape}r%
%     p{\dimexpr\hsize-2\tabcolsep-\tabcolwidth}@{}}
%     input&minimum unit unit weight at which start to search the non-zeros\\
%     output&macro may have been redefined
%   \end{tabular*}\\
%   \cs{@tempb}&input/output macro:\newline\noindent
%   \settowidth{\tabcolwidth}{output}%
%   \begin{tabular*}{\hsize}{@{}>{\raggedleft\arraybackslash\itshape}r%
%     p{\dimexpr\hsize-2\tabcolsep-\tabcolwidth}@{}}
% input&maximum unit weight at which end to seach the non-zeros\\
% output&macro may have been redefined
% \end{tabular*}\\
% \cs{@tempc}&ouput macro: 0 if all-zeros, 1 if at least one zero is found\\
% \cs{count0}&output counter: \(\mathrm{weight}+1\) of the first found non zero starting from minimum
% \(\mathrm{weight}\).
% \end{tabularx}
%    \begin{macrocode}
\def\fc@@check@nonzeros@inner{%
   \ifnum\count0<\fc@min@weight
      \count0=\fc@min@weight\relax
   \fi
   \ifnum\count1>\fc@max@weight\relax
      \count1=\fc@max@weight
   \fi
   \count2\count0 %
   \advance\count2 by 1 %
   \ifnum\count0>\count1 %
     \PackageError{fcnumparser}{Unexpected arguments}{Number in argument 2 of macro
       `fc@check@nonzeros' must be at least equal to number in argument 1}%
   \else
     \fc@@check@nonzeros@inner@loopbody
     \ifnum\@tempc>0 %
       \ifnum\@tempc<9 %
         \ifnum\count0>\count1 %
         \else
           \let\@tempd\@tempc
           \fc@@check@nonzeros@inner@loopbody
           \ifnum\@tempc=0 %
             \let\@tempc\@tempd
           \else
             \def\@tempc{9}%
           \fi
         \fi
       \fi
     \fi
   \fi
}
%    \end{macrocode}
%    \begin{macrocode}
\def\fc@@check@nonzeros@inner@loopbody{%
   % \@tempc <-  digit of weight \count0
   \expandafter\let\expandafter\@tempc\csname fc@digit@\the\count0\endcsname
   \advance\count0 by 1 %
   \ifnum\@tempc=0 %
      \ifnum\count0>\count1 %
        \let\next\relax
      \else
        \let\next\fc@@check@nonzeros@inner@loopbody
      \fi
   \else
      \ifnum\count0>\count2 %
        \def\@tempc{9}%
      \fi
      \let\next\relax
   \fi
   \next
}
%    \end{macrocode}
% \DescribeMacro{\fc@intpart@find@last} Macro \cs{fc@intpart@find@last} find the rightmost non zero digit in the
% integer part. First check that the macro is not yet defined.
%    \begin{macrocode}
\ifcsundef{fc@intpart@find@last}{}{%
  \PackageError{fcnumparser}{Duplicate definition}{Redefinition of macro
    `fc@intpart@find@last'}}
%    \end{macrocode}
% When macro is called, the number of interest is already parsed, that is to say each digit of weight \(w\) is
% stored in macro \cs{fc@digit@}\meta{$w$}.  Macro \cs{fc@intpart@find@last} takes one single argument which
% is a counter to set to the result.
%    \begin{macrocode}
\def\fc@intpart@find@last#1{%
  {%
%    \end{macrocode}
% Counter \cs{count0} will hold the result. So we will loop on \cs{count0}, starting from
% \(\min\{u,w_{\mathrm{min}}\}\), where \(u\triangleq\cs{fc@unit@weight}\), and
% \(w_{\mathrm{min}}\triangleq\cs{fc@min@weight}\). So first set \cs{count0} to
% \(\min\{u,w_{\mathrm{min}}\}\):
%    \begin{macrocode}
    \count0=\fc@unit@weight\space
    \ifnum\count0<\fc@min@weight\space
      \count0=\fc@min@weight\space
    \fi
%    \end{macrocode}
% Now the loop. This is done by defining macro \cs{@templ} for final recursion.
%    \begin{macrocode}
    \def\@templ{%
      \ifnum\csname fc@digit@\the\count0\endcsname=0 %
        \advance\count0 by 1 %
        \ifnum\count0>\fc@max@weight\space
          \let\next\relax
        \fi
      \else
        \let\next\relax
      \fi
      \next
    }%
    \let\next\@templ
    \@templ
%    \end{macrocode}
% Now propagate result after closing bracket into counter \texttt{\#1}.
%    \begin{macrocode}
     \toks0{#1}%
     \edef\@tempa{\the\toks0=\the\count0}%
     \expandafter
  }\@tempa\space
}
%    \end{macrocode}
% \DescribeMacro{\fc@get@last@word} Getting last word. Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#1&input: full sequence\\
%   \#2&output macro 1: all sequence without last word\\
%   \#3&output macro 2: last word\\
% \end{tabularx}
%    \begin{macrocode}
\ifcsundef{fc@get@last@word}{}{\PackageError{fcnumparser}{Duplicate definition}{Redefinition 
    of macro `fc@get@last@word'}}%
\def\fc@get@last@word#1#2#3{%
  {%
%    \end{macrocode}
% First we split \texttt{\#1} into two parts: everything that is upto \cs{fc@case} exclusive goes to
% \cs{toks0}, and evrything from \cs{fc@case} exclusive upto the final \cs{@nil} exclusive goes to \cs{toks1}.
%    \begin{macrocode}
    \def\@tempa##1\fc@case##2\@nil\fc@end{%
      \toks0{##1}%
%    \end{macrocode}
% Actually a dummy \cs{fc@case} is appended to \cs{toks1}, because that makes easier further checking that it
% does not contains any other \cs{fc@case}.
%    \begin{macrocode}
      \toks1{##2\fc@case}%
    }%
    \@tempa#1\fc@end
%    \end{macrocode}
% Now leading part upto last word should be in \cs{toks0}, and last word should be in \cs{toks1}. However we
% need to check that this is really the last word, i.e. we need to check that there is no \cs{fc@case} inside
% \cs{toks1} other than the tailing dummy one. To that purpose we will loop while we find that \cs{toks1}
% contains some \cs{fc@case}. First we define \cs{@tempa} to split \cs{the}\cs{toks1} between parts before and
% after some potential \cs{fc@case}.
%    \begin{macrocode}
    \def\@tempa##1\fc@case##2\fc@end{%
      \toks2{##1}%
      \def\@tempb{##2}%
      \toks3{##2}%
    }%
%    \end{macrocode}
% \cs{@tempt} is just an aliases of \cs{toks0} to make its handling easier later on.
%    \begin{macrocode}
    \toksdef\@tempt0 %
%    \end{macrocode}
% Now the loop itself, this is done by terminal recursion with macro \cs{@templ}.
%    \begin{macrocode}
    \def\@templ{%
      \expandafter\@tempa\the\toks1 \fc@end
      \ifx\@tempb\@empty
%    \end{macrocode}
% \cs{@tempb} empty means that the only \cs{fc@case} found in \cs{the}\cs{toks1} is the dummy one. So we end
% the loop here, \cs{toks2} contains the last word.
%    \begin{macrocode}
        \let\next\relax
      \else
%    \end{macrocode}
% \cs{@tempb} is not empty, first we use 
%    \begin{macrocode}
         \expandafter\expandafter\expandafter\@tempt
         \expandafter\expandafter\expandafter{%
           \expandafter\the\expandafter\@tempt
           \expandafter\fc@case\the\toks2}%
         \toks1\toks3 %
      \fi
      \next
    }%
    \let\next\@templ
    \@templ
    \edef\@tempa{\def\noexpand#2{\the\toks0}\def\noexpand#3{\the\toks2}}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro{\fc@get@last@word} Getting last letter. Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
%   \#1&input: full word\\
%   \#2&output macro 1: all word without last letter\\
%   \#3&output macro 2: last letter\\
% \end{tabularx}
%    \begin{macrocode}
\ifcsundef{fc@get@last@letter}{}{\PackageError{fcnumparser}{Duplicate definition}{Redefinition 
    of macro `fc@get@last@letter'}}%
\def\fc@get@last@letter#1#2#3{%
  {%
%    \end{macrocode}
% First copy input to local \cs{toks1}. What we are going to to is to bubble one by one letters from
% \cs{toks1} which initial contains the whole word, into \cs{toks0}. At the end of the macro \cs{toks0} will
% therefore contain the whole work but the last letter, and the last letter will be in \cs{toks1}.
%    \begin{macrocode}
    \toks1{#1}%
    \toks0{}%
    \toksdef\@tempt0 %
%    \end{macrocode}
% We define \cs{@tempa} in order to pop the first letter from the remaining of word.
%    \begin{macrocode}
    \def\@tempa##1##2\fc@nil{%
      \toks2{##1}%
      \toks3{##2}%
      \def\@tempb{##2}%
    }%
%    \end{macrocode}
% Now we define \cs{@templ} to do the loop by terminal recursion.
%    \begin{macrocode}
    \def\@templ{%
      \expandafter\@tempa\the\toks1 \fc@nil
      \ifx\@tempb\@empty
%    \end{macrocode}
% Stop loop, as \cs{toks1} has been detected to be one single letter.
%    \begin{macrocode}
        \let\next\relax
      \else
%    \end{macrocode}
% Here we append to \cs{toks0} the content of \cs{toks2}, i.e. the next letter.
%    \begin{macrocode}
         \expandafter\expandafter\expandafter\@tempt
         \expandafter\expandafter\expandafter{%
           \expandafter\the\expandafter\@tempt
           \the\toks2}%
%    \end{macrocode}
% And the remaining letters go to \cs{toks1} for the next iteration.
%    \begin{macrocode}
        \toks1\toks3 %
      \fi
      \next
    }%
%    \end{macrocode}
% Here run the loop.
%    \begin{macrocode}
    \let\next\@templ
    \next
%    \end{macrocode}
% Now propagate the results into macros \texttt{\#2} and \texttt{\#3} after closing brace.
%    \begin{macrocode}
    \edef\@tempa{\def\noexpand#2{\the\toks0}\def\noexpand#3{\the\toks1}}%
    \expandafter
  }\@tempa
}%
%    \end{macrocode}
\iffalse Local variables: \fi
\iffalse mode: docTeX     \fi
\iffalse End:             \fi
%\iffalse
%    \begin{macrocode}
%</fcnumparser.sty>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fcprefix.sty>
%    \end{macrocode}
%\fi
%\subsection{fcprefix.sty}
% Pseudo-latin prefixes.
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{fcprefix}[2012/09/28]
\RequirePackage{ifthen}
\RequirePackage{keyval}
\RequirePackage{fcnumparser}
%    \end{macrocode}
% Option `\texttt{use duode and unde}' is to select whether \(18\) and suchlikes (\(\meta{x}8\),
% \(\meta{x}9\)) writes like duodevicies, or like octodecies. For French it should be `\texttt{below
% 20}'. Possible values are `\texttt{below 20}' and `\texttt{never}'.
%    \begin{macrocode}
\define@key{fcprefix}{use duode and unde}[below20]{%
  \ifthenelse{\equal{#1}{below20}}{%
    \def\fc@duodeandunde{2}%
  }{%
    \ifthenelse{\equal{#1}{never}}{%
      \def\fc@duodeandunde{0}%
    }{%
      \PackageError{fcprefix}{Unexpected option}{%
        Option `use duode and unde' expects `below 20' or `never' }%
    }%
  }%
}
%    \end{macrocode}
% Default is `\texttt{below 20}' like in French.
%    \begin{macrocode}
\def\fc@duodeandunde{2}
%    \end{macrocode}
% Option `\texttt{numeral u in duo}', this can be `\texttt{true}' or `\texttt{false}' and is used to select
% whether 12 and suchlikes write like dodec\meta{xxx} or duodec\meta{xxx} for numerals.
%    \begin{macrocode}
\define@key{fcprefix}{numeral u in duo}[false]{%
  \ifthenelse{\equal{#1}{false}}{%
    \let\fc@u@in@duo\@empty
  }{%
    \ifthenelse{\equal{#1}{true}}{%
      \def\fc@u@in@duo{u}%
    }{%
      \PackageError{fcprefix}{Unexpected option}{%
        Option `numeral u in duo' expects `true' or `false' }%
    }%
  }%
}
%    \end{macrocode}
% Option `\texttt{e accute}', this can be `\texttt{true}' or `\texttt{false}' and is used to select whether
% letter `\texttt{e}' has an accute accent when it pronounce [e] in French.
%    \begin{macrocode}
\define@key{fcprefix}{e accute}[false]{%
  \ifthenelse{\equal{#1}{false}}{%
    \let\fc@prefix@eaccute\@firstofone
  }{%
    \ifthenelse{\equal{#1}{true}}{%
      \let\fc@prefix@eaccute\'%
    }{%
      \PackageError{fcprefix}{Unexpected option}{%
        Option `e accute' expects `true' or `false' }%
    }%
  }%
}
%    \end{macrocode}
% Default is to set accute accent like in French.
%    \begin{macrocode}
\let\fc@prefix@eaccute\'%
%    \end{macrocode}
% Option `\texttt{power of millia}' tells how millia is raise to power n. It expects value:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% recursive&for which millia squared is noted as `milliamillia'\\
% arabic&for which millia squared is noted as `millia\^{}2'\\
% prefix&for which millia squared is noted as `bismillia'
% \end{tabularx}
%    \begin{macrocode}
\define@key{fcprefix}{power of millia}[prefix]{%
  \ifthenelse{\equal{#1}{prefix}}{%
       \let\fc@power@of@millia@init\@gobbletwo
       \let\fc@power@of@millia\fc@@prefix@millia
  }{%
    \ifthenelse{\equal{#1}{arabic}}{%
       \let\fc@power@of@millia@init\@gobbletwo
       \let\fc@power@of@millia\fc@@arabic@millia
    }{%
      \ifthenelse{\equal{#1}{recursive}}{%
        \let\fc@power@of@millia@init\fc@@recurse@millia@init
        \let\fc@power@of@millia\fc@@recurse@millia
      }{%
        \PackageError{fcprefix}{Unexpected option}{%
          Option `power of millia' expects `recursive', `arabic', or `prefix' }%
      }%
    }%
  }%
}
%    \end{macrocode}
% Arguments as follows:\def\interface{\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1& output macro\\
% \#2& number with current weight \(w\)
% \end{tabularx}}\interface
%    \begin{macrocode}
\def\fc@@recurse@millia#1#2{%
  \let\@tempp#1%
  \edef#1{millia\@tempp}%
}
%    \end{macrocode}
% Arguments as follows --- same interface as \cs{fc@@recurse@millia}: \interface
%    \begin{macrocode}
\def\fc@@recurse@millia@init#1#2{%
  {%
%    \end{macrocode}
% Save input argument current weight \(w\) into local macro \cs{@tempb}.
%    \begin{macrocode}
    \edef\@tempb{\number#2}%
%    \end{macrocode}
% Now main loop from 0 to \(w\). Final value of \cs{@tempa} will be the result.
%    \begin{macrocode}
    \count0=0 %
    \let\@tempa\@empty
    \loop
       \ifnum\count0<\@tempb
         \advance\count0 by 1 %
         \expandafter\def
           \expandafter\@tempa\expandafter{\@tempa millia}%
    \repeat
%    \end{macrocode}
% Now propagate the expansion of \cs{@tempa} into \texttt{\#1} after closing bace.
%    \begin{macrocode}
    \edef\@tempb{\def\noexpand#1{\@tempa}}%
    \expandafter
  }\@tempb
}
%    \end{macrocode}
% Arguments as follows --- same interface as \cs{fc@@recurse@millia}: \interface
%    \begin{macrocode}
\def\fc@@arabic@millia#1#2{%
  \ifnnum#2=0 %
    \let#1\@empty
  \else
    \edef#1{millia\^{}\the#2}%
  \fi
}
%    \end{macrocode}
% Arguments as follows --- same interface as \cs{fc@@recurse@millia}: \interface
%    \begin{macrocode}
\def\fc@@prefix@millia#1#2{%
  \fc@@latin@numeral@pefix{#2}{#1}%
}
%    \end{macrocode}
% Default value of option `\texttt{power of millia}' is `\texttt{prefix}':
%    \begin{macrocode}
\let\fc@power@of@millia@init\@gobbletwo
\let\fc@power@of@millia\fc@@prefix@millia
%    \end{macrocode}
% \DescribeMacro{\fc@@latin@cardinal@pefix} Compute a cardinal prefix for n-illion, like \(1 \Rightarrow
% \textrm{`m'}\), \(2 \Rightarrow \textrm{`bi'}\), \(3 \Rightarrow \textrm{`tri'}\). The algorithm to derive
% this prefix is that of Russ Rowlett I founds its documentation on Alain Lassine's site:
% \url{http://www.alain.be/Boece/grands\_nombres.html}. First check that macro is not yet defined.
%    \begin{macrocode}
\ifcsundef{fc@@latin@cardinal@pefix}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro `fc@@latin@cardinal@pefix'}}
%    \end{macrocode}
% Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&input number to be formated\\
% \#2&outut macro name into which to place the formatted result
% \end{tabularx}
%    \begin{macrocode}
\def\fc@@latin@cardinal@pefix#1#2{%
  {%
%    \end{macrocode}
% First we put input argument into local macro @cs{@tempa} with full expansion.
%    \begin{macrocode}
    \edef\@tempa{\number#1}%
%    \end{macrocode}
% Now parse number from expanded input.
%    \begin{macrocode}
    \expandafter\fc@number@parser\expandafter{\@tempa}%
    \count2=0 %
%    \end{macrocode}
% \cs{@tempt} will hold the optional final \texttt{t}, \cs{@tempu} is used to initialize \cs{@tempt} to `t'
% when the firt non-zero 3digit group is met, which is the job made by \cs{@tempi}.
%    \begin{macrocode}
    \let\@tempt\@empty
    \def\@tempu{t}%
%    \end{macrocode}
% \cs{@tempm} will hold the \texttt{millia\^}\(^{n\div 3}\)
%    \begin{macrocode}
    \let\@tempm\@empty
%    \end{macrocode}
% Loop by means of terminal recursion of herinafter defined macro \cs{@templ}. We loop by group of 3 digits.
%    \begin{macrocode}
    \def\@templ{%
      \ifnum\count2>\fc@max@weight
        \let\next\relax
      \else
%    \end{macrocode}
% Loop body. Here we read a group of 3 consecutive digits \(d_2d_1d_0\) and place them respectively into
% \cs{count3}, \cs{count4}, and \cs{count5}.
%    \begin{macrocode}
        \fc@read@unit{\count3}{\count2}%
        \advance\count2 by 1 %
        \fc@read@unit{\count4}{\count2}%
        \advance\count2 by 1 %
        \fc@read@unit{\count5}{\count2}%
        \advance\count2 by 1 %
%    \end{macrocode}
% If the 3 considered digits \(d_2d_1d_0\) are not all zero, then set \cs{@tempt} to `\texttt{t}' for the
% first time this event is met.
%    \begin{macrocode}
        \edef\@tempn{%
          \ifnum\count3=0\else 1\fi
          \ifnum\count4=0\else 1\fi
          \ifnum\count5=0\else 1\fi
        }%
        \ifx\@tempn\@empty\else
          \let\@tempt\@tempu
          \let\@tempu\@empty
        \fi
%    \end{macrocode}
% Now process the current group \(d_2d_1d_0\) of 3 digits.
%    \begin{macrocode}
        \let\@tempp\@tempa
        \edef\@tempa{%
%    \end{macrocode}
% Here we process \(d_{2}\) held by \cs{count5}, that is to say hundreds.
%    \begin{macrocode}
          \ifcase\count5 %
          \or cen%
          \or ducen%
          \or trecen%
          \or quadringen%
          \or quingen%
          \or sescen%
          \or septigen%
          \or octingen%
          \or nongen%
          \fi
%    \end{macrocode}
% Here we process \(d_1d_0\) held by \cs{count4} \& \cs{count3}, that is to say tens and units.
%    \begin{macrocode}
          \ifnum\count4=0 %
            % x0(0..9)
            \ifnum\count2=3 %
              % Absolute weight zero
              \ifcase\count3 \@tempt
              \or m%
              \or b%
              \or tr% 
              \or quadr%
              \or quin\@tempt
              \or sex\@tempt
              \or sep\@tempt
              \or oc\@tempt
              \or non%
              \fi
            \else
%    \end{macrocode}
% Here the weight of \cs{count3} is \(3\times n\), with \(n>0\), i.e. this is followed by a
% \texttt{millia\^}\(n\).
%    \begin{macrocode}
              \ifcase\count3 %
              \or \ifnum\count2>\fc@max@weight\else un\fi
              \or d\fc@u@in@duo o%
              \or tre%
              \or quattuor%
              \or quin%
              \or sex%
              \or septen%
              \or octo%
              \or novem%
              \fi
            \fi
          \else
             % x(10..99)
             \ifcase\count3 %
             \or un%
             \or d\fc@u@in@duo o%
             \or tre%
             \or quattuor%
             \or quin%
             \or sex%
             \or septen%
             \or octo%
             \or novem%
             \fi
             \ifcase\count4 %
             \or dec%
             \or vigin\@tempt
             \or trigin\@tempt
             \or quadragin\@tempt
             \or quinquagin\@tempt
             \or sexagin\@tempt
             \or septuagin\@tempt
             \or octogin\@tempt
             \or nonagin\@tempt
             \fi
          \fi
%    \end{macrocode}
% Insert the \texttt{millia\^}\(^{(n\div 3)}\) only if \(d_2d_1d_0\not=0\), i.e. if one of \cs{count3}
% \cs{count4} or \cs{count5} is non zero.
%    \begin{macrocode}
          \@tempm
%    \end{macrocode}
% And append previous version of \cs{@tempa}.
%    \begin{macrocode}
          \@tempp
        }%
%    \end{macrocode}
% ``Concatenate'' \texttt{millia} to \cs{@tempm}, so that \cs{@tempm} will expand to
% \texttt{millia\^}\(^{(n\div 3)+1}\) at the next iteration. Actually whether this is a concatenation or some
% \texttt{millia} prefixing depends of option `\texttt{power of millia}'.
%    \begin{macrocode}
        \fc@power@of@millia\@tempm{\count2}%
      \fi
      \next
    }%
    \let\@tempa\@empty
    \let\next\@templ
    \@templ
%    \end{macrocode}
% Propagate expansion of \cs{@tempa} into \texttt{\#2} after closing bracket.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def#2{##1}}}%
    \expandafter\@tempb\expandafter{\@tempa}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% \DescribeMacro{\fc@@latin@numeral@pefix} Compute a numeral prefix
% like `s\'emel', `bis', `ter', `quater',
% etc\ldots I found the algorithm to derive this prefix on Alain Lassine's site:
% \url{http://www.alain.be/Boece/nombres\_gargantuesques.html}. First check that the macro is not yet defined.
%    \begin{macrocode}
\ifcsundef{fc@@latin@numeral@pefix}{}{%
  \PackageError{fmtcount}{Duplicate definition}{Redefinition of macro 
    `fc@@latin@numeral@pefix'}}
%    \end{macrocode}
% Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1& input number to be formatted,\\
% \#2&  outut macro name into which to place the result
% \end{tabularx}
%    \begin{macrocode}
\def\fc@@latin@numeral@pefix#1#2{%
  {%
    \edef\@tempa{\number#1}%
    \def\fc@unit@weight{0}%
    \expandafter\fc@number@parser\expandafter{\@tempa}%
    \count2=0 %
%    \end{macrocode}
% Macro \cs{@tempm} will hold the \texttt{millies\^}\(^{n\div 3}\).
%    \begin{macrocode}
    \let\@tempm\@empty
%    \end{macrocode}
% Loop over digits. This is done by defining macro \cs{@templ} for terminal recursion.
%    \begin{macrocode}
    \def\@templ{%
      \ifnum\count2>\fc@max@weight
        \let\next\relax
      \else
%    \end{macrocode}
% Loop body. Three consecutive digits \(d_{2}d_{1}d_{0}\) are read into counters \cs{count3}, \cs{count4}, and
% \cs{count5}.
%    \begin{macrocode}
        \fc@read@unit{\count3}{\count2}%
        \advance\count2 by 1 %
        \fc@read@unit{\count4}{\count2}%
        \advance\count2 by 1 %
        \fc@read@unit{\count5}{\count2}%
        \advance\count2 by 1 %
%    \end{macrocode}
% Check the use of \texttt{duodevicies} instead of \texttt{octodecies}.
%    \begin{macrocode}
        \let\@tempn\@secondoftwo
        \ifnum\count3>7 %
          \ifnum\count4<\fc@duodeandunde
            \ifnum\count4>0 %
               \let\@tempn\@firstoftwo
             \fi
          \fi
        \fi
        \@tempn
        {% use duodevicies for eighteen
          \advance\count4 by 1 %
          \let\@temps\@secondoftwo
        }{%  do not use duodevicies for eighteen
          \let\@temps\@firstoftwo
        }%
        \let\@tempp\@tempa
        \edef\@tempa{%
          % hundreds
          \ifcase\count5 %
          \expandafter\@gobble
          \or c%
          \or duc%
          \or trec%
          \or quadring%
          \or quing%
          \or sesc%
          \or septing%
          \or octing%
          \or nong%
          \fi
          {enties}%
          \ifnum\count4=0 %
%    \end{macrocode}
% Here \(d_{2}d_{1}d_{0}\) is such that \(d_{1} = 0\).
%    \begin{macrocode}
            \ifcase\count3 %
            \or
              \ifnum\count2=3 %
                s\fc@prefix@eaccute emel%
              \else
                \ifnum\count2>\fc@max@weight\else un\fi
              \fi
            \or bis%
            \or ter% 
            \or quater%
            \or quinquies%
            \or sexies%
            \or septies%
            \or octies%
            \or novies%
            \fi
          \else
%    \end{macrocode}
% Here \(d_{2}d_{1}d_{0}\) is such that \(d_{1} \geq 1\).
%    \begin{macrocode}
             \ifcase\count3 %
             \or un%
             \or d\fc@u@in@duo o%
             \or ter%
             \or quater%
             \or quin%
             \or sex%
             \or septen%
             \or \@temps{octo}{duod\fc@prefix@eaccute e}% x8 = two before next (x+1)0
             \or \@temps{novem}{und\fc@prefix@eaccute e}% x9 = one before next (x+1)0
             \fi
             \ifcase\count4 %
             % can't get here
             \or d\fc@prefix@eaccute ec%
             \or vic%
             \or tric%
             \or quadrag%
             \or quinquag%
             \or sexag%
             \or septuag%
             \or octog%
             \or nonag%
             \fi
             ies%
          \fi
          % Insert the millies^(n/3) only if one of \count3 \count4 \count5 is non zero
          \@tempm
          % add up previous version of \@tempa
          \@tempp
        }%
%    \end{macrocode}
% Concatenate \texttt{millies} to \cs{@tempm} so that it is equal to \texttt{millies\^}\(^{n\div 3}\) at the
% next iteration. Here we just have plain concatenation, contrary to cardinal for which a prefix can be used
% instead.
%    \begin{macrocode}
        \let\@tempp\@tempp
        \edef\@tempm{millies\@tempp}%
      \fi
      \next
    }%
    \let\@tempa\@empty
    \let\next\@templ
    \@templ
%    \end{macrocode}
% Now propagate expansion of \@tempa into \texttt{\#2} after closing bracket.
%    \begin{macrocode}
    \def\@tempb##1{\def\@tempa{\def#2{##1}}}%
    \expandafter\@tempb\expandafter{\@tempa}%
    \expandafter
  }\@tempa
}
%    \end{macrocode}
% Stuff for calling macros. Construct \cs{fc@call}\meta{some macro} can be used to pass two arguments to
% \meta{some macro} with a configurable calling convention:
% \begin{itemize}
% \item the calling convention is such that there is one mandatory argument \meta{marg} and an optional
%   argument \meta{oarg}
% \item either \cs{fc@call} is \cs{let} to be equal to \cs{fc@call@opt@arg@second}, and then calling
% convention is that the \meta{marg} is first and \meta{oarg} is second,
% \item or \cs{fc@call} is \cs{let} to be equal to \cs{fc@call@opt@arg@first}, and then calling convention is
%   that the \meta{oarg} is first and \meta{aarg} is second,
% \item if \meta{oarg} is absent, then it is by convention set empty,
% \item \meta{some macro} is supposed to have two mandatory arguments of which \meta{oarg} is passed to the
%   first, and \meta{marg} is passed to the second, and
% \item \meta{some macro} is called within a group.
% \end{itemize}
%    \begin{macrocode}
\def\fc@call@opt@arg@second#1#2{%
  \def\@tempb{%
    \ifx[\@tempa
      \def\@tempc[####1]{%
            {#1{####1}{#2}}%
          }%
    \else
      \def\@tempc{{#1{}{#2}}}%
    \fi
    \@tempc
  }%
  \futurelet\@tempa
  \@tempb
}
%    \end{macrocode}
%    \begin{macrocode}
\def\fc@call@opt@arg@first#1{%
  \def\@tempb{%
    \ifx[\@tempa
      \def\@tempc[####1]####2{{#1{####1}{####2}}}%
    \else
      \def\@tempc####1{{#1{}{####1}}}%
    \fi
    \@tempc
  }%
  \futurelet\@tempa
  \@tempb
}

\let\fc@call\fc@call@opt@arg@first
%    \end{macrocode}
% User API.
% 
% \DescribeMacro{\@latinnumeralstringnum} Macro \cs{@latinnumeralstringnum}. Arguments as
% follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&local options\\
% \#2& input number
% \end{tabularx}
%    \begin{macrocode}
\newcommand*{\@latinnumeralstringnum}[2]{%
  \setkeys{fcprefix}{#1}%
  \fc@@latin@numeral@pefix{#2}\@tempa
  \@tempa
}
%    \end{macrocode}
% Arguments as follows:\newline\noindent
% \begin{tabularx}{\linewidth}{@{}>{\raggedleft\arraybackslash\ttfamily}rX@{}}
% \#1&local options\\
% \#2&input counter
% \end{tabularx}
%    \begin{macrocode}
\newcommand*{\@latinnumeralstring}[2]{%
  \setkeys{fcprefix}{#1}%
  \expandafter\let\expandafter
     \@tempa\expandafter\csname c@#2\endcsname
  \expandafter\fc@@latin@numeral@pefix\expandafter{\the\@tempa}\@tempa
  \@tempa
}
%    \end{macrocode}
%    \begin{macrocode}
\newcommand*{\latinnumeralstring}{%
  \fc@call\@latinnumeralstring
}
%    \end{macrocode}
%    \begin{macrocode}
\newcommand*{\latinnumeralstringnum}{%
  \fc@call\@latinnumeralstringnum
}
%    \end{macrocode}
\iffalse Local variables: \fi
\iffalse mode: docTeX     \fi
\iffalse End:             \fi
%\iffalse
%    \begin{macrocode}
%</fcprefix.sty>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*fmtcount.sty>
%    \end{macrocode}
%\fi
%\subsection{fmtcount.sty}
% This section deals with the code for |fmtcount.sty|
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{fmtcount}[2015/05/05 v3.01]
\RequirePackage{ifthen}
%    \end{macrocode}
% \changes{3.01}{2014-12-18}{Use \styfmt{xkeyval} instead of \styfmt{keyval}, so that we do not get in trouble
% with bracket spurious removals}
%    \begin{macrocode}
\RequirePackage{xkeyval}
\RequirePackage{etoolbox}
\RequirePackage{fcprefix}
%    \end{macrocode}
% \changes{3.00}{2014-07-18}{Add \cs{RequirePackage} for \texttt{ifxetex}}
%    \begin{macrocode}
\RequirePackage{ifxetex}
%    \end{macrocode}
% \changes{1.3}{2007/7/19}{no
%longer using xspace package}
%\changes{1.31}{2009/10/02}{amsgen now loaded (\cs{new@ifnextchar}
% needed)}
% Need to use \cs{new@ifnextchar} instead of \cs{@ifnextchar} in
% commands that have a final optional argument (such as \cs{gls})
% so require \sty{amsgen}.
%    \begin{macrocode}
\RequirePackage{amsgen}
%    \end{macrocode}
% These commands need to be defined before the
% configuration file is loaded.
%
% Define the macro to format the |st|, |nd|, |rd| or |th| of an 
% ordinal.
% \changes{3.01}{2014-12-18}{Make \cs{fmtord} language dependent.}
% \changes{3.01}{2014-12-21}{Substitute \cs{textsuperscript} for \cs{fc@textsuperscript}, and define
% \cs{fc@textsuperscript} as \cs{fup} when defined at beginning of document, or as \cs{textsuperscript}
% otherwise}
%\begin{macro}{\fc@orddef@ult}
%    \begin{macrocode}
\providecommand*{\fc@orddef@ult}[1]{\fc@textsuperscript{#1}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\fc@ord@multiling}
%    \begin{macrocode}
\providecommand*{\fc@ord@multiling}[1]{%
  \ifcsundef{fc@\languagename @alias@of}{%
%    \end{macrocode}
% Not a supported language, just use the default setting:
%    \begin{macrocode}
  \fc@orddef@ult{#1}}{%
  \expandafter\let\expandafter\@tempa\csname fc@\languagename @alias@of\endcsname
  \ifcsundef{fc@ord@\@tempa}{%
%    \end{macrocode}
% Not language specfic setting, just use the default setting:
%    \begin{macrocode}
    \fc@orddef@ult{#1}}{%
%    \end{macrocode}
% Language with specific setting, use that setting:
%    \begin{macrocode}
\csname fc@ord@\@tempa\endcsname{#1}}}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\padzeroes}
%\begin{definition}
%\cs{padzeroes}\oarg{n}
%\end{definition}
% Specifies how many digits should be displayed for commands such as
% \cs{decimal} and \cs{binary}.
%    \begin{macrocode}
\newcount\c@padzeroesN
\c@padzeroesN=1\relax
\providecommand*{\padzeroes}[1][17]{\c@padzeroesN=#1}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\FCloadlang}
%\changes{2.0}{2012-06-18}{new}
%\changes{2.02}{2012-10-24}{ensured catcode for @ set to `letter'
%before loading file}
%\begin{definition}
%\cs{FCloadlang}\marg{language}
%\end{definition}
% Load \styfmt{fmtcount} language file,
% \texttt{fc-}\meta{language}\texttt{.def}, unless already loaded.
% Unfortunately neither \styfmt{babel} nor \styfmt{polyglossia} keep a list of loaded
% dialects, so we can't load all the necessary def files in the
% preamble as we don't know which dialects the user requires.
% Therefore the dialect definitions get loaded when a command such
% as \cs{ordinalnum} is used, if they
% haven't already been loaded.
%    \begin{macrocode}
\newcount\fc@tmpcatcode
\def\fc@languages{}%
\def\fc@mainlang{}%
\newcommand*{\FCloadlang}[1]{%
  \@FC@iflangloaded{#1}{}%
  {%
    \fc@tmpcatcode=\catcode`\@\relax
    \catcode `\@ 11\relax
    \InputIfFileExists{fc-#1.def}%
    {%
      \ifdefempty{\fc@languages}%
      {%
        \gdef\fc@languages{#1}%
      }%
      {%
         \gappto\fc@languages{,#1}%
      }%
      \gdef\fc@mainlang{#1}%
    }%
    {}%
    \catcode `\@ \fc@tmpcatcode\relax
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@FC@iflangloaded}
%\changes{2.0}{2012-06-18}{new}
%\begin{definition}
%\cs{@FC@iflangloaded}\marg{language}\marg{true}\marg{false}
%\end{definition}
%If fmtcount language definition file \texttt{fc-}\meta{language}\texttt{.def} has
%been loaded, do \meta{true} otherwise do \meta{false}
%    \begin{macrocode}
\newcommand{\@FC@iflangloaded}[3]{%
  \ifcsundef{ver@fc-#1.def}{#3}{#2}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ProvidesFCLanguage}
%\changes{2.0}{2012-06-18}{new}
% Declare fmtcount language definition file. Adapted from
% \ics{ProvidesFile}.
%    \begin{macrocode}
\newcommand*{\ProvidesFCLanguage}[1]{%
  \ProvidesFile{fc-#1.def}%
}
%    \end{macrocode}
%\end{macro}
%
% We need that flag to remember that a language has been loaded via package option, so that in the end we can
% set \styfmt{fmtcount} in multiling
%    \begin{macrocode}
\newif\iffmtcount@language@option
\fmtcount@language@optionfalse
%    \end{macrocode}
%\begin{macro}{\fc@supported@language@list}
%    Declare list of supported languages, as a comma separated list. No space, no empty items. Each item is a
%    language for which fmtcount is able to load language specific definitions. \texttt{Aliases but be
%    \textit{after} their meaning, for instance `american' being an alias of `USenglish', it has to appear
%    after it in the list}. The raison d'\^etre of this list is to commonalize iteration on languages for the
%    two following purposes:
%    \begin{itemize}
%    \item loading language definition as a result of the language being used by
%      \styfmt{babel}/\styfmt{polyglossia}
%    \item loading language definition as a result of package option
%    \end{itemize}
%    These two purposes cannot be handled in the same pass, we need two different passes otherwise there would
%    be some corner cases when a package would be required --- as a result of loading language definition for
%    one language --- between a \cs{DeclareOption} and a \cs{ProcessOption} which is forbidden by \LaTeXe.
%\changes{3.00}{2014-07-18}{new}
%    \begin{macrocode}
\newcommand*\fc@supported@language@list{%
english,%
UKenglish,%
british,%
USenglish,%
american,%
spanish,%
portuges,%
french,%
frenchb,%
francais,%
german,%
germanb,%
ngerman,%
ngermanb,%
italian}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\fc@iterate@on@languages}
%\begin{definition}
%\cs{fc@iterate@on@languages}\marg{body}
%\end{definition}
% Now make some language iterator, note that for the following to work properly
% \cs{fc@supported@language@list} must not be empty. \meta{body} is  a macro that takes one argument, and
% \cs{fc@iterate@on@languages} applies it iteratively :
%\changes{3.00}{2014-07-18}{new}
%    \begin{macrocode}
\newcommand*\fc@iterate@on@languages[1]{%
  \ifx\fc@supported@language@list\@empty
%    \end{macrocode}
% That case should never happen !
%    \begin{macrocode}
    \PackageError{fmtcount}{Macro `\protect\@fc@iterate@on@languages' is empty}{You should never get here:
      Something is broken within \texttt{fmtcount}, please report the issue on
      \texttt{https://github.com/search?q=fmtcount\&ref=cmdform\&type=Issues}}%
  \else
    \let\fc@iterate@on@languages@body#1
    \expandafter\@fc@iterate@on@languages\fc@supported@language@list,\@nil,%
  \fi
}
\def\@fc@iterate@on@languages#1,{%
    {%
      \def\@tempa{#1}%
      \ifx\@tempa\@nnil
        \let\@tempa\@empty
      \else
        \def\@tempa{%
          \fc@iterate@on@languages@body{#1}%
          \@fc@iterate@on@languages
        }%
      \fi
      \expandafter
    }\@tempa
}%
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@fc@loadifbabelorpolyglossialdf}
%\begin{definition}
%\cs{@fc@loadifbabelorpolyglossialdf}\marg{language}
%\end{definition}
%Loads fmtcount language file,
%\texttt{fc-}\meta{language}\texttt{.def}, 
% if one of the following condition is met:
% \begin{itemize}
% \item \styfmt{babel} language definition file \meta{language}\texttt{.ldf} has been loaded --- conditionally
% to compilation with \texttt{latex}, not \texttt{xelatex}.
% \item \styfmt{polyglossia} language definition file \texttt{gloss-}\meta{language}\texttt{.ldf} has been
%   loaded --- conditionally to compilation with \texttt{xelatex}, not \texttt{latex}.
% \item \meta{language} option has been passed to package \styfmt{fmtcount}.
% \end{itemize}
% 
%\changes{2.03}{2012-11-11}{renamed \cs{@fc@loadifbabelldf} to
% \cs{@fc@loadifbabelorpolyglossialdf}}
%\changes{2.03}{2012-11-11}{added check for polyglossia language}
%\changes{3.00}{2014-07-18}{use \cs{ifxetex} to discriminate between \styfmt{babel} and \styfmt{polyglossia}}
%    \begin{macrocode}
\newcommand*{\@fc@loadifbabelorpolyglossialdf}[1]{%
  \ifxetex
    \IfFileExists{gloss-#1.ldf}{\ifcsundef{#1@loaded}{}{\FCloadlang{#1}}}{}%
  \else
     \ifcsundef{ver@#1.ldf}{}{\FCloadlang{#1}}%
  \fi
}
%    \end{macrocode}
%\end{macro}
%
% Load appropriate language definition files:
%\changes{1.1}{14 June 2007}{added check for UKenglish,
% british and USenglish babel settings}
%\changes{2.0}{2012-06-18}{changed check for \cs{l@}\meta{language} 
% to check for \cs{date}\meta{language}}
%\changes{3.00}{2014-07-18}{use iterator rather than doing it flat on each language}
%\changes{3.01}{2014-12-18}{Define language aliases to \cs{fmtord}
%   option dependent on ``true'' language .}
%    \begin{macrocode}
\fc@iterate@on@languages\@fc@loadifbabelorpolyglossialdf
%    \end{macrocode}
% By default all languages are unique --- i.e. aliases not yet defined.
%    \begin{macrocode}
\def\fc@iterate@on@languages@body#1{%
  \expandafter\def\csname fc@#1@alias@of\endcsname{#1}}
\expandafter\@fc@iterate@on@languages\fc@supported@language@list,\@nil,%
%    \end{macrocode}
% Now define those languages that are aliases of another
% language. This is done with: \cs{@tempa}\marg{alias}\marg{language}
%    \begin{macrocode}
\def\@tempa#1#2{%
  \expandafter\def\csname fc@#1@alias@of\endcsname{#2}%
}%
\@tempa{frenchb}{french}
\@tempa{francais}{french}
\@tempa{germanb}{german}
\@tempa{ngermanb}{german}
\@tempa{ngerman}{german}
\@tempa{british}{english}
\@tempa{american}{USenglish}
%    \end{macrocode}
% Now, thanks to the aliases, we are going to define one option for each language, so that each language can
% have its own settings.
%    \begin{macrocode}
\def\fc@iterate@on@languages@body#1{%
  \define@key{fmtcount}{#1}[]{%
    \@FC@iflangloaded{#1}%
    {%
      \setkeys{fc\csname fc@#1@alias@of\endcsname}{##1}%
    }{%
      \PackageError{fmtcount}%
      {Language `#1' not defined}%
      {You need to load \ifxetex polyglossia\else babel\fi\space before loading fmtcount}%
    }%
  }%
  \ifthenelse{\equal{\csname fc@#1@alias@of\endcsname}{#1}}{%
    \define@key{fc\csname fc@#1@alias@of\endcsname}{fmtord}{%
      \ifthenelse{\equal{##1}{raise}\or\equal{##1}{level}}{%
        \expandafter\let\expandafter\@tempa\csname fc@set@ord@as@##1\endcsname
        \expandafter\@tempa\csname fc@ord@#1\endcsname
      }{%
        \ifthenelse{\equal{##1}{undefine}}{%
          \expandafter\let\csname fc@ord@#1\endcsname\undefined
        }{%
          \PackageError{fmtcount}%
          {Invalid value `##1' to fmtord key}%
          {Option `fmtord' can only take the values `level', `raise'
            or `undefine'}%
        }}
    }%
  }{%
%    \end{macrocode}
% When the language \#1 is an alias, do the same as the language of which it is an alias:
%    \begin{macrocode}
    \expandafter\let\expandafter\@tempa\csname KV@\csname fc@#1@alias@of\endcsname @fmtord\endcsname
    \expandafter\let\csname KV@#1@fmtord\endcsname\@tempa
  }%
}
\expandafter\@fc@iterate@on@languages\fc@supported@language@list,\@nil,%
%    \end{macrocode}
%\begin{option}{fmtord}
% Key to determine how to display the ordinal
% \changes{3.01}{2014-12-18}{Apply option directly, rather than doing a border effect on \cs{fmtcount@fmtord},
% and then postprocessing depending on \cs{fmtcount@fmtord} at the end of \cs{fmtcountsetoptions}}
%    \begin{macrocode}
\def\fc@set@ord@as@level#1{%
  \def#1##1{##1}%
}
\def\fc@set@ord@as@raise#1{%
  \let#1\fc@textsuperscript
}
\define@key{fmtcount}{fmtord}{%
  \ifthenelse{\equal{#1}{level}
           \or\equal{#1}{raise}}%
  {%
    \csname fc@set@ord@as@#1\endcsname\fc@orddef@ult
    \def\fmtcount@fmtord{#1}%
  }%
  {%
    \PackageError{fmtcount}%
    {Invalid value `#1' to fmtord key}%
    {Option `fmtord' can only take the values `level' or `raise'}%
  }%
}
%    \end{macrocode}
%\end{option}
%\begin{macro}{\iffmtord@abbrv}
%  Key to determine whether the ordinal superscript should be
%  abbreviated (language dependent, currently only affects French
%  ordinals, non-abbreviated French ordinals ending --- i.e. `ier' and
%  `i\`eme' --- are considered faulty.)
%    \begin{macrocode}
\newif\iffmtord@abbrv
%    \end{macrocode}
% \changes{3.01}{2014-11-12}{Make `true' the default for option
% `abbr', as in French this is the correct behaviour, and currently
% only French uses that}
%    \begin{macrocode}
\fmtord@abbrvtrue
\define@key{fmtcount}{abbrv}[true]{%
  \ifthenelse{\equal{#1}{true}\or\equal{#1}{false}}%
  {%
    \csname fmtord@abbrv#1\endcsname
  }%
  {%
    \PackageError{fmtcount}%
    {Invalid value `#1' to fmtord key}%
    {Option `abbrv' can only take the values `true' or
     `false'}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{option}{prefix}
%\changes{2.0}{2012-06-18}{new}
%    \begin{macrocode}
\define@key{fmtcount}{prefix}[scale=long]{%
  \RequirePackage{fmtprefix}%
  \fmtprefixsetoption{#1}%
}
%    \end{macrocode}
%\end{option}
%\begin{macro}{\fmtcountsetoptions}
% Define command to set options.
% \changes{3.01}{2014-12-18}{ Move French specific stuff to \styfmt{french.def}.}
%    \begin{macrocode}
\def\fmtcountsetoptions{%
  \def\fmtcount@fmtord{}%
  \setkeys{fmtcount}}%
%    \end{macrocode}
%\end{macro}
% Load configuration file if it exists.  This needs to be done
% before the package options, to allow the user to override
% the settings in the configuration file.
%\changes{2.0}{2012-06-18}{Now no message if fmtcount.cfg not found}
%    \begin{macrocode}
\InputIfFileExists{fmtcount.cfg}%
{%
  \PackageInfo{fmtcount}{Using configuration file fmtcount.cfg}%
}%
{%
}
%    \end{macrocode}
%\begin{macro}{\fmtcount@loaded@by@option@lang@list}
% \changes{3.01}{2014-10-15}{Declare language option so that actual loading happens after \cs{ProcessOptions},
% and the \cs{ProcessOption} only registers the language for loading.}
%    \begin{macrocode}
\newcommand*{\fmtcount@loaded@by@option@lang@list}{}
%    \end{macrocode}
%\end{macro}
%\begin{option}{\meta{language}}
%Option \meta{language} causes language \meta{language} to be registered for loading. 
%    \begin{macrocode}
\newcommand*\@fc@declare@language@option[1]{%
  \DeclareOption{#1}{%
    \ifx\fmtcount@loaded@by@option@lang@list\@empty
       \def\fmtcount@loaded@by@option@lang@list{#1}%
    \else
       \edef\fmtcount@loaded@by@option@lang@list{\fmtcount@loaded@by@option@lang@list,#1}%
    \fi
  }}%
\fc@iterate@on@languages\@fc@declare@language@option
%    \end{macrocode}
%\end{option}
%
%\begin{option}{level}
%    \begin{macrocode}
\DeclareOption{level}{\def\fmtcount@fmtord{level}%
  \def\fc@orddef@ult#1{#1}}
%    \end{macrocode}
%\end{option}
%\begin{option}{raise}
%    \begin{macrocode}
\DeclareOption{raise}{\def\fmtcount@fmtord{raise}%
  \def\fc@orddef@ult#1{\fc@textsuperscript{#1}}}
%    \end{macrocode}
%\end{option}
% Process package options 
% \changes{3.00}{2014-07-18}{Add \cs{relax} after \cs{ProcessOptions} like shown in \texttt{clsguide.pdf}}
%    \begin{macrocode}
\ProcessOptions\relax
%    \end{macrocode}
% \changes{3.01}{2014-10-15}{Load languages that have been registered for loading by package option.}
% Now we do the loading of all languages that have been set by option to be loaded.
%    \begin{macrocode}
\ifx\fmtcount@loaded@by@option@lang@list\@empty\else
\def\fc@iterate@on@languages@body#1{%
    \@FC@iflangloaded{#1}{}{%
      \fmtcount@language@optiontrue
      \FCloadlang{#1}%
     }}
\expandafter\@fc@iterate@on@languages\fmtcount@loaded@by@option@lang@list,\@nil,%
\fi
%    \end{macrocode}
%\begin{macro}{\@FCmodulo}
%\begin{definition}
%\cs{@FCmodulo}\marg{count reg}\marg{n}
%\end{definition}
%\changes{2.04}{2014-06-09}{renamed \cs{@modulo} to \cs{@FCmodulo}}
% Sets the count register to be its value modulo \meta{n}. 
% This is used for the
% date, time, ordinal and numberstring commands. (The
% \styfmt{fmtcount} package was originally part of the 
% \sty{datetime} package.)
%    \begin{macrocode}
\newcount\@DT@modctr
\newcommand*{\@FCmodulo}[2]{%
  \@DT@modctr=#1\relax
  \divide \@DT@modctr by #2\relax
  \multiply \@DT@modctr by #2\relax
  \advance #1 by -\@DT@modctr
}
%    \end{macrocode}
%\end{macro}
% The following registers are needed by |\@ordinal| etc
%    \begin{macrocode}
\newcount\@ordinalctr
\newcount\@orgargctr
\newcount\@strctr
\newcount\@tmpstrctr
%    \end{macrocode}
%Define commands that display numbers in different bases.
% Define counters and conditionals needed.
%    \begin{macrocode}
\newif\if@DT@padzeroes
\newcount\@DT@loopN
\newcount\@DT@X
%    \end{macrocode}
%\begin{macro}{\binarynum}
% Converts a decimal number to binary, and display.
%    \begin{macrocode}
\newcommand*{\@binary}[1]{%
  \@DT@padzeroestrue
  \@DT@loopN=17\relax
  \@strctr=\@DT@loopN
  \whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by 1}%
  \@strctr=65536\relax
  \@DT@X=#1\relax
  \loop
    \@DT@modctr=\@DT@X
    \divide\@DT@modctr by \@strctr
    \ifthenelse{\boolean{@DT@padzeroes}
       \and \(\@DT@modctr=0\)
       \and \(\@DT@loopN>\c@padzeroesN\)}%
    {}%
    {\the\@DT@modctr}%
    \ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
    \multiply\@DT@modctr by \@strctr
    \advance\@DT@X by -\@DT@modctr
    \divide\@strctr by 2\relax
    \advance\@DT@loopN by -1\relax
  \ifnum\@strctr>1
  \repeat
  \the\@DT@X
}

\let\binarynum=\@binary
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\octalnum}
% Converts a decimal number to octal, and displays.
%    \begin{macrocode}
\newcommand*{\@octal}[1]{%
  \ifnum#1>32768
    \PackageError{fmtcount}%
    {Value of counter too large for \protect\@octal}
    {Maximum value 32768}
  \else
  \@DT@padzeroestrue
  \@DT@loopN=6\relax
  \@strctr=\@DT@loopN
  \whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by 1}%
  \@strctr=32768\relax
  \@DT@X=#1\relax
  \loop
    \@DT@modctr=\@DT@X
    \divide\@DT@modctr by \@strctr
    \ifthenelse{\boolean{@DT@padzeroes}
       \and \(\@DT@modctr=0\)
       \and \(\@DT@loopN>\c@padzeroesN\)}%
    {}{\the\@DT@modctr}%
    \ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
    \multiply\@DT@modctr by \@strctr
    \advance\@DT@X by -\@DT@modctr
    \divide\@strctr by 8\relax
    \advance\@DT@loopN by -1\relax
  \ifnum\@strctr>1
  \repeat
  \the\@DT@X
  \fi
}
\let\octalnum=\@octal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@@hexadecimalnum}
% Converts number from 0 to 15 into lowercase hexadecimal notation.
%    \begin{macrocode}
\newcommand*{\@@hexadecimal}[1]{%
  \ifcase#10\or1\or2\or3\or4\or5\or
  6\or7\or8\or9\or a\or b\or c\or d\or e\or f\fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\hexadecimalnum}
% Converts a decimal number to a lowercase hexadecimal number, 
% and displays it.
%    \begin{macrocode}
\newcommand*{\@hexadecimal}[1]{%
  \@DT@padzeroestrue
  \@DT@loopN=5\relax
  \@strctr=\@DT@loopN
  \whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by 1}%
  \@strctr=65536\relax
  \@DT@X=#1\relax
  \loop
    \@DT@modctr=\@DT@X
    \divide\@DT@modctr by \@strctr
    \ifthenelse{\boolean{@DT@padzeroes}
      \and \(\@DT@modctr=0\)
      \and \(\@DT@loopN>\c@padzeroesN\)}
    {}{\@@hexadecimal\@DT@modctr}%
    \ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
    \multiply\@DT@modctr by \@strctr
    \advance\@DT@X by -\@DT@modctr
    \divide\@strctr by 16\relax
    \advance\@DT@loopN by -1\relax
  \ifnum\@strctr>1
  \repeat
  \@@hexadecimal\@DT@X
}
\let\hexadecimalnum=\@hexadecimal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@@Hexadecimalnum}
% Converts number from 0 to 15 into uppercase hexadecimal notation.
%    \begin{macrocode}
\newcommand*{\@@Hexadecimal}[1]{%
  \ifcase#10\or1\or2\or3\or4\or5\or6\or
  7\or8\or9\or A\or B\or C\or D\or E\or F\fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Hexadecimalnum}
% Uppercase hexadecimal
%    \begin{macrocode}
\newcommand*{\@Hexadecimal}[1]{%
  \@DT@padzeroestrue
  \@DT@loopN=5\relax
  \@strctr=\@DT@loopN
  \whiledo{\@strctr<\c@padzeroesN}{0\advance\@strctr by 1}%
  \@strctr=65536\relax
  \@DT@X=#1\relax
  \loop
    \@DT@modctr=\@DT@X
    \divide\@DT@modctr by \@strctr
    \ifthenelse{\boolean{@DT@padzeroes}
      \and \(\@DT@modctr=0\)
      \and \(\@DT@loopN>\c@padzeroesN\)}%
    {}{\@@Hexadecimal\@DT@modctr}%
    \ifnum\@DT@modctr=0\else\@DT@padzeroesfalse\fi
    \multiply\@DT@modctr by \@strctr
    \advance\@DT@X by -\@DT@modctr
    \divide\@strctr by 16\relax
    \advance\@DT@loopN by -1\relax
  \ifnum\@strctr>1
  \repeat
  \@@Hexadecimal\@DT@X
}

\let\Hexadecimalnum=\@Hexadecimal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\aaalphnum}
% Lowercase alphabetical representation (a \ldots\ z aa \ldots\ zz)
%    \begin{macrocode}
\newcommand*{\@aaalph}[1]{%
  \@DT@loopN=#1\relax
  \advance\@DT@loopN by -1\relax
  \divide\@DT@loopN by 26\relax
  \@DT@modctr=\@DT@loopN
  \multiply\@DT@modctr by 26\relax
  \@DT@X=#1\relax
  \advance\@DT@X by -1\relax
  \advance\@DT@X by -\@DT@modctr
  \advance\@DT@loopN by 1\relax
  \advance\@DT@X by 1\relax
  \loop
    \@alph\@DT@X
    \advance\@DT@loopN by -1\relax
  \ifnum\@DT@loopN>0
  \repeat
}

\let\aaalphnum=\@aaalph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\AAAlphnum}
% Uppercase alphabetical representation (a \ldots\ z aa \ldots\ zz)
%    \begin{macrocode}
\newcommand*{\@AAAlph}[1]{%
  \@DT@loopN=#1\relax
  \advance\@DT@loopN by -1\relax
  \divide\@DT@loopN by 26\relax
  \@DT@modctr=\@DT@loopN
  \multiply\@DT@modctr by 26\relax
  \@DT@X=#1\relax
  \advance\@DT@X by -1\relax
  \advance\@DT@X by -\@DT@modctr
  \advance\@DT@loopN by 1\relax
  \advance\@DT@X by 1\relax
  \loop
    \@Alph\@DT@X
    \advance\@DT@loopN by -1\relax
  \ifnum\@DT@loopN>0
  \repeat
}

\let\AAAlphnum=\@AAAlph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\abalphnum}
% Lowercase alphabetical representation
%    \begin{macrocode}
\newcommand*{\@abalph}[1]{%
  \ifnum#1>17576\relax
    \PackageError{fmtcount}%
    {Value of counter too large for \protect\@abalph}%
    {Maximum value 17576}%
  \else
    \@DT@padzeroestrue
    \@strctr=17576\relax
    \@DT@X=#1\relax
    \advance\@DT@X by -1\relax
    \loop
      \@DT@modctr=\@DT@X
      \divide\@DT@modctr by \@strctr
      \ifthenelse{\boolean{@DT@padzeroes}
        \and \(\@DT@modctr=1\)}%
      {}{\@alph\@DT@modctr}%
      \ifnum\@DT@modctr=1\else\@DT@padzeroesfalse\fi
      \multiply\@DT@modctr by \@strctr
      \advance\@DT@X by -\@DT@modctr
      \divide\@strctr by 26\relax
    \ifnum\@strctr>1
    \repeat
    \advance\@DT@X by 1\relax
    \@alph\@DT@X
  \fi
}

\let\abalphnum=\@abalph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ABAlphnum}
% Uppercase alphabetical representation
%    \begin{macrocode}
\newcommand*{\@ABAlph}[1]{%
  \ifnum#1>17576\relax
    \PackageError{fmtcount}%
   {Value of counter too large for \protect\@ABAlph}%
   {Maximum value 17576}%
  \else
    \@DT@padzeroestrue
    \@strctr=17576\relax
    \@DT@X=#1\relax
    \advance\@DT@X by -1\relax
    \loop
      \@DT@modctr=\@DT@X
      \divide\@DT@modctr by \@strctr
      \ifthenelse{\boolean{@DT@padzeroes}\and
      \(\@DT@modctr=1\)}{}{\@Alph\@DT@modctr}%
      \ifnum\@DT@modctr=1\else\@DT@padzeroesfalse\fi
      \multiply\@DT@modctr by \@strctr
      \advance\@DT@X by -\@DT@modctr
      \divide\@strctr by 26\relax
    \ifnum\@strctr>1
    \repeat
    \advance\@DT@X by 1\relax
    \@Alph\@DT@X
  \fi
}

\let\ABAlphnum=\@ABAlph
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@fmtc@count}
% Recursive command to count number of characters in argument.
% \cs{@strctr} should be set to zero before calling it.
%    \begin{macrocode}
\def\@fmtc@count#1#2\relax{%
  \if\relax#1%
  \else
    \advance\@strctr by 1\relax
    \@fmtc@count#2\relax
  \fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@decimal}
%\changes{1.31}{2009/10/02}{fixed unwanted space.}
% Format number as a decimal, possibly padded with zeroes in front.
%    \begin{macrocode}
\newcommand{\@decimal}[1]{%
  \@strctr=0\relax
  \expandafter\@fmtc@count\number#1\relax
  \@DT@loopN=\c@padzeroesN
  \advance\@DT@loopN by -\@strctr
  \ifnum\@DT@loopN>0\relax
    \@strctr=0\relax
    \whiledo{\@strctr < \@DT@loopN}{0\advance\@strctr by 1\relax}%
  \fi
  \number#1\relax
}

\let\decimalnum=\@decimal
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\FCordinal}
%\begin{definition}
%\cs{FCordinal}\marg{number}
%\end{definition}
% This is a bit cumbersome.  Previously \cs{@ordinal}
% was defined in a similar way to \cs{abalph} etc.
% This ensured that the actual value of the counter was
% written in the new label stuff in the .aux file. However
% adding in an optional argument to determine the gender
% for multilingual compatibility messed things up somewhat.
% This was the only work around I could get to keep the
% the cross-referencing stuff working, which is why
% the optional argument comes \emph{after} the compulsory
% argument, instead of the usual manner of placing it before.
% Note however, that putting the optional argument means that
% any spaces will be ignored after the command if the optional
% argument is omitted.
% Version 1.04 changed \cs{ordinal} to \cs{FCordinal}
% to prevent it clashing with the memoir class. 
%    \begin{macrocode}
\newcommand{\FCordinal}[1]{%
  \expandafter\protect\expandafter\ordinalnum{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinal}
% If \cs{ordinal} isn't defined make \cs{ordinal} a synonym
% for \cs{FCordinal} to maintain compatibility with previous
% versions.
% \changes{3.00}{2014-07-18}{Use \cs{protect}, not \cs{string} in \cs{PackageWarning} to quote macros like
% shown in \texttt{clsguide.pdf}}
%    \begin{macrocode}
\ifcsundef{ordinal}
 {\let\ordinal\FCordinal}%
 {%
   \PackageWarning{fmtcount}%
   {\protect\ordinal \space already defined use 
    \protect\FCordinal \space instead.}
 }
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinalnum}
% Display ordinal where value is given as a number or 
% count register instead of a counter:
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\ordinalnum}[1]{%
  \new@ifnextchar[%
  {\@ordinalnum{#1}}%
  {\@ordinalnum{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@ordinalnum}
% Display ordinal according to gender (neuter added in v1.1,
% \cs{xspace} added in v1.2, and removed in v1.3\footnote{I
%couldn't get it to work consistently both with and without the
%optional argument}):
%    \begin{macrocode}
\def\@ordinalnum#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@ordinalF{#1}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@ordinalN{#1}{\@fc@ordstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
           {Invalid gender option `#2'}%
           {Available options are m, f or n}%
        }%
        \protect\@ordinalM{#1}{\@fc@ordstr}%
      }%
    }%
    \@fc@ordstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinal}
% Store the ordinal (first argument
% is identifying name, second argument is a counter.)
%    \begin{macrocode}
\newcommand*{\storeordinal}[2]{%
  \expandafter\protect\expandafter\storeordinalnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinalnum}
% Store ordinal (first argument
% is identifying name, second argument is a number or
% count register.)
%    \begin{macrocode}
\newcommand*{\storeordinalnum}[2]{%
  \@ifnextchar[%
  {\@storeordinalnum{#1}{#2}}%
  {\@storeordinalnum{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@storeordinalnum}
% Store ordinal according to gender:
%    \begin{macrocode}
\def\@storeordinalnum#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@ordinalF{#2}{\@fc@ord}
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@ordinalN{#2}{\@fc@ord}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m or f}%
      }%
      \protect\@ordinalM{#2}{\@fc@ord}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@ord
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\FMCuse}
% Get stored information:
%    \begin{macrocode}
\newcommand*{\FMCuse}[1]{\csname @fcs@#1\endcsname}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinalstring}
% Display ordinal as a string (argument is a counter)
%    \begin{macrocode}
\newcommand*{\ordinalstring}[1]{%
  \expandafter\protect\expandafter\ordinalstringnum{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinalstringnum}
% Display ordinal as a string (argument is a count register or
% number.)
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%\changes{1.33}{2009/10/15}{Made robust}
%    \begin{macrocode}
\newcommand{\ordinalstringnum}[1]{%
  \new@ifnextchar[%
  {\@ordinal@string{#1}}%
  {\@ordinal@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@ordinal@string}
% Display ordinal as a string according to gender.
% \changes{3.00}{2014-07-18}{Use \cs{protect}, not \cs{string} in \cs{PackageError} to quote macros like
% shown in \texttt{clsguide.pdf}}
% \changes{3.00}{2014-07-18}{Correct detailed error message, so `n' is one of available gender options}
%    \begin{macrocode}
\def\@ordinal@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@ordinalstringF{#1}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@ordinalstringN{#1}{\@fc@ordstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2' to \protect\ordinalstring}%
          {Available options are m, f or n}%
        }%
        \protect\@ordinalstringM{#1}{\@fc@ordstr}%
      }%
    }%
    \@fc@ordstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinalstring}
% Store textual representation of number. First argument is 
% identifying name, second argument is the counter set to the 
% required number.
%    \begin{macrocode}
\newcommand*{\storeordinalstring}[2]{%
  \expandafter\protect\expandafter\storeordinalstringnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeordinalstringnum}
% Store textual representation of number. First argument is 
% identifying name, second argument is a count register or number.
%    \begin{macrocode}
\newcommand*{\storeordinalstringnum}[2]{%
  \@ifnextchar[%
  {\@store@ordinal@string{#1}{#2}}%
  {\@store@ordinal@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@ordinal@string}
% Store textual representation of number according to gender.
% \changes{3.00}{2014-07-18}{Use \cs{protect}, not \cs{string} in \cs{PackageWarning} to quote macros like
% shown in \texttt{clsguide.pdf}}
%    \begin{macrocode}
\def\@store@ordinal@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@ordinalstringF{#2}{\@fc@ordstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@ordinalstringN{#2}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3' to \protect\ordinalstring}%
        {Available options are m, f or n}%
      }%
      \protect\@ordinalstringM{#2}{\@fc@ordstr}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@ordstr
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Ordinalstring}
% Display ordinal as a string with initial letters in upper case
% (argument is a counter)
%    \begin{macrocode}
\newcommand*{\Ordinalstring}[1]{%
  \expandafter\protect\expandafter\Ordinalstringnum{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Ordinalstringnum}
% Display ordinal as a string with initial letters in upper case
% (argument is a number or count register)
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\Ordinalstringnum}[1]{%
  \new@ifnextchar[%
  {\@Ordinal@string{#1}}%
  {\@Ordinal@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@Ordinal@string}
% Display ordinal as a string with initial letters in upper case
% according to gender
%    \begin{macrocode}
\def\@Ordinal@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@OrdinalstringF{#1}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@OrdinalstringN{#1}{\@fc@ordstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@OrdinalstringM{#1}{\@fc@ordstr}%
      }%
    }%
    \@fc@ordstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeOrdinalstring}
% Store textual representation of number, with initial letters in 
% upper case. First argument is identifying name, second argument 
% is the counter set to the 
% required number.
%    \begin{macrocode}
\newcommand*{\storeOrdinalstring}[2]{%
  \expandafter\protect\expandafter\storeOrdinalstringnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeOrdinalstringnum}
% Store textual representation of number, with initial letters in 
% upper case. First argument is identifying name, second argument 
% is a count register or number.
%    \begin{macrocode}
\newcommand*{\storeOrdinalstringnum}[2]{%
  \@ifnextchar[%
  {\@store@Ordinal@string{#1}{#2}}%
  {\@store@Ordinal@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@Ordinal@string}
% Store textual representation of number according to gender, 
% with initial letters in upper case.
%    \begin{macrocode}
\def\@store@Ordinal@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@OrdinalstringF{#2}{\@fc@ordstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@OrdinalstringN{#2}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m or f}%
      }%
      \protect\@OrdinalstringM{#2}{\@fc@ordstr}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@ordstr
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\storeORDINALstring}
% Store upper case textual representation of ordinal. The first 
% argument is identifying name, the second argument is a counter.
%    \begin{macrocode}
\newcommand*{\storeORDINALstring}[2]{%
  \expandafter\protect\expandafter\storeORDINALstringnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeORDINALstringnum}
% As above, but the second argument is a count register or a
% number.
%    \begin{macrocode}
\newcommand*{\storeORDINALstringnum}[2]{%
  \@ifnextchar[%
  {\@store@ORDINAL@string{#1}{#2}}%
  {\@store@ORDINAL@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@ORDINAL@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@store@ORDINAL@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@ordinalstringF{#2}{\@fc@ordstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@ordinalstringN{#2}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m or f}%
      }%
      \protect\@ordinalstringM{#2}{\@fc@ordstr}%
    }%
  }%
%    \end{macrocode}
% \changes{3.01}{2014-11-10}{Protect \cs{`}.}
%    \begin{macrocode}
  \expandafter\protected@edef\csname @fcs@#1\endcsname{%
    \noexpand\MakeUppercase{\@fc@ordstr}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ORDINALstring}
% Display upper case textual representation of an ordinal. The
% argument must be a counter.
%    \begin{macrocode}
\newcommand*{\ORDINALstring}[1]{%
  \expandafter\protect\expandafter\ORDINALstringnum{%
    \expandafter\the\csname c@#1\endcsname
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ORDINALstringnum}
% As above, but the argument is a count register or a number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\ORDINALstringnum}[1]{%
  \new@ifnextchar[%
  {\@ORDINAL@string{#1}}%
  {\@ORDINAL@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@ORDINAL@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@ORDINAL@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@ordinalstringF{#1}{\@fc@ordstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@ordinalstringN{#1}{\@fc@ordstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@ordinalstringM{#1}{\@fc@ordstr}%
      }%
    }%
    \MakeUppercase{\@fc@ordstr}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storenumberstring}
% Convert number to textual respresentation, and store. First 
% argument is the identifying name, second argument is a counter 
% containing the number.
%    \begin{macrocode}
\newcommand*{\storenumberstring}[2]{%
  \expandafter\protect\expandafter\storenumberstringnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storenumberstringnum}
% As above, but second argument is a number or count register.
%    \begin{macrocode}
\newcommand{\storenumberstringnum}[2]{%
  \@ifnextchar[%
  {\@store@number@string{#1}{#2}}%
  {\@store@number@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@number@string}
% Gender is given as optional argument, \emph{at the end}.
%    \begin{macrocode}
\def\@store@number@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@numberstringF{#2}{\@fc@numstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@numberstringN{#2}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}
        {Invalid gender option `#3'}%
        {Available options are m, f or n}%
      }%
      \protect\@numberstringM{#2}{\@fc@numstr}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@numstr
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\numberstring}
% Display textual representation of a number. The argument
% must be a counter.
%    \begin{macrocode}
\newcommand*{\numberstring}[1]{%
  \expandafter\protect\expandafter\numberstringnum{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\numberstringnum}
% As above, but the argument is a count register or a number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\numberstringnum}[1]{%
  \new@ifnextchar[%
  {\@number@string{#1}}%
  {\@number@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\@number@string}
% Gender is specified as an optional argument \emph{at the end}.
%    \begin{macrocode}
\def\@number@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@numberstringF{#1}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
         \protect\@numberstringN{#1}{\@fc@numstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@numberstringM{#1}{\@fc@numstr}%
      }%
    }%
    \@fc@numstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNumberstring}
% Store textual representation of number. First argument is 
% identifying name, second argument is a counter.
%    \begin{macrocode}
\newcommand*{\storeNumberstring}[2]{%
  \expandafter\protect\expandafter\storeNumberstringnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNumberstringnum}
% As above, but second argument is a count register or number.
%    \begin{macrocode}
\newcommand{\storeNumberstringnum}[2]{%
  \@ifnextchar[%
  {\@store@Number@string{#1}{#2}}%
  {\@store@Number@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@Number@string}
% Gender is specified as an optional argument \emph{at the end}:
%    \begin{macrocode}
\def\@store@Number@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@NumberstringF{#2}{\@fc@numstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@NumberstringN{#2}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m, f or n}%
      }%
      \protect\@NumberstringM{#2}{\@fc@numstr}%
    }%
  }%
  \expandafter\let\csname @fcs@#1\endcsname\@fc@numstr
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Numberstring}
% Display textual representation of number. The argument must be
% a counter. 
%    \begin{macrocode}
\newcommand*{\Numberstring}[1]{%
  \expandafter\protect\expandafter\Numberstringnum{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Numberstringnum}
% As above, but the argument is a count register or number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\Numberstringnum}[1]{%
  \new@ifnextchar[%
  {\@Number@string{#1}}%
  {\@Number@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@Number@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@Number@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@NumberstringF{#1}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
        \protect\@NumberstringN{#1}{\@fc@numstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@NumberstringM{#1}{\@fc@numstr}%
      }%
    }%
    \@fc@numstr
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNUMBERstring}
% Store upper case textual representation of number. The first 
% argument is identifying name, the second argument is a counter.
%    \begin{macrocode}
\newcommand{\storeNUMBERstring}[2]{%
  \expandafter\protect\expandafter\storeNUMBERstringnum{#1}{%
    \expandafter\the\csname c@#2\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\storeNUMBERstringnum}
% As above, but the second argument is a count register or a
% number.
%    \begin{macrocode}
\newcommand{\storeNUMBERstringnum}[2]{%
  \@ifnextchar[%
  {\@store@NUMBER@string{#1}{#2}}%
  {\@store@NUMBER@string{#1}{#2}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@store@NUMBER@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@store@NUMBER@string#1#2[#3]{%
  \ifthenelse{\equal{#3}{f}}%
  {%
    \protect\@numberstringF{#2}{\@fc@numstr}%
  }%
  {%
    \ifthenelse{\equal{#3}{n}}%
    {%
      \protect\@numberstringN{#2}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#3}{m}}%
      {}%
      {%
        \PackageError{fmtcount}%
        {Invalid gender option `#3'}%
        {Available options are m or f}%
      }%
      \protect\@numberstringM{#2}{\@fc@numstr}%
    }%
  }%
  \expandafter\edef\csname @fcs@#1\endcsname{%
    \noexpand\MakeUppercase{\@fc@numstr}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\NUMBERstring}
% Display upper case textual representation of a number. The
% argument must be a counter.
%    \begin{macrocode}
\newcommand*{\NUMBERstring}[1]{%
  \expandafter\protect\expandafter\NUMBERstringnum{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\NUMBERstringnum}
% As above, but the argument is a count register or a number.
%\changes{1.31}{2009/10/02}{replaced \cs{@ifnextchar} with
%\cs{new@ifnextchar}}
%    \begin{macrocode}
\newcommand*{\NUMBERstringnum}[1]{%
  \new@ifnextchar[%
  {\@NUMBER@string{#1}}%
  {\@NUMBER@string{#1}[m]}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@NUMBER@string}
% Gender is specified as an optional argument at the end.
%    \begin{macrocode}
\def\@NUMBER@string#1[#2]{%
  {%
    \ifthenelse{\equal{#2}{f}}%
    {%
      \protect\@numberstringF{#1}{\@fc@numstr}%
    }%
    {%
      \ifthenelse{\equal{#2}{n}}%
      {%
         \protect\@numberstringN{#1}{\@fc@numstr}%
      }%
      {%
        \ifthenelse{\equal{#2}{m}}%
        {}%
        {%
          \PackageError{fmtcount}%
          {Invalid gender option `#2'}%
          {Available options are m, f or n}%
        }%
        \protect\@numberstringM{#1}{\@fc@numstr}%
      }%
    }%
    \MakeUppercase{\@fc@numstr}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\binary}
% Number representations in other bases. Binary:
%    \begin{macrocode}
\providecommand*{\binary}[1]{%
  \expandafter\protect\expandafter\@binary{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\aaalph}
% Like \ics{alph}, but goes beyond 26.
% (a \ldots\ z aa \ldots zz \ldots)
%    \begin{macrocode}
\providecommand*{\aaalph}[1]{%
  \expandafter\protect\expandafter\@aaalph{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\AAAlph}
% As before, but upper case.
%    \begin{macrocode}
\providecommand*{\AAAlph}[1]{%
  \expandafter\protect\expandafter\@AAAlph{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\abalph}
% Like \ics{alph}, but goes beyond 26. 
% (a \ldots\ z ab \ldots az \ldots)
%    \begin{macrocode}
\providecommand*{\abalph}[1]{%
  \expandafter\protect\expandafter\@abalph{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ABAlph}
% As above, but upper case.
%    \begin{macrocode}
\providecommand*{\ABAlph}[1]{%
  \expandafter\protect\expandafter\@ABAlph{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\hexadecimal}
% Hexadecimal:
%    \begin{macrocode}
\providecommand*{\hexadecimal}[1]{%
  \expandafter\protect\expandafter\@hexadecimal{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\Hexadecimal}
% As above, but in upper case.
%    \begin{macrocode}
\providecommand*{\Hexadecimal}[1]{%
  \expandafter\protect\expandafter\@Hexadecimal{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\octal}
% Octal:
%    \begin{macrocode}
\providecommand*{\octal}[1]{%
  \expandafter\protect\expandafter\@octal{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\decimal}
% Decimal:
%    \begin{macrocode}
\providecommand*{\decimal}[1]{%
  \expandafter\protect\expandafter\@decimal{%
    \expandafter\the\csname c@#1\endcsname}%
}
%    \end{macrocode}
%\end{macro}
%
%\subsection{Multilinguage Definitions}
%\begin{macro}{\@setdef@ultfmtcount}
% If multilingual support is provided, make \cs{@numberstring}
% etc use the correct language (if defined).
% Otherwise use English definitions. \cs{@setdef@ultfmtcount}
% sets the macros to use English.
%    \begin{macrocode}
\def\@setdef@ultfmtcount{%
  \ifcsundef{@ordinalMenglish}{\FCloadlang{english}}{}%
  \def\@ordinalstringM{\@ordinalstringMenglish}%
  \let\@ordinalstringF=\@ordinalstringMenglish
  \let\@ordinalstringN=\@ordinalstringMenglish
  \def\@OrdinalstringM{\@OrdinalstringMenglish}%
  \let\@OrdinalstringF=\@OrdinalstringMenglish
  \let\@OrdinalstringN=\@OrdinalstringMenglish
  \def\@numberstringM{\@numberstringMenglish}%
  \let\@numberstringF=\@numberstringMenglish
  \let\@numberstringN=\@numberstringMenglish
  \def\@NumberstringM{\@NumberstringMenglish}%
  \let\@NumberstringF=\@NumberstringMenglish
  \let\@NumberstringN=\@NumberstringMenglish
  \def\@ordinalM{\@ordinalMenglish}%
  \let\@ordinalF=\@ordinalM
  \let\@ordinalN=\@ordinalM
  \let\fmtord\fc@orddef@ult
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\fc@multiling}
%\changes{2.02}{2012-10-24}{new}
%\cs{fc@multiling}\marg{name}\marg{gender}
%\changes{3.00}{2014-07-18}{Use \cs{protect}, not \cs{string} in \cs{PackageWarning} to quote macros like
% shown in \texttt{clsguide.pdf}}
%    \begin{macrocode}
\newcommand*{\fc@multiling}[2]{%
  \ifcsundef{@#1#2\languagename}%
  {% try loading it
     \FCloadlang{\languagename}%
  }%
  {%
  }%
  \ifcsundef{@#1#2\languagename}%
  {%
    \PackageWarning{fmtcount}%
    {No support for \expandafter\protect\csname #1\endcsname\space for
     language '\languagename'}%
    \ifthenelse{\equal{\languagename}{\fc@mainlang}}%
    {%
       \FCloadlang{english}%
    }%
    {%
    }%
    \ifcsdef{@#1#2\fc@mainlang}%
    {%
       \csuse{@#1#2\fc@mainlang}%
    }%
    {%
       \PackageWarningNoLine{fmtcount}%
       {No languages loaded at all! Loading english definitions}%
       \FCloadlang{english}%
       \def\fc@mainlang{english}%
       \csuse{@#1#2english}%
    }%
  }%
  {%
    \csuse{@#1#2\languagename}%
  }%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\@set@mulitling@fmtcount}
% This defines the number and ordinal string macros to use 
% \cs{languagename}:
%\changes{2.0}{2012-06-18}{changed errors to warnings for
%unsupported languages}
%    \begin{macrocode}
\def\@set@mulitling@fmtcount{%
%    \end{macrocode}
% The masculine version of \cs{numberstring}:
%    \begin{macrocode}
  \def\@numberstringM{%
    \fc@multiling{numberstring}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{numberstring}:
%    \begin{macrocode}
  \def\@numberstringF{%
    \fc@multiling{numberstring}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{numberstring}:
%    \begin{macrocode}
  \def\@numberstringN{%
    \fc@multiling{numberstring}{N}%
  }%
%    \end{macrocode}
% The masculine version of \cs{Numberstring}:
%    \begin{macrocode}
  \def\@NumberstringM{%
    \fc@multiling{Numberstring}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{Numberstring}:
%    \begin{macrocode}
  \def\@NumberstringF{%
    \fc@multiling{Numberstring}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{Numberstring}:
%    \begin{macrocode}
  \def\@NumberstringN{%
    \fc@multiling{Numberstring}{N}%
  }%
%    \end{macrocode}
% The masculine version of \cs{ordinal}:
%    \begin{macrocode}
  \def\@ordinalM{%
    \fc@multiling{ordinal}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{ordinal}:
%    \begin{macrocode}
  \def\@ordinalF{%
    \fc@multiling{ordinal}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{ordinal}:
%    \begin{macrocode}
  \def\@ordinalN{%
    \fc@multiling{ordinal}{N}%
  }%
%    \end{macrocode}
% The masculine version of \cs{ordinalstring}:
%    \begin{macrocode}
  \def\@ordinalstringM{%
    \fc@multiling{ordinalstring}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{ordinalstring}:
%    \begin{macrocode}
  \def\@ordinalstringF{%
    \fc@multiling{ordinalstring}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{ordinalstring}:
%    \begin{macrocode}
  \def\@ordinalstringN{%
    \fc@multiling{ordinalstring}{N}%
  }%
%    \end{macrocode}
% The masculine version of \cs{Ordinalstring}:
%    \begin{macrocode}
  \def\@OrdinalstringM{%
    \fc@multiling{Ordinalstring}{M}%
  }%
%    \end{macrocode}
% The feminine version of \cs{Ordinalstring}:
%    \begin{macrocode}
  \def\@OrdinalstringF{%
    \fc@multiling{Ordinalstring}{F}%
  }%
%    \end{macrocode}
% The neuter version of \cs{Ordinalstring}:
%    \begin{macrocode}
  \def\@OrdinalstringN{%
    \fc@multiling{Ordinalstring}{N}%
  }%
%    \end{macrocode}
% Make \cs{fmtord} language dependent:
% \changes{3.01}{2014-12-18}{Make \cs{fmtord} language dependent.}
%    \begin{macrocode}
  \let\fmtord\fc@ord@multiling
}
%    \end{macrocode}
%\end{macro}
% Check to see if \styfmt{babel}, \styfmt{polyglossia} or \styfmt{ngerman} packages have been loaded, and if
% yes set \styfmt{fmtcount} in multiling.
%    \begin{macrocode}
\expandafter\@ifpackageloaded
\expandafter{\ifxetex polyglossia\else babel\fi}%
{%
  \@set@mulitling@fmtcount
}%
{%
  \@ifpackageloaded{ngerman}%
  {%
    \FCloadlang{ngerman}%
    \@set@mulitling@fmtcount
  }%
  {%
%    \end{macrocode}
% In the case that neither babel/polyglossia, nor ngerman has been loaded, then we go to multiling if a
% language has been loaded by package option, and to delfault language otherwise.
%    \begin{macrocode}
    \iffmtcount@language@option
        \@set@mulitling@fmtcount
%    \end{macrocode}
% Some sanity check at the beginning of document may help the end user understand what is wrong:
%    \begin{macrocode}
        \AtBeginDocument{%
          \ifcsundef{languagename}%
          {%
            \PackageWarning{fmtcount}{%
              `\protect\languagename' is undefined, you should use package babel/polyglossia when loading a
              language via package option. Reverting to default language.
            }%
            \@setdef@ultfmtcount
          }{%
            \@FC@iflangloaded{\languagename}{}{%
%    \end{macrocode}
% The current \cs{languagename} is not a language that has been previously loaded. The correction is to have
% \cs{languagename} let to \cs{fc@mainlang}. Please note that, as \cs{iffmtcount@language@option} is true,
% we know that \texttt{fmtcount} has loaded some language.
%    \begin{macrocode}
              \PackageWarning{fmtcount}{%
                Setting `\protect\languagename' to `\fc@mainlang'.\MessageBreak
                Reason is that `\protect\languagename' was `\languagename',\MessageBreak
                but `\languagename' was not loaded by fmtcount,\MessageBreak
                whereas `\fc@mainlang' was the last language loaded by fmtcount ;
              }%
              \let\languagename\fc@mainlang
            }
          }%
        }
    \else
       \@setdef@ultfmtcount
    \fi
  }%
}
%    \end{macrocode}
% \changes{3.01}{2014-12-21}{Substitute \cs{textsuperscript} for \cs{fc@textsuperscript}, and define
% \cs{fc@textsuperscript} as \cs{fup} when defined at beginning of document, or as \cs{textsuperscript}
% otherwise}
%    \begin{macrocode}
\AtBeginDocument{%
   \ifcsundef{FBsupR}{\let\fc@textsuperscript\textsuperscript}{\let\fc@textsuperscript\fup}%
}
%    \end{macrocode}
% Backwards compatibility:
%    \begin{macrocode}
\let\@ordinal=\@ordinalM
\let\@ordinalstring=\@ordinalstringM
\let\@Ordinalstring=\@OrdinalstringM
\let\@numberstring=\@numberstringM
\let\@Numberstring=\@NumberstringM
%    \end{macrocode}
\iffalse Local variables: \fi
\iffalse mode: docTeX     \fi
\iffalse End:             \fi
%\iffalse
%    \begin{macrocode}
%</fmtcount.sty>
%    \end{macrocode}
%\fi
%\Finale
\endinput
