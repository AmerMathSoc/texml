%\iffalse
% datetime.dtx generated using makedtx version 1.1 (c) Nicola Talbot
% Command line args:
%   -doc "datetime-manual.tex"
%   -setambles ".*\.perl=>\nopreamble\nopostamble"
%   -author "Nicola Talbot"
%   -macrocode "datetime.perl"
%   -comment "datetime.perl"
%   -comment "dt-.+\.tex"
%   -src "(.+)\.(sty)=>\1.\2"
%   -src "(.+)\.(def)=>\1.\2"
%   -src "(dt-.+)\.(tex)=>\1.\2"
%   -src "datetime.perl\Z=>datetime.perl"
%   datetime
% Created on 2015/3/20 16:54
%\fi
%\iffalse
%<*package>
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
%</package>
%\fi
% \iffalse
% Doc-Source file to use with LaTeX2e
% Copyright (C) 2015 Nicola Talbot, all rights reserved.
% \fi
% \iffalse
%<*driver>
\documentclass{nlctdoc}

\usepackage[colorlinks,
            bookmarks,
            bookmarksopen,
            hyperindex=false,
            pdfauthor={Nicola L.C. Talbot},
            pdftitle={datetime.sty: A Date and Time Package},
            pdfkeywords={date,time,LaTeX}]{hyperref}



\begin{document}
\DocInput{datetime.dtx}
\end{document}
%</driver>
%\fi
%\RecordChanges
%\OnlyDescription
%
%\title{datetime.sty v2.60: 
%Formatting Current Date and Time}
% \author{Nicola L. C. Talbot\\[10pt]
% Dickimaw Books\\
% \url{http://www.dickimaw-books.com/}}
% \date{2015-03-20}
% \maketitle
%
%\begin{important}
%This is the last version of this package. The replacement package is
%called \sty{datetime2} and will be released shortly after the
%this final version.
%\end{important}
%
% \tableofcontents
%
% \section{Introduction}
%\changes{1.0}{2000/08/08}{First release}
%\changes{1.01}{2000/09/18}{Documentation added}
%The \styfmt{datetime} package is a \LaTeXe\ package that 
%provides various different formats for \ics{today},
%and provides commands for displaying the current time.  
%If you only want the 
%time commands but not the date changing commands, you can pass 
%the option \pkgopt{nodate} to the package.
%\changes{2.3}{2004/05/01}{nodate package option added}
%
%\changes{2.41}{2004/10/22}{split package into two files: 
%datetime.sty and fmtcount.sty}
%Since version 2.4, the \styfmt{datetime} package has been 
%separated into two packages: \styfmt{datetime} and 
%\sty{fmtcount}.  When I originally created this package, 
%I defined the commands, \ics{ordinal} etc which could be used 
%in the definition of \cs{today}.  Since then, I have extended 
%the number of commands available that can be used to display the 
%value of a \LaTeX\ counter, however it seems more appropriate to 
%define all these counter-related commands in a separate package. 
%The \sty{fmtcount} package is now distributed separately 
%from the \styfmt{datetime} package, and will also need to 
%be installed.
%
%\changes{2.42}{2004/11/01}{made package compatible with babel}
%As from version 2.42, the \styfmt{datetime} package is now 
%compatible with \sty{babel}, however you must load the 
%\styfmt{datetime} package \emph{after} the \sty{babel} package.  
%For example:
%\begin{verbatim}
%\usepackage[francais]{babel}
%\usepackage{datetime}
%\end{verbatim}
%
% \section{Predefined Date Formats}
% There are various declarations that change the effect of 
%\ics{today}.  The change can be localised by placing the 
%declaration within a group.
%
%As from version 2.43, the numerical date formats (such as 
%\ics{ddmmyyyydate}) use the command
%\begin{definition}[\DescribeMacro{\dateseparator}]
%\cs{dateseparator}
%\end{definition}
%to separate the numbers.  So, for example, if you want to hyphens
%instead of slashes, you can do:
%\begin{verbatim}
%\renewcommand{\dateseparator}{-}
%\end{verbatim}
%
%\subsection{ISO format}
%
%\begin{definition}[\DescribeMacro{\yyyymmdddate}]
%\cs{yyyymmdddate}
%\end{definition}
%This declaration will redefine \ics{today} to produce the current
%date displayed in the form 2000/03/08. (You can redefine
%\ics{dateseparator} to \texttt{-} to change to 2000-03-08.)
%
%\subsection{\texorpdfstring{\meta{Day} \meta{Month} \meta{Year}}{Day Month Year} formats}
%
%\begin{definition}[\DescribeMacro{\longdate}]
%\cs{longdate}
%\end{definition}
%This declaration will redefine \ics{today} to produce the current
%date displayed in the form Wednesday 8\textsuperscript{th} March,
%2000 if the package option \pkgopt{dayofweek} is used, or
%8\textsuperscript{th} March, 2000 if the package option
%\pkgopt{nodayofweek} is used.
%
%\begin{definition}[\DescribeMacro{\shortdate}]
%\cs{shortdate}
%\end{definition}
%This declaration will redefine \ics{today} to produce the current
%date displayed in the form Wed 8\textsuperscript{th} Mar, 2000 if
%the package option \pkgopt{dayofweek} is used, or
%8\textsuperscript{th} Mar, 2000 if the package option
%\pkgopt{nodayofweek} is used.
%
%\begin{definition}[\DescribeMacro{\ddmmyyyydate}]
%\cs{ddmmyyyydate}
%\end{definition}
%This declaration will redefine \ics{today} to produce the current
%date displayed in the form 08/03/2000.
%
%\begin{definition}[\DescribeMacro{\dmyyyydate}]
%\cs{dmyyyydate}
%\end{definition}
%This declaration will redefine \ics{today} to produce the current
%date displayed in the form 8/3/2000.
%
%\begin{definition}[\DescribeMacro{\ddmmyydate}]
%\cs{ddmmyydate}
%\end{definition}
%This declaration will redefine \ics{today} to produce the current
%date displayed in the form 08/03/00.
%
%\begin{definition}[\DescribeMacro{\dmyydate}]
%\cs{dmyydate}
%\end{definition}
%This declaration will redefine \ics{today} to produce the current
%date displayed in the form 8/3/00.
%
%\begin{definition}[\DescribeMacro{\textdate}]
%\cs{textdate}
%\end{definition}
%This declaration will redefine \ics{today} to produce the current
%date displayed in the form: Wednesday the Eighth of March, Two
%Thousand if the package option \pkgopt{dayofweek} is used, or Eighth
%of March, Two Thousand if the package option \pkgopt{nodayofweek} is
%used. Note that \cs{textdate} is defined for use with English, it
%won't look right if it is used when another language has been
%selected\footnote{in fact, you may get an error from the
%\sty{fmtcount} package if you are using a language that it doesn't
%support.}.  If you want to define a similar command for another
%language, you will first need to check that the \sty{fmtcount}
%package supports that language.
%
%\subsection{\texorpdfstring{\meta{Month} \meta{Day} \meta{Year}}{Month Day Year} formats}
%
%\begin{definition}[\DescribeMacro{\usdate}]
%\cs{usdate}
%\end{definition}
%This declaration will redefine \cs{today} to produce the current
%date displayed in the form March 8, 2000. (As \TeX\ and \LaTeX\ do
%by default.)
%
%\begin{definition}[\DescribeMacro{\mmddyyyydate}]
%\cs{mmddyyyydate}
%\end{definition}
%This declaration will redefine \ics{today} to produce the current
%date displayed in the form 03/08/2000.
%
%\begin{definition}[\DescribeMacro{\mdyyyydate}]
%\cs{mdyyyydate}
%\end{definition}
%This declaration will redefine \verb"\today" to produce the current
%date displayed in the form 3/8/2000.
%
%\begin{definition}[\DescribeMacro{\mmddyydate}]
%\cs{mmddyydate}
%\end{definition}
%This declaration will redefine \ics{today} to produce the current
%date displayed in the form 03/08/00.
%
%\begin{definition}[\DescribeMacro{\mdyydate}]
%\cs{mdyydate}
%\end{definition}
%This declaration will redefine \ics{today} to produce the current
%date displayed in the form 3/8/00.
%
%\subsection{Dates defined by \texorpdfstring{\styfmt{babel}}{babel}}
%
%In addition to the above, the declarations \cs{date}\meta{lang} are
%available for all languages defined either by calling \sty{babel}
%prior to \styfmt{datetime} or by passing the language name as an
%option to \styfmt{datetime}.  See~\sectionref{sec:newdate} if you
%want to define your own customised date format.
%
% \section{Time Commands}
%
%The current time is displayed using the command 
%\begin{definition}[\DescribeMacro{\currenttime}]
%\cs{currenttime}
%\end{definition}
%
%A specific time can be displayed using the command
%\begin{definition}[\DescribeMacro{\formattime}]
%\cs{formattime}\marg{hour}\marg{minute}\marg{second}
%\end{definition}
%where \meta{hour} is a number from~0 to~23, and \meta{minute} and
%\meta{second} are numbers from~0 to~59.
%
%The format can be changed using the declaration
%\begin{definition}[\DescribeMacro{\settimeformat}]
%\cs{settimeformat}\marg{style}
%\end{definition}
%where \meta{style} is the name of the
%format. Predefined formats are:
%\begin{description}
%\item[xxivtime] Twenty-four hour time in the form 22:28 (Default)
%\item[hhmmsstime] Twenty-four hour time in the form 22:28:00
%\item[ampmtime] Twelve hour time in the form 10:28pm
%\item[oclock] Displays the current time as a string, e.g.\ 
%Twenty-Eight minutes past Ten in the afternoon.
%\end{description}
%
%New time formats can be defined using the command:
%\begin{definition}[\DescribeMacro{\newtimeformat}]
%\cs{newtimeformat}\marg{name}\marg{format}
%\end{definition}
%where \meta{name} is the name of the new format (used in
%\ics{settimeformat}), and \meta{format} is how to format the time.
%Within \meta{format} you can use the counters \ctr{HOUR} (number
%of hours after midnight), \ctr{MINUTE} (number of minutes past
%the hour), \ctr{SECOND} (number of seconds) \ctr{HOURXII}
%(number of hours after midnight/midday), \ctr{TOHOUR} (the next
%hour) and \ctr{TOMINUTE} (number of minutes to the next hour),
%and the corresponding commands: \ics{THEHOUR}, \ics{THEMINUTE},
%\ics{THESECOND}, \ics{THEHOURXII}, \ics{THETOHOUR} and
%\ics{THETOMINUTE}.
%
%For example, to define a new time format that uses a dot instead of a
%colon:
%\begin{verbatim}
%\newtimeformat{dottime}{\twodigit{\THEHOUR}.\twodigit{\THEMINUTE}}
%\end{verbatim}
%You then need to switch to this new format before you can use it:
%\begin{verbatim}
%\settimeformat{dottime}
%\currenttime
%\end{verbatim}
%
%As from version 2.43, if you only want to change the separator, 
%you can simply redefine
%\begin{definition}[\DescribeMacro{\timeseparator}]
%\cs{timeseparator}
%\end{definition}
%instead of defining a new time format.  For example:
%\begin{verbatim}
%\renewcommand{\timeseparator}{.}
%\end{verbatim}
%The \texttt{xxivtime} format will now work like the \texttt{dottime} 
%format defined above.
%
% \section{Formating Dates}
%\begin{definition}[\DescribeMacro{\pdfdate}]
%\cs{pdfdate}
%\end{definition}
% This command\footnote{thanks to Ulrich Dirr for 
%asking about this} prints the date in the format required for
% PDF files, e.g.\ if the date is 1 May 2004 and time is
% 22:02, \verb"\pdfdate" will print 20040501220200.  The reason 
%this date format is separate from all the others is because the 
%other form doesn't get properly expanded by PDF\TeX. (This 
%command is defined regardless of whether the package option 
%\texttt{nodate} is called.)
%Example:
%\begin{verbatim}
%\pdfinfo{
%   /Author (Me)
%   /Title (A Sample Document)
%   /CreationDate (D:20040501215500)
%   /ModDate (D:\pdfdate)
%}
%\end{verbatim}
%\textbf{Note} that PDF\TeX\ introduced the new primitive
%\cs{pdfcreationdate} in version 1.30.0, so \cs{pdfdate} isn't
%required with newer versions of PDF\TeX. (\cs{pdfcreationdate}
%is better than \cs{pdfdate} as it also stores the time zone.)
% 
% There are two commands that print the name of the current
% month:
%\begin{definition}[\DescribeMacro{\monthname}]
%\cs{monthname}\oarg{num}
%\end{definition}
%prints the current month name in full, 
%e.g.\ August, and 
%\begin{definition}[\DescribeMacro{\shortmonthname}]
%\cs{shortmonthname}\oarg{num}
%\end{definition}
%prints the abbreviated month name, e.g.\ Aug.  Both \cs{monthname}
%and \cs{shortmonthname} take an optional argument (a number from 1
%to 12) if the name of a specific month is required.  For example,
%\verb"\monthname[6]" will produced the output: June.
%
% The day of the week is computed using the algorithm documented at
% \url{http://userpages.wittenburg.edu/bshelburne/Comp150/DayOfWeek.htm}.
% This algorithm works for any date between 1\textsuperscript{st} 
%Jan, 1901 and 31\textsuperscript{st} Dec, 2099.
% The following macros display the day of week for a given date:
%
%\begin{definition}[\DescribeMacro{\dayofweekname}]
%\cs{dayofweekname}\marg{day}\marg{month}\marg{year}
%\end{definition}
%prints the day of week for the specified date.  For example, 
%\begin{verbatim}
%\dayofweekname{31}{10}{2002}
%\end{verbatim}
%will produce the output: Thursday.
%
%\begin{definition}[\DescribeMacro{\shortdayofweekname}]
%\cs{shortdayofweekname}\meta{day}\marg{month}\marg{year}
%\end{definition}
%prints the abbreviated name for the day of week for the specified
%date. For example
%\begin{verbatim}
%\shortdayofweekname{31}{10}{2002}
%\end{verbatim}
%will produce the output: Thu.
%
%\begin{definition}[\DescribeMacro{\ifshowdow}]
%\cs{ifshowdow}
%\end{definition}
%This \TeX\ conditional can be used to determine whether or not the
%option \pkgopt{dayofweek} has been passed to the package. For
%example:
%\begin{verbatim}
%\ifshowdow\dayofweekname{31}{10}{2002} \fi
%\end{verbatim}
%will only display the day of week if the \pkgopt{dayofweek} option
%was passed to \styfmt{datetime}. Alternatively, you can use
%David~Carlisle's \sty{ifthen} package:
%\begin{verbatim}
%\ifthenelse{\boolean{showdow}}{\dayofweekname{31}{10}{2002} }{}
%\end{verbatim}
%
%The command
%\begin{definition}[\DescribeMacro{\ordinaldate}]
%\cs{ordinaldate}\marg{number}
%\end{definition}
%displays \meta{number} as a date-type ordinal. If the current
%language is English, this will simply pass the argument to
%\ics{ordinalnum} (defined in the \sty{fmtcount} package), if the
%current language is Breton, Welsh or French, a superscript will only
%be added if \meta{number} is 1, otherwise only \meta{number} will be
%displayed.
%
%The macro\footnote{Note the name change since version 1.1. The
%command name was changed from \cs{thedate} to \cs{formatdate} to
%avoid a name clash when using the \sty{seminar} class file.}
%\begin{definition}[\DescribeMacro{\formatdate}]
%\cs{formatdate}\marg{day}\marg{month}\marg{year}
%\end{definition}
%formats the specified date according to the current format of
%\ics{today}\footnote{To be more precise, \ics{today} is defined to
%be \ics{formatdate}\{\cs{day}\}\{\cs{month}\}\{\cs{year}\} where
%\ics{longdate} etc change the definition of \cs{formatdate}}.
%(Arguments must all be integers.) For example, in combination with
%\ics{longdate}, the command
%\begin{verbatim}
%\formatdate{27}{9}{2004}
%\end{verbatim}
%will produce the output: Monday 27\textsuperscript{th} September,
%2004.
%
%You can ensure that a number is displayed with at least two digits
%using the command
%\begin{definition}[\DescribeMacro{\twodigit}]
%\cs{twodigit}\marg{num}
%\end{definition}
%
%\section{Defining New Date Formats}\label{sec:newdate}
%
%New date formats can be defined using the command:
%\begin{definition}[\DescribeMacro{\newdateformat}]
% \cs{newdateformat}\marg{name}\marg{format}
%\end{definition}
%where \meta{name} is the name of the new format, and \meta{format}
%is how to format the date. Within the argument \meta{format} you can
%use the commands \ics{THEDAY}, \ics{THEMONTH} and \ics{THEYEAR} to
%represent the relevant day, month and year, or you can use the
%counters \ctr{DAY}, \ctr{MONTH} and \ctr{YEAR} if you want to use
%\ics{ordinal} etc. Once you have defined the new date format, you
%can then switch to it using the declaration \verb'\'\meta{name}
%(i.e.\ the name you specified preceded by a backslash), and
%subsequent calls to \ics{today} and \ics{formatdate} will use your
%new format.
%
%For example, suppose you want to define a new date format called,
%say, \texttt{mydate}, that will typeset the date in the form: 
%8-3-2002, then you can do:
%\begin{verbatim}
%\newdateformat{mydate}{\THEDAY-\THEMONTH-\THEYEAR}
%\end{verbatim}
%\ics{newdateformat} will then define the declaration 
%\cs{mydate} which can be used to
%switch to your new format. In the following example, 
%two new date formats are defined, and they are then
%selected to produce two different formats for the current date:
%\begin{verbatim}
%\newdateformat{dashdate}{%
%\twodigit{\THEDAY}-\twodigit{\THEMONTH}-\THEYEAR}
%
%\newdateformat{usvardate}{%
%\monthname[\THEMONTH] \ordinal{DAY}, \THEYEAR}
%
%Dash: \dashdate\today.
%US: \usvardate\today.
%\end{verbatim}
%If the current date is, say, 8th March, 2002, the above code will
%produce the following: Dash: 08-03-2002.  US: March
%8\textsuperscript{th}, 2002.
%
%Note that \ics{THEDAY} etc and \ctr{DAY} etc have no real 
%meaning outside \ics{newdateformat} (this is why they 
%are in uppercase). Incidentally, the \texttt{dashdate} format
%is not really necessary, as you can achieve this format
%using:
%\begin{verbatim}
%\renewcommand{\dateseparator}{-}
%\ddmmyyyydate
%\end{verbatim}
%
%Another note: in the above code, \ics{ordinal} was
%used to illustrate the use of the \ctr{DAY} counter.  It
%is better to use \ics{ordinaldate} instead:
%\begin{verbatim}
%\newdateformat{usvardate}{%
%\monthname[\THEMONTH] \ordinaldate{\THEDAY}, \THEYEAR}
%\end{verbatim}
%
%\section{Saving Dates}
%
%It is possible to save a date for later use using the command:
%\footnote{Thanks to Denis Bitouz\'e for asking about this}
%\begin{definition}[\DescribeMacro{\newdate}]
%\cs{newdate}\marg{name}\marg{day}\marg{month}\marg{year}
%\end{definition}
%
%This date can later be displayed using the same format as that
%used by \ics{formatdate} using the command:
%\begin{definition}[\DescribeMacro{\displaydate}]
%\cs{displaydate}\marg{name}
%\end{definition}
%
%Individual elements of the date can be extracted using the
%commands:
%\begin{definition}[\DescribeMacro{\getdateday}]
%\cs{getdateday}\marg{name}
%\end{definition}
%\begin{definition}[\DescribeMacro{\getdatemonth}]
%\cs{getdatemonth}\marg{name}
%\end{definition}
%\begin{definition}[\DescribeMacro{\getdateyear}]
%\cs{getdateyear}\marg{name}
%\end{definition}
%
%\section{Predefined Names}
%
%The following commands are defined by the \styfmt{datetime} 
%package:
%
%\begin{tabular}{ll}
%\bfseries Command Name & \bfseries Default Value\\
%\ics{dateseparator} & \verb'/'\\
%\ics{timeseparator} & \verb':'\\
%\ics{amname} & \texttt{am}\\
%\ics{pmname} & \texttt{pm}\\
%\ics{amorpmname} & \ics{amname} if morning, otherwise \ics{pmname}\\
%\ics{amstring} & \texttt{in the morning}\\
%\ics{pmstring} & \texttt{in the afternoon}\\
%\ics{amorpmstring} & \ics{amstring} if morning, otherwise 
%\ics{pmstring}\\
%\ics{halfpast} & \texttt{Half past}\\
%\ics{quarterpast} & \texttt{Quarter past}\\
%\ics{quarterto} & \texttt{Quarter to}\\
%\ics{noon} & \texttt{Noon}\\
%\ics{midnight} & \texttt{Midnight}\\
%\ics{oclockstring} & \texttt{O'Clock}
%\end{tabular}
%
%\section{Package Options}
%
% The following options may be passed to this package:
%\begin{description}
%\item[\pkgopt{long}] make \cs{today} produce long date
%\item[\pkgopt{short}] make \cs{today} produce short date
%\item[\pkgopt{yyyymmdd}] make \cs{today} produce YYYY/MM/DD date
%\item[\pkgopt{ddmmyyyy}] make \cs{today} produce DD/MM/YYYY date
%\item[\pkgopt{dmyyyy}] make \cs{today} produce D/M/YYYY date
%\item[\pkgopt{ddmmyy}] make \cs{today} produce DD/MM/YY date
%\item[\pkgopt{dmyy}] make \cs{today} produce D/M/YY date
%\item[\pkgopt{text}] make \cs{today} produce text date in UK style
%\item[\pkgopt{us}] make \cs{today} produce US style date
%\item[\pkgopt{mmddyyyy}] make \cs{today} produce MM/DD/YYYY date
%\item[\pkgopt{mdyyyy}] make \cs{today} produce M/D/YYYY date
%\item[\pkgopt{mmddyy}] make \cs{today} produce MM/DD/YY date
%\item[\pkgopt{mdyy}] make \cs{today} produce M/D/YY date
%\item[\pkgopt{raise}] make ordinal st,nd,rd,th appear as superscript
%\item[\pkgopt{level}] make ordinal st,nd,rd,th appear level with rest of 
%text
%\item[\pkgopt{dayofweek}] make the day of week appear for \ics{longdate}, 
%\ics{shortdate} 
%            or \ics{textdate}
%\item[\pkgopt{nodayofweek}] don't display the day of week.
%\item[\pkgopt{hhmmss}] make \cs{currenttime} produce \texttt{hhmmsstime} 
%format
%\item[\pkgopt{24hr}] make \cs{currenttime} produce \texttt{xxivtime} 
%format
%\item[\pkgopt{12hr}] make \cs{currenttime} produce \texttt{ampmtime} 
%format
%\item[\pkgopt{oclock}] make \cs{currenttime} produce \texttt{oclock} 
%format
%\item[\pkgopt{nodate}] Don't redefine \cs{today} or define the month or 
%day of week commands
%           (useful if you only want the time commands) 
%\item[\pkgopt{iso}] as \pkgopt{ddmmyyyy} and \pkgopt{hhmmss} but
%also sets date separator to \texttt{-}
% and time separator to \texttt{:}
% \end{description}
%
%The default options are: \pkgopt{long}, \pkgopt{raise},
%\pkgopt{dayofweek} and \pkgopt{24hr}.
%
%\section{Multilingual Support}
%
%If you use the \sty{ngerman} package, you must use \styfmt{datetime}'s
%\pkgopt{ngerman} package option if you want the date displayed
%in the same form as \sty{ngerman}. You must also load \sty{ngerman}
%\emph{before} you load \styfmt{datetime}. Similarly for the
%\sty{german} package.
%
%If you want to use the \sty{babel} package, you must load
%it \emph{before} you load the \styfmt{datetime} package. This
%is because the \sty{babel} \cs{date}\meta{lang} commands
%redefine \ics{today}, whereas the \sty{datetime} package
%redefines \cs{today} to use \ics{formatdate}, and the
%date formatting commands (such as \ics{longdate}) redefine
%\cs{formatdate} rather than \cs{today}. This ensures 
%consistent formatting of the dates whether you use \cs{today} or
%\cs{formatdate}.  Therefore, the \styfmt{datetime} package
%has to redefine all the \cs{date}\meta{lang} commands accordingly.
%Thus the multilingual date support is mostly limited to that provided
%by \sty{babel}. Additional support, such as the day of
%week names and abbreviations, are only supplied for those
%languages that I know, or that other people have been able to supply
%for me.
%
%As from v2.56, the package options supplied to \styfmt{datetime}
%override \sty{babel}'s date format. For example:
%\begin{verbatim}
%\usepackage[french,spanish]{babel}
%\usepackage[ddmmyyyy]{datetime}
%\end{verbatim}
%will use ddmmyyyy date format regardless of language. Note that
%if you use a declaration instead of a package option, for
%example:
%\begin{verbatim}
%\usepackage[french,spanish]{babel}
%\usepackage{datetime}
%\ddmmyyyydate
%\end{verbatim}
%the date format will be switched back to \cs{datefrench} or
%\cs{datespanish} whenever the language is set. You can use
%\begin{definition}[\DescribeMacro{\setdefaultdate}]
%\cs{setdefaultdate}\marg{declaration}
%\end{definition}
%to always use \marg{declaration} whenever the language
%is set. For example:
%\begin{verbatim}
%\setdefaultdate{\ddmmyyyydate}
%\end{verbatim}
%
%The commands \ics{monthname} and \ics{shortmonthname},
%will produce the month name in the current language.
%If you want the month name in a specific language, you
%can use the command \cs{monthname}\meta{lang}.
%For example, \verb"\monthnamefrench[6]" will produce the output: 
%juin. Note that \ics{textdate} is formatted for English dates,
%and won't look right if used with another language setting. If you
%want a textual date, the \sty{fmtcount} package (which is 
%loaded by \styfmt{datetime}) defines some commands which display
%a number or ordinal as a word, but it only has very limited 
%multilingual support. See the \sty{fmtcount} documentation 
%for further details.
%
%\section{Registers}
%
%\TeX\ provides \ics{day}, \ics{month} and \ics{year} registers. In
%addition, \styfmt{datetime} provides the registers: 
%\ics{currenthour}, \ics{currentminute} and \ics{currentsecond}. 
%Note that old distributions of \TeX\ will always have
%\cs{currentsecond} set to zero.
%
%\section{Configuration File}
%
%As from Version 2.4, the \styfmt{datetime} package will read in settings
%from the configuration file \texttt{datetime.cfg}, if it exists,
%which will override the default package options.  For example,
%suppose you prefer a short date without the day of week by default,
%you will need to create a file called \texttt{datetime.cfg} that
%contains the line:
%\begin{verbatim}
%\shortdate\showdowfalse
%\end{verbatim}
%The file \texttt{datetime.cfg} should then go somewhere on the 
%\TeX\ path.  Now all you need to do is:
%\begin{verbatim}
%\usepackage{datetime}
%\end{verbatim}
%without having to specify the \pkgopt{short} and 
%\pkgopt{nodayofweek} options.
%
%You can also use this file to define and set your own date 
%styles.  For example, you could create
%a configuration file that has the following lines:
%\begin{verbatim}
%\newdateformat{dashdate}{\twodigit{\THEDAY}-\twodigit{\THEMONTH}-\THEYEAR}
%\dashdate
%\end{verbatim}
%Whenever you use the \styfmt{datetime} package, it will now 
%use this format by default.
%
%\section{LaTeX2HTML styles}
%
%\changes{2.43}{2005/02/25}{Added LaTeX2HTML support}%
%\changes{2.44}{2005/03/03}{Fixed minor bugs in Perl scripts}
%Version 2.43 and above of the \styfmt{datetime} bundle 
%supplies the LaTeX2HTML style file \texttt{datetime.perl}.  
%This file should be placed in a 
%directory searched by LaTeX2HTML.  The following limitations 
%apply to the LaTeX2HTML styles:
%
%\begin{itemize}
%\item The configuration file \texttt{datetime.cfg}
%is currently ignored.  You can however
%do:
%\begin{verbatim}
%\usepackage{datetime}
%\html{\input{datetime.cfg}}
%\end{verbatim}
%This, I agree, is an unpleasant cludge.
%
%\item The commands \cs{monthname}\meta{language} are not 
%implemented.
%
%\item Some of the languages are not implemented.
%
%\item The package option \pkgopt{nodate} is not implemented.
%
%\end{itemize}
%
%\section{Troubleshooting}
%
%There is a \sty{datetime} FAQ available at:
%\url{http://www.dickimaw-books.com/faqs/datetimefaq.html}.
%
%\StopEventually{\phantomsection
%\addcontentsline{toc}{section}{Index}\PrintIndex
%}
%
%
%
%\section{The Code}
%\iffalse
%    \begin{macrocode}
%<*datetime-defaults.sty>
%    \end{macrocode}
%\fi
% Default language settings.
%    \begin{macrocode}
\ProvidesPackage{datetime-defaults}[2013/09/10]
%    \end{macrocode}
%\begin{macro}{\ordinaldateenglish}
% Default date ordinal:
%    \begin{macrocode}
\newcommand*{\ordinaldateenglish}[1]{\ordinalnum{#1}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\monthnameenglish}
%    \begin{macrocode}
\providecommand*{\monthnameenglish}[1][\month]{%
  \@orgargctr=#1\relax
  \ifcase\@orgargctr
  \PackageError{datetime}{Invalid Month number \the\@orgargctr}{Month
  numbers should go from 1 (January) to 12 (December)}%
  \or January%
  \or February%
  \or March%
  \or April%
  \or May%
  \or June%
  \or July%
  \or August%
  \or September%
  \or October%
  \or November%
  \or December%
  \else \PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
  Month numbers should go from 1 (January) to 12 (December)}%
  \fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortmonthnameenglish}
%\changes{2.1}{2003/12/17}{fixed bug producing an error message
% in December}
%    \begin{macrocode}
\providecommand*{\shortmonthnameenglish}[1][\month]{%
  \@orgargctr=#1\relax
  \ifcase\@orgargctr
  \PackageError{datetime}{Invalid Month number \the\@orgargctr}{Month
  numbers should go from 1 (jan) to 12 (dec)}%
  \or Jan%
  \or Feb%
  \or Mar%
  \or Apr%
  \or May%
  \or Jun%
  \or Jul%
  \or Aug%
  \or Sept%
  \or Oct%
  \or Nov%
  \or Dec%
  \else%
  \PackageError{datetime}%
  {Invalid Month number \the\@orgargctr}%
  {Month numbers should go from 1 (jan) to 12 (dec)}%
\fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dayofweeknameidenglish}
% Given the day of week index, print associated the English name.
%    \begin{macrocode}
\providecommand*{\dayofweeknameidenglish}[1]{%
  \ifcase#1\relax
  \or Sunday%
  \or Monday%
  \or Tuesday%
  \or Wednesday%
  \or Thursday%
  \or Friday%
  \or Saturday%
  \fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortdayofweeknameidenglish}
% As before, but for abbreviated day of week name. English version:
%    \begin{macrocode}
\providecommand*{\shortdayofweeknameidenglish}[1]{%
  \ifcase#1\relax
  \or Sun%
  \or Mon%
  \or Tue%
  \or Wed%
  \or Thu%
  \or Fri%
  \or Sat%
\fi}
%    \end{macrocode}
%\end{macro}
%\iffalse
%    \begin{macrocode}
%</datetime-defaults.sty>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*datetime.sty>
%    \end{macrocode}
%\fi
%\subsection{datetime.sty}
% This section documents the code for \texttt{datetime.sty}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{datetime}[2015/03/20 v2.60 Date Time Package]
%    \end{macrocode}
%\changes{2.59}{2013/09/10}{new loads etoolbox}
%    \begin{macrocode}
\RequirePackage{etoolbox}
%    \end{macrocode}
%\texttt{fmtcount.sty} needs to be loaded here as it defines the 
% command \cs{fmtord} which may be redefined later:
%    \begin{macrocode}
\RequirePackage{fmtcount}
%    \end{macrocode}
% In case we're using an older version of \sty{fmtcount}:
%    \begin{macrocode}
\@ifundefined{@FCmodulo}%
{%
  \let\@FCmodulo\@modulo
}{}
%    \end{macrocode}
% Need ifthen package for conditional stuff.
%    \begin{macrocode}
\RequirePackage{ifthen}
%    \end{macrocode}
%\subsubsection{Date Commands}
% Load defaults:
%    \begin{macrocode}
\RequirePackage{datetime-defaults}
%    \end{macrocode}
%\begin{macro}{\if@dtl@nodate}
% Define a new conditional \cs{if@dt@nodate}.  If it is true, 
% \cs{today} will not be redefined, nor will
% \cs{monthname}, \cs{shortmonthname}, \cs{dayofweek} and 
% \cs{shortdayofweek} be defined.
% Set it to false.
%    \begin{macrocode}
\newif\if@dt@nodate
\@dt@nodatefalse
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dateseparator}
% Define the character used to separate the numbers in the formats 
% defined by \cs{ddmmyyyy} etc
%\changes{2.43}{2005/02/25}{new}
%    \begin{macrocode}
\newcommand{\dateseparator}{/}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\if@dt@multilingual}
% Define switch to determine whether to enable multilingual support.
% This check to see if babel package is
% loaded instead of testing 'languagename (following suggestions on
% comp.text.tex)
%\changes{v2.49}{5 Dec 2006}{checks if babel package has been loaded}
% Note that babel must be loaded \emph{before} datetime, otherwise
% it will change the definitions of \cs{date}\meta{lang}.
%\changes{2.55}{2007/08/20}{fixed bug preventing multilingual support}
%    \begin{macrocode}
\newif\if@dt@multilingual
  \@ifpackageloaded{babel}%
  {%
    \@dt@multilingualtrue
  }%
  {%
    \@ifpackageloaded{ngerman}%
    {\@dt@multilingualtrue}%
    {\@dt@multilingualfalse}%
  }
%    \end{macrocode}
%\end{macro}
% Define the \cs{ordinaldate}\meta{language} macros. These are 
% needed because some
% languages only use an ordinal for the first day of
% the month (such as french).
% If |\ordinaldate|\meta{language} is not defined, then just display
% the number.
%\changes{2.45}{2005/05/23}{new}
%\changes{2.59}{2013/09/10}{made robust}
%    \begin{macrocode}
\DeclareRobustCommand*{\ordinaldate}[1]{%
  \if@dt@multilingual
%    \end{macrocode}
% Make sure language file has been loaded.
%    \begin{macrocode}
    \DTloadDefIfNotLoadedButExists{\languagename}%
    \@ifundefined{ordinaldate\languagename}{#1}%
    {%
      \csname ordinaldate\languagename\endcsname{#1}%
    }%
  \else
    \ordinalnum{#1}%
  \fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ifshowdow}
% Now define the declarations that redefine |\formatdate| as they
% are used by the package options. Need a conditional to determine
% whether or not to show the day of week name.
%    \begin{macrocode}
\newif\ifshowdow
%    \end{macrocode}
%\end{macro}
%\changes{1.1}{2002/04/20}{\cs{thedate} added}
%\begin{macro}{\formatdate}
% Initially |\formatdate| does nothing. It will be redefined later.
%\changes{2.0}{2002/10/30}{changes \cs{thedate} to \cs{formatdate}
% to avoid name conflict with other packages/class files.}
%    \begin{macrocode}
\providecommand*{\formatdate}[3]{}
%    \end{macrocode}
%\end{macro}
% Provide counters to store the specified date:
%    \begin{macrocode}
\newcount\@day
\newcount\@month
\newcount\@year
%    \end{macrocode}
%\begin{macro}{\longdate}
% Long date format. (This is the default in the absence of package
% options, babel and datetime.cfg settings.)
%    \begin{macrocode}
\DeclareRobustCommand*{\longdate}{%
  \renewcommand*{\formatdate}[3]{%
  \ifshowdow\dayofweekname{##1}{##2}{##3} \fi
  \@day=##1\relax\@month=##2\relax\@year=##3\relax
  \ordinaldate{\the\@day}\ \monthname[\@month], \the\@year}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortdate}
% Abbreviated version of above
%    \begin{macrocode}
\DeclareRobustCommand*{\shortdate}{%
  \renewcommand*{\formatdate}[3]{%
  \ifshowdow\shortdayofweekname{##1}{##2}{##3} \fi
  \@day=##1\relax\@month=##2\relax\@year=##3\relax
  \ordinaldate{\the\@day}\ \shortmonthname[\@month], \the\@year}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\twodigit}
% Define |\twodigit| to display a number as two digits. \LaTeX\
% already defines the internal command |\two@digits|, but need
% a command that can be used in |\newdateformat| in the document.
%\changes{2.2}{2004/04/27}{new}
%    \begin{macrocode}
\let\twodigit\two@digits
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\yyyymmdddate}
%\changes{2.56}{2009/11/16}{new}
% Year/month/day format. (Day and month displayed as two digits,
% year displayed as is.)
%    \begin{macrocode}
\DeclareRobustCommand*{\yyyymmdddate}{%
\renewcommand*{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\the\@year\dateseparator \twodigit\@month\dateseparator 
\twodigit\@day}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ddmmyyyydate}
% Day/month/year format. (Day and month displayed as two digits,
% year displayed as is.)
%    \begin{macrocode}
\DeclareRobustCommand*{\ddmmyyyydate}{%
\renewcommand*{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\twodigit\@day\dateseparator \twodigit\@month\dateseparator 
\the\@year}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dmyyyydate}
% Day/month/year format. (Numbers all displayed as is.)
%    \begin{macrocode}
\DeclareRobustCommand*{\dmyyyydate}{%
\renewcommand*{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\the\@day\dateseparator \the\@month\dateseparator \the\@year}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ddmmyydate}
% Day/month/year format. (All numbers displayed as two digits.)
%    \begin{macrocode}
\DeclareRobustCommand*{\ddmmyydate}{\renewcommand*{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\@dtctr=\@year%
\@FCmodulo{\@dtctr}{100}%
\twodigit\@day\dateseparator \twodigit\@month\dateseparator 
\twodigit\@dtctr}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dmyydate}
% Day/month/year format. (Day and month displayed as is, year 
% abbreviated to two digits.)
%    \begin{macrocode}
\DeclareRobustCommand*{\dmyydate}{\renewcommand*{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\@dtctr=\@year%
\@FCmodulo{\@dtctr}{100}%
\the\@day\dateseparator \the\@month\dateseparator \twodigit\@dtctr}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\textdate}
% Full textual date (English).
%    \begin{macrocode}
\DeclareRobustCommand*{\textdate}{%
\renewcommand*{\formatdate}[3]{%
\ifshowdow\dayofweekname{##1}{##2}{##3} the \fi
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\Ordinalstringnum{\@day}\ of \monthname[\@month], 
\Numberstringnum{\@year}%
}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\usdate}
% US format (as per original definition of |\today|)
%    \begin{macrocode}
\DeclareRobustCommand*{\usdate}{%
\renewcommand*{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\monthname[\@month]\ \the\@day, \the\@year}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\mmddyyyydate}
% Month/day/year format. (Month and day displayed as two digits,
% year displayed as is.)
%    \begin{macrocode}
\DeclareRobustCommand*{\mmddyyyydate}{%
\renewcommand*{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\twodigit\@month\dateseparator \twodigit\@day\dateseparator 
\the\@year}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\mdyyyydate}
% Month/day/year format. (All numbers displayed as is.)
%    \begin{macrocode}
\DeclareRobustCommand*{\mdyyyydate}{%
\renewcommand*{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\the\@month\dateseparator \the\@day\dateseparator \the\@year}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\mmddyydate}
% Month/day/year format. (All numbers displayed with two digits.)
%    \begin{macrocode}
\DeclareRobustCommand*{\mmddyydate}{\renewcommand*{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\@dtctr=\@year%
\@FCmodulo{\@dtctr}{100}%
\twodigit\@month\dateseparator \twodigit\@day\dateseparator 
\twodigit\@dtctr}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\mdyydate}
% Month/day/year format. (Month and day displayed as is, year 
% abbreviated to two digits.)
%    \begin{macrocode}
\DeclareRobustCommand*{\mdyydate}{\renewcommand*{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\@dtctr=\@year%
\@FCmodulo{\@dtctr}{100}%
\the\@month\dateseparator \the\@day\dateseparator \twodigit\@dtctr}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\newdate}
% Define commands to save dates
% and later format them. Store a given date:
%\changes{2.45}{2005/05/01}{new}
%    \begin{macrocode}
\newcommand*{\newdate}[4]{%
\@ifundefined{date@#1@y}{%
\@namedef{date@#1@d}{#2}%
\@namedef{date@#1@m}{#3}%
\@namedef{date@#1@y}{#4}}{%
\PackageError{datetime}{Date `#1' already defined}{}}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\getdateyear}
% Display year from previously stored date
%    \begin{macrocode}
\newcommand*{\getdateyear}[1]{%
\@ifundefined{date@#1@y}{%
\PackageError{datetime}{Date `#1' not defined}{}}{%
\csname date@#1@y\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\getdatemonth}
% Display month from previously stored date
%    \begin{macrocode}
\newcommand*{\getdatemonth}[1]{%
\@ifundefined{date@#1@m}{%
\PackageError{datetime}{Date `#1' not defined}{}}{%
\csname date@#1@m\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\getdateday}
% Display day from previously stored date
%    \begin{macrocode}
\newcommand{\getdateday}[1]{%
\@ifundefined{date@#1@d}{%
\PackageError{datetime}{Date `#1' not defined}{}}{%
\csname date@#1@d\endcsname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\displaydate}
% Display a previously stored date using current date format
%    \begin{macrocode}
\newcommand*{\displaydate}[1]{%
\@ifundefined{date@#1@y}{%
\PackageError{datetime}{Date `#1' not defined}{}}{%
\formatdate{\csname date@#1@d\endcsname}{%
\csname date@#1@m\endcsname}{%
\csname date@#1@y\endcsname}}}
%    \end{macrocode}
%\end{macro}
% Set defaults:
%    \begin{macrocode}
\longdate
\showdowtrue
%    \end{macrocode}
%
%\changes{2.56}{2009/11/16}{moved definition of \cs{newdateformat}
% before cfg file loaded}
% Define |\newdateformat| which defines a declaration that redefines |\formatdate| so that
% it uses |\dateformat|.  |\dateformat| takes four arguments, the first defines the format
% the last three arguments are the three arguments that effectively get passed to |\formatdate|.
% |\dateformat| sets |\@day|, |\@month| and |\@year|.  |\c@DAY|, |\c@MONTH| and |\c@YEAR| 
% are set as synonims for |\@day|, |\@month| and |\@year|, to that the uses can use the counters
% |DAY|, |MONTH| and |YEAR| as part of the format.
% The commands |\THEDAY|, |\THEMONTH| and |\THEYEAR| should only be
% used in the argument to |\newdateformat|. This is done partly to
% assist the \LaTeX2HTML version.
%
% This command must be defined before the configuration file is
% loaded, which in turn must be before the package options, therefore
% can't test for \texttt{nodate} package option.
%    \begin{macrocode}
\providecommand*\THEDAY{\the\@day}
\providecommand*\THEMONTH{\the\@month}
\providecommand*\THEYEAR{\the\@year}
%    \end{macrocode}
% Simulate a \LaTeX\ counter.
%    \begin{macrocode}
\let\c@DAY=\@day
\let\c@MONTH=\@month
\let\c@YEAR=\@year
%    \end{macrocode}
%\begin{macro}{\newdateformat}
% Provide a means to define a new date format.
%\changes{2.2}{2004/04/27}{new}
%    \begin{macrocode}
\providecommand{\newdateformat}[2]{%
\@ifundefined{#1}{%
\expandafter\DeclareRobustCommand\csname#1\endcsname{%
\renewcommand{\formatdate}{\dateformat{#2}}}}{%
\PackageError{datetime}{Can't create new date format, command 
\textbackslash#1 already defined}{You will need to 
give your new date format a different name}}}
%    \end{macrocode}
%\end{macro}
% \subsubsection{Time Macros}
%\begin{macro}{\currenttime}
% (New to v2.3) Define |\currenttime| which will print the
% time according to the current format.
%\changes{2.56}{2009/11/16}{change to use \cs{formattime}}
%    \begin{macrocode}
\DeclareRobustCommand*{\currenttime}{%
  \formattime{\currenthour}{\currentminute}{\currentsecond}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\formattime}
% Define \cs{formattime} analoguous to \cs{formatdate}.
% Set it to 24hr time by default
%\changes{2.56}{2009/11/16}{new}
%    \begin{macrocode}
\newcommand*{\formattime}[3]{\protect\@formattime{#1}{#2}{#3}}
\newcommand*{\@formattime}[3]{%
  \csname timeformat@xxivtime\endcsname{#1}{#2}{#3}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\timeseparator}
%\changes{2.43}{2005/02/25}{new}
% Define separator for numerical times:
%    \begin{macrocode}
\newcommand*{\timeseparator}{:}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\settimeformat}
% Switch to specified time format:
%\changes{2.3}{2004/05/01}{new}
%\changes{2.56}{2009/11/16}{now sets formattime}
%    \begin{macrocode}
\providecommand*{\settimeformat}[1]{%
  \@ifundefined{timeformat@#1}{%
    \PackageError{datetime}{Unknown time format `#1'}{}%
  }{%
    \renewcommand*{\@formattime}[3]{%
      \csname timeformat@#1\endcsname{##1}{##2}{##3}}%
  }%
}
%    \end{macrocode}
%\end{macro}
% Define a command to create a new time format, similar to the new 
% date format. Again this is done in a way that makes it easier to
% code the \LaTeX2HTML version.
%    \begin{macrocode}
\newcount\c@HOUR
\newcount\c@HOURXII
\newcount\c@MINUTE
\newcount\c@TOHOUR
\newcount\c@TOMINUTE
\newcount\c@SECOND
%    \end{macrocode}
% These commands should only be used in |\newtimeformat|.
%    \begin{macrocode}
\def\THEHOUR{\the\c@HOUR}
\def\THEHOURXII{\the\c@HOURXII}
\def\THEMINUTE{\the\c@MINUTE}
\def\THETOHOUR{\the\c@TOHOUR}
\def\THETOMINUTE{\the\c@TOMINUTE}
\def\THESECOND{\the\c@SECOND}
%    \end{macrocode}
%\begin{macro}{\currenthour}
%\changes{2.56}{2009/11/16}{new}
% Store the current hour
%    \begin{macrocode}
\newcount\currenthour
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\currentminute}
%\changes{2.56}{2009/11/16}{new}
% Store current minute
%    \begin{macrocode}
\newcount\currentminute
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\currentsecond}
%\changes{2.56}{2009/11/16}{new}
\newcount\currentsecond
%\end{macro}
% Get time information from \cs{pdfcreationdate} (if it exists)
%    \begin{macrocode}
{\catcode`\D=12\relax
  \gdef\@dt@getdate D:#1#2#3#4#5#6#7#8{\@dt@gettime}%
}
\@ifundefined{pdfcreationdate}{%
  \currenthour=\time\relax
  \divide\currenthour by 60\relax
  \currentminute=\time\relax
  \@FCmodulo{\currentminute}{60}%
  \currentsecond=0\relax
}{%
  \def\@dt@gettime#1#2#3#4#5#6#7\relax{%
    \currenthour=#1#2\relax
    \currentminute=#3#4\relax
    \currentsecond=#5#6\relax}%
  \expandafter\@dt@getdate\pdfcreationdate\relax
}
%    \end{macrocode}
%\begin{macro}{\newtimeformat}
% Provide a means to define a new time format.
%\changes{2.3}{2004/05/01}{new}
%\changes{2.56}{2009/11/16}{added \cs{timeformat}@\meta{name}}
%    \begin{macrocode}
\providecommand*{\newtimeformat}[2]{%
\@ifundefined{#1}{%
\expandafter\def\csname#1\endcsname{%
  \csname timeformat@#1\endcsname{\currenthour}{\currentminute}%
  {\currentsecond}%
}%
\expandafter\def\csname timeformat@#1\endcsname##1##2##3{%
\c@HOUR=##1%
\c@HOURXII=\c@HOUR
\ifnum\c@HOURXII>12
\advance\c@HOURXII by -12\relax
\fi
\c@MINUTE=##2%
\c@TOHOUR=\c@HOURXII
\advance\c@TOHOUR by 1\relax
\@FCmodulo{\c@TOHOUR}{12}%
\c@TOMINUTE=\c@MINUTE
\advance\c@TOMINUTE by -60\relax
\multiply\c@TOMINUTE by -1\relax
\c@SECOND=##3\relax
#2\relax
}}{%
\PackageError{datetime}{Command \textbackslash#1  already defined}{%
You can't create a new time format called "#1" as the command 
\textbackslash#1 already exists}}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\xxivtime}
% Define commands to print the current time. Twenty-four hour time:
%    \begin{macrocode}
\newtimeformat{xxivtime}{%
\twodigit\THEHOUR\timeseparator\twodigit\THEMINUTE}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\hhmmsstime}
% Twenty-four hour time including seconds.
%    \begin{macrocode}
\newtimeformat{hhmmsstime}{%
\twodigit\THEHOUR\timeseparator\twodigit\THEMINUTE\timeseparator
\twodigit\THESECOND}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ampmtime}
% 12-hour time:
%\changes{2.3}{2004/05/01}{fixed minor bug}
%\changes{2.51}{2007/01/30}{fixed bug between midnight and 1am}
%    \begin{macrocode}
\newtimeformat{ampmtime}{%
\ifthenelse{\value{HOUR}=0}{12}{\THEHOURXII}\timeseparator
\twodigit\THEMINUTE
\ifthenelse{\value{HOUR}<12}{\amname}{%
\ifthenelse{\value{HOUR}=12}{ \noon}{\pmname}}}
%    \end{macrocode}
%\end{macro}
% Textual time:
%\begin{macro}{\hourstring}
% \cs{hourstring}\marg{count} will print |\midnight| if 
% \meta{count} is 0, otherwise will do \cs{Numberstring}\marg{count}.
%    \begin{macrocode}
\newcommand*{\hourstring}[1]{%
\ifthenelse{\value{#1}=0}{\midnight}{\Numberstring{#1}}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\oclock}
%\changes{2.43}{2005/02/23}{fixed bug causing an infinite loop on the hour}
%    \begin{macrocode}
\newtimeformat{oclock}{%
  \ifthenelse{\(\value{HOUR}=0 \OR \value{HOUR}=12 \OR\value{HOUR}=24\)\AND 
 \value{MINUTE}=0}{%
%    \end{macrocode}
% Midnight or Midday:
%    \begin{macrocode}
\ifthenelse{\value{HOUR}=12}{\noon}{\midnight}}{%
%    \end{macrocode}
% Neither Midnight nor Midday.
% Do minutes first
%    \begin{macrocode}
\ifthenelse{\value{MINUTE}=0}{%
%    \end{macrocode}
% On the hour: don't print any minutes, just do the hour and 
% |\oclockstring|
%    \begin{macrocode}
\Numberstring{HOUR} \oclockstring}{%
\ifthenelse{\value{MINUTE}=15}{%
\quarterpast\ \hourstring{HOUR}}{%
\ifthenelse{\value{MINUTE}=30}{%
\halfpast\ \hourstring{HOUR}}{%
\ifthenelse{\value{MINUTE}=45}{%
\quarterto\ \hourstring{TOHOUR}}{%
\ifthenelse{\value{MINUTE}<30}{%
\Numberstring{MINUTE}\ \ifthenelse{\value{MINUTE}=1}{minute}{minutes} 
past \hourstring{HOURXII}}{%
\Numberstring{TOMINUTE}\ \ifthenelse{%
\value{TOMINUTE}=1}{minute}{minutes} to \hourstring{TOHOUR}}}}}}% 
%    \end{macrocode}
% Now say whether it is morning or afternoon
%    \begin{macrocode}
\ifthenelse{\value{HOUR}<12}{%
%    \end{macrocode}
% Morning
%    \begin{macrocode}
\ifthenelse{\value{HOUR}=0}{}{\ \amstring}}{%
%    \end{macrocode}
% Afternoon
%    \begin{macrocode}
\ifthenelse{\value{TOHOUR}=0}{}{\ \pmstring}}}}
%    \end{macrocode}
%\end{macro}
% Define textual strings used in the above.
%\begin{macro}{\amname}
%    \begin{macrocode}
\providecommand*{\amname}{am}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\pmname}
%    \begin{macrocode}
\providecommand*{\pmname}{pm}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\amorpmname}
%\changes{2.60}{2015-03-20}{fixed bug}
%    \begin{macrocode}
\providecommand*{\amorpmname}{%
\ifthenelse{\value{HOUR}>11}{\pmname}{\amname}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\amstring}
%    \begin{macrocode}
\providecommand*{\amstring}{in the morning}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\pmstring}
%    \begin{macrocode}
\providecommand*{\pmstring}{in the afternoon}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\amorpmstring}
%    \begin{macrocode}
\providecommand*{\amorpmstring}{%
\ifthenelse{\value{HOUR}>12}{\pmstring}{\amstring}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\halfpast}
%    \begin{macrocode}
\providecommand*{\halfpast}{Half past}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\quarterpast}
%    \begin{macrocode}
\providecommand*{\quarterpast}{Quarter past}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\quarterto}
%    \begin{macrocode}
\providecommand*{\quarterto}{Quarter to}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\noon}
%    \begin{macrocode}
\providecommand*{\noon}{Noon}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\midnight}
%    \begin{macrocode}
\providecommand*{\midnight}{Midnight}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\oclockstring}
%    \begin{macrocode}
\providecommand*{\oclockstring}{O'Clock}
%    \end{macrocode}
%\end{macro}
%\subsubsection{Configuration File}
% Load in specifications from configuration file:
%\changes{2.4}{2004/09/25}{added provision for configuration file
%datetime.cfg}
%    \begin{macrocode}
\InputIfFileExists{datetime.cfg}{\PackageInfo{datetime}{%
Loading local datetime configurations}}{%
\PackageInfo{datetime}{No datetime.cfg file found, using default
settings}}
%    \end{macrocode}
%\subsubsection{Package Options}
% Package options need to override \sty{babel}, so define command to
% add date format to \sty{babel}'s extras.
%    \begin{macrocode}
\@ifpackageloaded{babel}{%
  \newcommand*{\dt@addtoextras}[1]{%
    \@ifundefined{extrasenglish}{}{%
      \addto\extrasenglish{#1}%
    }%
    \@ifundefined{extrasamerican}{}{%
      \addto\extrasamerican{#1}%
    }%
    \@ifundefined{extrasaustrian}{}{%
      \addto\extrasaustrian{#1}%
    }%
    \@ifundefined{extrasaustralian}{}{%
      \addto\extrasaustralian{#1}%
    }%
    \@ifundefined{extrasbahasa}{}{%
      \addto\extrasbahasa{#1}%
    }%
    \@ifundefined{extrasbreton}{}{%
      \addto\extrasbreton{#1}%
    }%
    \@ifundefined{extrasbritish}{}{%
      \addto\extrasbritish{#1}%
    }%
    \@ifundefined{extrasbulgarian}{}{%
      \addto\extrasbulgarian{#1}%
    }%
    \@ifundefined{extrascanadian}{}{%
      \addto\extrascanadian{#1}%
    }%
    \@ifundefined{extrascatalan}{}{%
      \addto\extrascatalan{#1}%
    }%
    \@ifundefined{extrascroatian}{}{%
      \addto\extrascroatian{#1}%
    }%
    \@ifundefined{extrasczech}{}{%
      \addto\extrasczech{#1}%
    }%
    \@ifundefined{extrasdanish}{}{%
      \addto\extrasdanish{#1}%
    }%
    \@ifundefined{extrasesperanto}{}{%
      \addto\extrasesperanto{#1}%
    }%
    \@ifundefined{extrasestonian}{}{%
      \addto\extrasestonian{#1}%
    }%
    \@ifundefined{extrasfinnish}{}{%
      \addto\extrasfinnish{#1}%
    }%
    \@ifundefined{extrasfrench}{}{%
      \addto\extrasfrench{#1}%
    }%
    \@ifundefined{extrasgalician}{}{%
      \addto\extrasgalician{#1}%
    }%
    \@ifundefined{extrasgerman}{}{%
      \addto\extrasgerman{#1}%
    }%
    \@ifundefined{extrasgreek}{}{%
      \addto\extrasgreek{#1}%
    }%
    \@ifundefined{extrashebrew}{}{%
      \addto\extrashebrew{#1}%
    }%
    \@ifundefined{extrasicelandic}{}{%
      \addto\extrasicelandic{#1}%
    }%
    \@ifundefined{extrasirish}{}{%
      \addto\extrasirish{#1}%
    }%
    \@ifundefined{extrasitalian}{}{%
      \addto\extrasitalian{#1}%
    }%
    \@ifundefined{extraslatin}{}{%
      \addto\extraslatin{#1}%
    }%
    \@ifundefined{extraslsorbian}{}{%
      \addto\extraslsorbian{#1}%
    }%
    \@ifundefined{extrasmagyar}{}{%
      \addto\extrasmagyar{#1}%
    }%
    \@ifundefined{extrasnaustrian}{}{%
      \addto\extrasnaustrian{#1}%
    }%
    \@ifundefined{extrasngerman}{}{%
      \addto\extrasngerman{#1}%
    }%
    \@ifundefined{extrasnewzealand}{}{%
      \addto\extrasnewzealand{#1}%
    }%
    \@ifundefined{extrasnorsk}{}{%
      \addto\extrasnorsk{#1}%
    }%
    \@ifundefined{extraspolish}{}{%
      \addto\extraspolish{#1}%
    }%
    \@ifundefined{extrasportuges}{}{%
      \addto\extrasportuges{#1}%
    }%
    \@ifundefined{extrasromanian}{}{%
      \addto\extrasromanian{#1}%
    }%
    \@ifundefined{extrasrussian}{}{%
      \addto\extrasrussian{#1}%
    }%
    \@ifundefined{extrassamin}{}{%
      \addto\extrassamin{#1}%
    }%
    \@ifundefined{extrasscottish}{}{%
      \addto\extrasscottish{#1}%
    }%
    \@ifundefined{extrasserbian}{}{%
      \addto\extrasserbian{#1}%
    }%
    \@ifundefined{extrasslovak}{}{%
      \addto\extrasslovak{#1}%
    }%
    \@ifundefined{extrasslovene}{}{%
      \addto\extrasslovene{#1}%
    }%
    \@ifundefined{extrasspanish}{}{%
      \addto\extrasspanish{#1}%
    }%
    \@ifundefined{extrasswedish}{}{%
      \addto\extrasswedish{#1}%
    }%
    \@ifundefined{extrasturkish}{}{%
      \addto\extrasturkish{#1}%
    }%
    \@ifundefined{extrasUKenglish}{}{%
      \addto\extrasUKenglish{#1}%
    }%
    \@ifundefined{extrasukraine}{}{%
      \addto\extrasukraine{#1}%
    }%
    \@ifundefined{extrasUSenglish}{}{%
      \addto\extrasUSenglish{#1}%
    }%
    \@ifundefined{extrasusorbian}{}{%
      \addto\extrasusorbian{#1}%
    }%
    \@ifundefined{extraswelsh}{}{%
      \addto\extraswelsh{#1}%
    }%
  }
}{%
  \newcommand*{\dt@addtoextras}[1]{}
}
%    \end{macrocode}
%\begin{macro}{setdefaultdate}
% Set default date.
%    \begin{macrocode}
\newcommand*{\setdefaultdate}[1]{\dt@addtoextras{#1}#1}
%    \end{macrocode}
%\end{macro}
% Specify the package options, specify default options and process
%    \begin{macrocode}
\RequirePackage{fmtcount}
\DeclareOption{long}{\setdefaultdate{\longdate}}
\DeclareOption{short}{\setdefaultdate{\shortdate}}
\DeclareOption{yyyymmdd}{\setdefaultdate{\yyyymmdddate}}
\DeclareOption{ddmmyyyy}{\setdefaultdate{\ddmmyyyydate}}
\DeclareOption{dmyyyy}{\setdefaultdate{\dmyyyydate}}
\DeclareOption{ddmmyy}{\setdefaultdate{\ddmmyydate}}
\DeclareOption{dmyy}{\setdefaultdate{\dmyydate}}
\DeclareOption{text}{\setdefaultdate{\textdate}}
\DeclareOption{us}{\setdefaultdate{\usdate}}
\DeclareOption{mmddyyyy}{\setdefaultdate{\mmddyyyydate}}
\DeclareOption{mdyyyy}{\setdefaultdate{\mdyyyydate}}
\DeclareOption{mmddyy}{\setdefaultdate{\mmddyydate}}
\DeclareOption{mdyy}{\setdefaultdate{\mdyydate}}
\DeclareOption{level}{\fmtcountsetoptions{fmtord=level}}
\DeclareOption{raise}{\fmtcountsetoptions{fmtord=raise}}
\DeclareOption{dayofweek}{\showdowtrue}
\DeclareOption{nodayofweek}{\showdowfalse}
\DeclareOption{nodate}{\@dt@nodatetrue}
\DeclareOption{hhmmss}{\settimeformat{hhmmsstime}}
\DeclareOption{24hr}{\settimeformat{xxivtime}}
\DeclareOption{12hr}{\settimeformat{ampmtime}}
\DeclareOption{oclock}{\settimeformat{oclock}}
\DeclareOption{iso}{%
  \setdefaultdate{\yyyymmdddate}\settimeformat{hhmmsstime}%
  \renewcommand*{\dateseparator}{-}%
  \renewcommand*{\timeseparator}{:}%
}
%    \end{macrocode}
%
%\begin{macro}{\loadDTdef}
%\changes{2.58}{2010/09/21}{new}
% Load the datetime language definition file for the given language
%    \begin{macrocode}
\newcommand*{\loadDTdef}[1]{%
%    \end{macrocode}
% Check whether the file has already been loaded.
%    \begin{macrocode}
  \DTifDefLoaded{#1}%
%    \end{macrocode}
% File already loaded, so do nothing.
%    \begin{macrocode}
  {}%
  {%
    \InputIfFileExists{dt-#1.def}%
    {}%
    {%
       \PackageWarning{datetime}{Can't find datetime language
         definition file for `#1'}%
    }%
  }%
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\DTifDefLoaded}
%\changes{2.59}{2013/09/10}{new}
%    \begin{macrocode}
\newcommand{\DTifDefLoaded}[3]{%
  \@ifundefined{ver@dt-#1.def}{#3}{#2}%
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\DTloadDefIfNotLoadedButExists}
%\changes{2.59}{2013/09/10}{new}
%    \begin{macrocode}
\newcommand{\DTloadDefIfNotLoadedButExists}[1]{%
  \DTifDefLoaded{#1}%
  {}%
  {%
    \bgroup
      \catcode `\@ 11\relax
      \InputIfFileExists{dt-#1.def}{}{}%
    \egroup
  }%
}%
%    \end{macrocode}
%\end{macro}
%
% Multilingual support. These package options shouldn't really be
% needed if babel has already been loaded.
%    \begin{macrocode}
\DeclareOption{austrian}{\loadDTdef{austrian}}
\DeclareOption{american}{\loadDTdef{american}}
\DeclareOption{bahasa}{\loadDTdef{bahasa}}
\DeclareOption{basque}{\loadDTdef{basque}}
\DeclareOption{breton}{\loadDTdef{breton}}
\DeclareOption{british}{\loadDTdef{british}}
\DeclareOption{bulgarian}{\loadDTdef{bulgarian}}
\DeclareOption{catalan}{\loadDTdef{catalan}}
\DeclareOption{croatian}{\loadDTdef{croatian}}
\DeclareOption{czech}{\loadDTdef{czech}}
\DeclareOption{danish}{\loadDTdef{danish}}
\DeclareOption{dutch}{\loadDTdef{dutch}}
\DeclareOption{esperanto}{\loadDTdef{esperanto}}
\DeclareOption{estonian}{\loadDTdef{estonian}}
\DeclareOption{finnish}{\loadDTdef{finnish}}
\DeclareOption{french}{\loadDTdef{french}}
\DeclareOption{galician}{\loadDTdef{galician}}
\DeclareOption{german}{\loadDTdef{german}\dategerman}
\DeclareOption{greek}{\loadDTdef{greek}}
\DeclareOption{hebrew}{\loadDTdef{hebrew}}
\DeclareOption{icelandic}{\loadDTdef{icelandic}}
\DeclareOption{irish}{\loadDTdef{irish}}
\DeclareOption{italian}{\loadDTdef{italian}}
\DeclareOption{latin}{\loadDTdef{latin}}
\DeclareOption{lsorbian}{\loadDTdef{lsorbian}}
\DeclareOption{magyar}{\loadDTdef{magyar}}
\DeclareOption{naustrian}{\loadDTdef{naustrian}}
\DeclareOption{ngerman}{\loadDTdef{ngerman}\datengerman}
\DeclareOption{norsk}{\loadDTdef{norsk}}
\DeclareOption{polish}{\loadDTdef{polish}}
\DeclareOption{portuges}{\loadDTdef{portuges}}
\DeclareOption{romanian}{\loadDTdef{romanian}}
\DeclareOption{russian}{\loadDTdef{russian}}
\DeclareOption{samin}{\loadDTdef{samin}}
\DeclareOption{scottish}{\loadDTdef{scottish}}
\DeclareOption{serbian}{\loadDTdef{serbian}}
\DeclareOption{slovak}{\loadDTdef{slovak}}
\DeclareOption{slovene}{\loadDTdef{slovene}}
\DeclareOption{spanish}{\loadDTdef{spanish}}
\DeclareOption{swedish}{\loadDTdef{swedish}}
\DeclareOption{turkish}{\loadDTdef{turkish}}
\DeclareOption{ukraineb}{\loadDTdef{ukraineb}}
\DeclareOption{usorbian}{\loadDTdef{usorbian}}
\DeclareOption{UKenglish}{\loadDTdef{UKenglish}}
\DeclareOption{USenglish}{\loadDTdef{USenglish}}
\DeclareOption{welsh}{\loadDTdef{welsh}}
%    \end{macrocode}
% Process package options
%    \begin{macrocode}
\ProcessOptions
%    \end{macrocode}
% \subsubsection{Date Specific Macros}
%    \begin{macrocode}
\if@dt@nodate
  \PackageInfo{datetime}{option "nodate" used, so note defining
  \string\dateformat}
\else
%    \end{macrocode}
%\begin{macro}{\dateformat}
% Format the given date in the given format.
%    \begin{macrocode}
  \providecommand*{\dateformat}[4]{%
    \@day=#2\relax\@month=#3\relax\@year=#4\relax#1}
%    \end{macrocode}
%\end{macro}
%    \begin{macrocode}
\fi
%    \end{macrocode}
% Define the macro that prints the month name.
% (Only define this command if @dt@nodate is false)
%    \begin{macrocode}
\if@dt@nodate
%    \end{macrocode}
% The |nodate| option was used, so just print informative message,
% and do nothing else.
%    \begin{macrocode}
  \PackageInfo{datetime}{option "nodate" used, so not defining 
  \string\monthname}
\else
%    \end{macrocode}
%\begin{macro}{\monthname}
%Define \verb|\monthname| to be language dependent. If there
%is no \verb|\monthname|\meta{language}, defaults to English.
%    \begin{macrocode}
\newcommand*{\monthname}[1][\month]{%
  \if@dt@multilingual
%    \end{macrocode}
% Make sure language file has been loaded.
%    \begin{macrocode}
    \DTloadDefIfNotLoadedButExists{\languagename}%
    \@ifundefined{monthname\languagename}%
    {%
    \PackageWarning{datetime}{No month names provided for language
    '\languagename'}%
    \monthnameenglish[#1]%
    }%
    {\csname monthname\languagename\endcsname[#1]}%
  \else
    \monthnameenglish[#1]%
  \fi
}
%    \end{macrocode}
%\end{macro}
% End of |\if@dt@nodate| else part:
%    \begin{macrocode}
\fi
%    \end{macrocode}
% Define the macro that prints the abbreviated month name
% (Again, only do this if @dt@nodate is false)
%    \begin{macrocode}
\if@dt@nodate
%    \end{macrocode}
% The |nodate| option was used, so just print informative message,
% and do nothing else.
%    \begin{macrocode}
  \PackageInfo{datetime}{option "nodate" used, so not defining 
  \protect\shortmonthname}
\else
%    \end{macrocode}
%\begin{macro}{\shortmonthname}
%Define \verb|\shortmonthname| to be language dependent. If there
%is no \verb|\shortmonthname|\meta{language}, defaults to English.
%    \begin{macrocode}
\newcommand*{\shortmonthname}[1][\month]{%
  \if@dt@multilingual
%    \end{macrocode}
% Make sure language file has been loaded.
%    \begin{macrocode}
    \DTloadDefIfNotLoadedButExists{\languagename}%
    \@ifundefined{shortmonthname\languagename}%
    {%
      \PackageWarning{datetime}{No abbreviated month name defined for
      language '\languagename', using full version instead}%
      \monthname[#1]%
    }%
    {%
      \csname shortmonthname\languagename\endcsname[#1]%
    }%
  \else
    \shortmonthnameenglish[#1]%
  \fi
}
%    \end{macrocode}
%\end{macro}
% End of |\if@dt@nodate| else part:
%    \begin{macrocode}
\fi
%    \end{macrocode}
% Define macros needed to compute the weekday
% (Again, only do this if @dt@nodate is false)
%\begin{macro}{\ifDTleapyear}
% Need to define |\ifDTleapyear| regardless of @dt@nodate otherwise \LaTeX\ won't
% match |\ifDTleapyear| with |\fi|
%\changes{2.59}{2013/09/10}{renamed \cs{ifleapyear} to
%\cs{ifDTLleapyear} to avoid clash with other packages}
%    \begin{macrocode}
\newif\ifDTleapyear
\@ifundefined{ifleapyear}
{%
%    \end{macrocode}
% Provide backward compatibility:
%    \begin{macrocode}
  \def\ifleapyear{\ifDTLleapyear}
  \let\leapyeartrue\DTLleapyeartrue
  \let\leapyearfalse\DTLleapyearfalse
}%
{}
%    \end{macrocode}
%\end{macro}
% Define temporary counter for arithmetic.
%    \begin{macrocode}
\newcount\@dtctr
%    \end{macrocode}
% If nodate, add a reminder in the log file that \verb|\dayofweek|
% is not defined.
%    \begin{macrocode}
\if@dt@nodate
  \PackageInfo{datetime}{option "nodate" used, so not defining 
  \string\dayofweek \space or \string\shortdayofweek}
\else
%    \end{macrocode}
% Using the algorithm documented at
% http://userpages.wittenberg.edu/bshelburne/Comp150/DayofWeek.htm
% Syntax: \verb|testifleapyear{|\meta{year}\verb|}| sets 
% conditional \verb|\ifDTleapyear|.
%    \begin{macrocode}
\providecommand*{\testifleapyear}[1]{%
  \DTleapyearfalse
  \@year=#1\relax
  \@dtctr=\@year
  \@FCmodulo{\@dtctr}{400}%
  \ifnum\@dtctr=0\relax
%    \end{macrocode}
%         year mod 400 = 0 => leap year
%    \begin{macrocode}
    \DTleapyeartrue
  \else
    \@dtctr=\@year
    \@FCmodulo{\@dtctr}{100}%
    \ifnum\@dtctr=0\relax
%    \begin{macrocode}
%        year mod 100 = 0 && year mod 400 != 0 => not a leap year
%    \end{macrocode}
      \DTleapyearfalse
    \else
      \@dtctr=\@year
      \@FCmodulo{\@dtctr}{4}%
      \ifnum\@dtctr=0\relax
%    \begin{macrocode}
%         year mod 4 = 0 && year mod 100 != 0 => leap year
%    \end{macrocode}
        \DTleapyeartrue 
      \fi
    \fi
  \fi
}
%    \end{macrocode}
%\begin{macro}{\dayofyear}
% Count register in which to store the day of the year.
%    \begin{macrocode}
\newcount\dayofyear
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\computedayofyear}
% \cs{computedayofyear}\marg{day}\marg{month}\marg{year}\par
% Computes the day of year. Result will be stored in \verb|\dayofyear|
%    \begin{macrocode}
\providecommand*{\computedayofyear}[3]{%
  \testifleapyear{#3}%
  \dayofyear=0\relax
  \@day=#1\relax \@month=#2\relax \@year=#3\relax
  \ifcase\@month
  \or
  \or \advance\dayofyear by 31\relax
  \or \advance\dayofyear by 59\relax
  \or \advance\dayofyear by 90\relax
  \or \advance\dayofyear by 120\relax
  \or \advance\dayofyear by 151\relax
  \or \advance\dayofyear by 181\relax
  \or \advance\dayofyear by 212\relax
  \or \advance\dayofyear by 243\relax
  \or \advance\dayofyear by 273\relax
  \or \advance\dayofyear by 304\relax
  \or \advance\dayofyear by 334\relax
  \else
  \PackageError{datetime}{Invalid month number}{The second argument to 
  \string\computedayofyear \space should lie in the range 1-12}%
  \fi
  \ifnum\@month>2\relax
  \ifDTleapyear\advance\dayofyear by 1\relax\fi
  \fi
  \advance\dayofyear by \@day\relax
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dayofweek}
% Count register in which to store the day of the week.
%    \begin{macrocode}
\newcount\dayofweek
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\computedayofweek}
% \cs{computedayofweek}\marg{day}\marg{month}\marg{year}\par
% Computes the day of week index. The result is stored in 
% |\dayofweek|.
%    \begin{macrocode}
\providecommand*{\computedayofweek}[3]{%
  \computedayofyear{#1}{#2}{#3}%
  \@dtctr=#3\relax
  \advance\@dtctr by -1901\relax
  \@FCmodulo{\@dtctr}{28}%
  \dayofweek=\@dtctr
  \divide\dayofweek by 4\relax
  \advance\dayofweek by \@dtctr
  \advance\dayofweek by 2\relax
  \@FCmodulo{\dayofweek}{7}%
  \advance\dayofweek by \dayofyear
  \advance\dayofweek by -1\relax
  \@FCmodulo{\dayofweek}{7}%
  \advance\dayofweek by 1\relax
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dayofweeknameid}
% Given the day of week index, print the associated name in the
% current language. If there is none defined for that language
% default to English.
%    \begin{macrocode}
\providecommand*{\dayofweeknameid}[1]{%
  \if@dt@multilingual
%    \end{macrocode}
% Make sure language file has been loaded.
%    \begin{macrocode}
    \DTloadDefIfNotLoadedButExists{\languagename}%
    \ifcsundef{dayofweeknameid\languagename}%
    {%
       \ifthenelse{\equal{\languagename}{nohyphenation}}{}%
       {%
          \PackageWarning{datetime}%
          {No week day names defined for language 
          '\languagename', defaulting to English}%
       }%
       \dayofweeknameidenglish{#1}%
    }%
    {%
       \csname dayofweeknameid\languagename\endcsname{#1}%
    }%
  \else
    \dayofweeknameidenglish{#1}%
  \fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dayofweekname}
% Print the day of week name for the specified date.
%    \begin{macrocode}
\providecommand*{\dayofweekname}[3]{%
  \computedayofweek{#1}{#2}{#3}%
  \dayofweeknameid{\dayofweek}%
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\thisdayofweekname}
% Print today's day of week name.
%    \begin{macrocode}
\providecommand*{\thisdayofweekname}{%
  \dayofweekname{\day}{\month}{\year}}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortdayofweekname}
% Language dependant version:
%    \begin{macrocode}
\providecommand*{\shortdayofweekname}[3]{%
  \computedayofweek{#1}{#2}{#3}%
  \if@dt@multilingual
%    \end{macrocode}
% Make sure language file has been loaded.
%    \begin{macrocode}
    \DTloadDefIfNotLoadedButExists{\languagename}%
    \@ifundefined{shortdayofweeknameid\languagename}%
    {%
      \ifthenelse{\equal{\languagename}{nohyphenation}}{}%
      {%
        \PackageWarning{datetime}%
        {No abbreviated week day names defined for 
         language '\languagename', defaulting to long version}%
      }%
      \dayofweeknameid{\dayofweek}%
    }%
    {%
      \csname shortdayofweeknameid\languagename\endcsname\dayofweek
    }%
  \else
    \shortdayofweeknameidenglish{\dayofweek}%
\fi
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\thisshortdayofweekname}
% Today's week day name, abbreviated:
%    \begin{macrocode}
\providecommand*{\thisshortdayofweekname}{%
  \dayofweekname{\day}{\month}{\year}}
%    \end{macrocode}
%\end{macro}
% End of |\if@dt@nodate| else part.
%    \begin{macrocode}
\fi
%    \end{macrocode}
%\begin{macro}{\today}
% Redefine |\today| so that it uses |\formatdate|.
% (Only do this if @dt@nodate is false)
%\changes{2.46}{2005/09/30}{defined using \cs{DeclareRobustCommand}}
%\changes{2.41}{2004/10/22}{defined using \cs{providecommand}}
%    \begin{macrocode}
\if@dt@nodate
\else
  \DeclareRobustCommand*{\today}{\formatdate{\day}{\month}{\year}}
\fi
%    \end{macrocode}
%\end{macro}
%Check to see if babel package has redefined |\today|.
%\changes{2.53}{11 June 2007}{added check for \cs{dateUKenglish} and 
%\cs{dateUSenglish}}
%\changes{2.54}{15 June 2007}{added check for \cs{datebritish}}
%    \begin{macrocode}
\if@dt@nodate
\else
\@ifundefined{dateenglish}{}{\let\dateenglish\longdate}
\@ifundefined{dateUKenglish}{}{\loadDTdef{UKenglish}}
\@ifundefined{dateUSenglish}{}{\loadDTdef{USenglish}}
\@ifundefined{datebritish}{}{\loadDTdef{british}}
\@ifundefined{dateamerican}{}{\loadDTdef{american}}
\@ifundefined{dateaustrian}{}{\loadDTdef{austrian}}
\@ifundefined{dateaustralian}{}{\loadDTdef{australian}}
\@ifundefined{datebahasa}{}{\loadDTdef{bahasa}}
\@ifundefined{datebasque}{}{\loadDTdef{basque}}
\@ifundefined{datebreton}{}{\loadDTdef{breton}}
\@ifundefined{datebulgarian}{}{\loadDTdef{bulgarian}}
\@ifundefined{datecanadian}{}{\loadDTdef{canadian}}
\@ifundefined{datecatalan}{}{\loadDTdef{catalan}}
\@ifundefined{datecroatian}{}{\loadDTdef{croatian}}
\@ifundefined{dateczech}{}{\loadDTdef{czech}}
\@ifundefined{datedanish}{}{\loadDTdef{danish}}
\@ifundefined{datedutch}{}{\loadDTdef{dutch}}
\@ifundefined{dateesperanto}{}{\loadDTdef{esperanto}}
\@ifundefined{dateestonian}{}{\loadDTdef{estonian}}
\@ifundefined{datefinnish}{}{\loadDTdef{finnish}}
\@ifundefined{datefrench}{}{\loadDTdef{french}}
\@ifundefined{dategalician}{}{\loadDTdef{galician}}
\@ifundefined{dategerman}{}{\loadDTdef{german}}
\@ifundefined{dategreek}{}{\loadDTdef{greek}}
\@ifundefined{datehebrew}{}{\loadDTdef{hebrew}}
\@ifundefined{dateicelandic}{}{\loadDTdef{icelandic}}
\@ifundefined{dateirish}{}{\loadDTdef{irish}}
\@ifundefined{dateitalian}{}{\loadDTdef{italian}}
\@ifundefined{datelatin}{}{\loadDTdef{latin}}
\@ifundefined{datelsorbian}{}{\loadDTdef{lsorbian}}
\@ifundefined{datemagyar}{}{\loadDTdef{magyar}}
\@ifundefined{datenaustrian}{}{\loadDTdef{naustrian}}
\@ifundefined{datenewzealand}{}{\loadDTdef{newzealand}}
\@ifundefined{datengerman}{}{\loadDTdef{ngerman}}
\@ifundefined{datenorsk}{}{\loadDTdef{norsk}}
\@ifundefined{datepolish}{}{\loadDTdef{polish}}
\@ifundefined{dateportuges}{}{\loadDTdef{portuges}}
\@ifundefined{dateromanian}{}{\loadDTdef{romanian}}
\@ifundefined{daterussian}{}{\loadDTdef{russian}}
\@ifundefined{datesamin}{}{\loadDTdef{samin}}
\@ifundefined{datescottish}{}{\loadDTdef{scottish}}
\@ifundefined{dateserbian}{}{\loadDTdef{serbian}}
\@ifundefined{dateslovak}{}{\loadDTdef{slovak}}
\@ifundefined{dateslovene}{}{\loadDTdef{slovene}}
\@ifundefined{datespanish}{}{\loadDTdef{spanish}}
\@ifundefined{dateswedish}{}{\loadDTdef{swedish}}
\@ifundefined{dateturkish}{}{\loadDTdef{turkish}}
\@ifundefined{dateukraineb}{}{\loadDTdef{ukraineb}}
\@ifundefined{dateusorbian}{}{\loadDTdef{usorbian}}
\@ifundefined{datewelsh}{}{\loadDTdef{welsh}}
\fi
%    \end{macrocode}
%
%\begin{macro}{\pdfdate}
% Finally create command that will typeset the date in PDF format
% e.g. 20040501215500. This is defined regardless of |\if@no@date|
% as it's provided for use in |\pdfinfo|. Initially |\pdfdate| is set 
% to the year. Note that pdftex provides \cs{pdfcreationdate} 
% which also stores the seconds and time zone.
%\changes{2.31}{2004/05/01}{new}
%\changes{2.32}{2004/05/04}{fixed bug}
%    \begin{macrocode}
\newtoks\dt@a \newtoks\dt@b
\edef\pdfdate{\the\year}
%    \end{macrocode}
% Append the month
%    \begin{macrocode}
\dt@b=\expandafter{\pdfdate}
\dt@a=\expandafter{\the\month}
\ifnum\month<10\relax
\edef\pdfdate{\the\dt@b0\the\dt@a}
\else
\edef\pdfdate{\the\dt@b\the\dt@a}
\fi
%    \end{macrocode}
% Append the day
%    \begin{macrocode}
\dt@b=\expandafter{\pdfdate}
\dt@a=\expandafter{\the\day}
\ifnum\day<10\relax
\edef\pdfdate{\the\dt@b0\the\dt@a}
\else
\edef\pdfdate{\the\dt@b\the\dt@a}
\fi
%    \end{macrocode}
% Append the hour
%    \begin{macrocode}
\@dtctr=\time%
\divide\@dtctr by 60\relax
\dt@b=\expandafter{\pdfdate}
\dt@a=\expandafter{\the\@dtctr}
\ifnum\@dtctr<10
\edef\pdfdate{\the\dt@b0\the\dt@a}
\else
\edef\pdfdate{\the\dt@b\the\dt@a}
\fi
%    \end{macrocode}
% Append the minute.
%    \begin{macrocode}
\@dtctr=\time%
\@FCmodulo{\@dtctr}{60}%
\dt@b=\expandafter{\pdfdate}
\dt@a=\expandafter{\the\@dtctr}
\ifnum\@dtctr<10\relax
\edef\pdfdate{\the\dt@b0\the\dt@a}
\else
\edef\pdfdate{\the\dt@b\the\dt@a}
\fi
%    \end{macrocode}
% Append the seconds. 
%    \begin{macrocode}
\dt@a={00}
\dt@b=\expandafter{\pdfdate}
\edef\pdfdate{\the\dt@b\the\dt@a}
%    \end{macrocode}
%\end{macro}
%\iffalse
%    \begin{macrocode}
%</datetime.sty>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-american.def>
%    \end{macrocode}
%\fi
%\subsection{Compatibility with Babel (Language definition files)}
%\subsubsection{american}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-american.def}[2013/09/10]%
%    \end{macrocode}
%\begin{macro}{\dateamerican}
%    \begin{macrocode}
\global\let\dateamerican\usdate
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\monthnameamerican}
%    \begin{macrocode}
\global\let\monthnameamerican\monthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortmonthnameamerican}
%    \begin{macrocode}
\global\let\shortmonthnameamerican\shortmonthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dayofweeknameidamerican}
%    \begin{macrocode}
\global\let\dayofweeknameidamerican\dayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortdayofweeknameamerican}
%    \begin{macrocode}
\global\let\shortdayofweeknameidamerican\shortdayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinaldateamerican}
%    \begin{macrocode}
\providecommand*{\ordinaldateamerican}[1]{#1}%
\global\let\ordinaldateamerican\ordinaldateamerican
%    \end{macrocode}
%\end{macro}
%\iffalse
%    \begin{macrocode}
%</dt-american.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-australian.def>
%    \end{macrocode}
%\fi
%\subsection{Compatibility with Babel (Language definition files)}
%\subsubsection{australian}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-australian.def}[2013/09/10]%
%    \end{macrocode}
%\begin{macro}{\dateaustralian}
%    \begin{macrocode}
\global\let\dateaustralian\usdate
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\monthnameaustralian}
%    \begin{macrocode}
\global\let\monthnameaustralian\monthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortmonthnameaustralian}
%    \begin{macrocode}
\global\let\shortmonthnameaustralian\shortmonthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dayofweeknameidaustralian}
%    \begin{macrocode}
\global\let\dayofweeknameidaustralian\dayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortdayofweeknameaustralian}
%    \begin{macrocode}
\global\let\shortdayofweeknameidaustralian\shortdayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinaldateaustralian}
%    \begin{macrocode}
\providecommand*{\ordinaldateaustralian}[1]{#1}%
\global\let\ordinaldateaustralian\ordinaldateaustralian
%    \end{macrocode}
%\end{macro}
%\iffalse
%    \begin{macrocode}
%</dt-australian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-austrian.def>
%    \end{macrocode}
%\fi
%\subsubsection{Austrian}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-austrian.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%\begin{macro}{\monthnameaustrian}
%    \begin{macrocode}
\providecommand{\monthnameaustrian}[1][\month]{%
  \@orgargctr=#1\relax
  \ifcase\@orgargctr
  \PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
  Month numbers should go from 1 to 12}%
  \or J\"anner%
  \or Februar%
  \or M\"arz%
  \or April%
  \or Mai%
  \or Juni%
  \or Juli%
  \or August%
  \or September%
  \or Oktober%
  \or November%
  \or Dezember%
\else
  \PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
  Month numbers should go from 1 (janvier) to 12 (decembre)}%
\fi}%
\global\let\monthnameaustrian\monthnameaustrian
%    \end{macrocode}
%\end{macro}
% (Re)Define declaration to switch to this format.
%\begin{macro}{\dateaustrian}
%    \begin{macrocode}
\DeclareRobustCommand*\dateaustrian{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnameaustrian[\@month]\space\number\@year}}%
\global\let\dateaustrian\dateaustrian
%    \end{macrocode}
%\end{macro}
%\iffalse
%    \begin{macrocode}
%</dt-austrian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-bahasa.def>
%    \end{macrocode}
%\fi
%\subsubsection{Bahasa}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-bahasa.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamebahasa}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (Januari) to 12 (Desember)}%
\or Januari%
\or Pebruari%
\or Maret%
\or April%
\or Mei%
\or Juni%
\or Juli%
\or Agustus%
\or September%
\or Oktober%
\or Nopember%
\or Desember%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (Januari) to 12 (Desember)}%
\fi}%
\global\let\monthnamebahasa\monthnamebahasa
%    \end{macrocode}
% Define abbreviated month names. This currently does the full 
% name, because I don't know the abbreviated versions.
%    \begin{macrocode}
\providecommand{\shortmonthnamebahasa}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (Januari) to 12 (Desember)}%
\or Januari%
\or Pebruari%
\or Maret%
\or April%
\or Mei%
\or Juni%
\or Juli%
\or Agustus%
\or September%
\or Oktober%
\or Nopember%
\or Desember%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (Januari) to 12 (Desember)}%
\fi}%
\global\let\shortmonthnamebahasa\shortmonthnamebahasa
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datebahasa{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day}~\monthnamebahasa[\@month]\space \number\@year}}%
\global\let\datebahasa\datebahasa
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-bahasa.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-basque.def>
%    \end{macrocode}
%\fi
%\subsubsection{Basque}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-basque.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamebasque}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (urtarrilaren) to 12 (abenduaren)}%
\or urtarrilaren%
\or otsailaren%
\or martxoaren%
\or apirilaren%
\or maiatzaren%
\or ekainaren%
\or uztailaren%
\or abuztuaren%
\or irailaren%
\or urriaren%
\or azaroaren%
\or abenduaren%
\else \PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (urtarrilaren) to 12 (abenduaren)}%
\fi}%
\global\let\monthnamebasque\monthnamebasque
%    \end{macrocode}
% Define abbreviated month names. This currently does the full 
% name, because I don't know the abbreviated versions.
%    \begin{macrocode}
\providecommand{\shortmonthnamebasque}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (urtarrilaren) to 12 (abenduaren)}%
\or urtarrilaren%
\or otsailaren%
\or martxoaren%
\or apirilaren%
\or maiatzaren%
\or ekainaren%
\or uztailaren%
\or abuztuaren%
\or irailaren%
\or urriaren%
\or azaroaren%
\or abenduaren%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (urtarrilaren) to 12 (abenduaren)}%
\fi}%
\global\let\shortmonthnamebasque\shortmonthnamebasque
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datebasque{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@year.eko\space\monthnamebasque[\@month]~\number\@day}}%
\global\let\datebasque\datebasque
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-basque.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-breton.def>
%    \end{macrocode}
%\fi
%\subsubsection{Breton}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-breton.def}[2013/09/10]%
%    \end{macrocode}
%\begin{macro}{\ordinaldatebreton}
% Breton version:
%    \begin{macrocode}
\providecommand*{\ordinaldatebreton}[1]{%
#1\ifnum#1=1\/\textsuperscript{a\~n}\fi}%
\global\let\ordinaldatebreton\ordinaldatebreton
%    \end{macrocode}
%\end{macro}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamebreton}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (Genver) to 12 (Kerzu)}%
\or Genver%
\or C'hwevrer%
\or Meurzh%
\or Ebrel%
\or Mae%
\or Mezheven%
\or Gouere%
\or Eost%
\or Gwengolo%
\or Here%
\or Du%
\or Kerzu%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (Genver) to 12 (Kerzu)}%
\fi}%
\global\let\monthnamebreton\monthnamebreton
%    \end{macrocode}
% Define abbreviated month names. This currently does the full 
% name, because I don't know the abbreviated versions.
%    \begin{macrocode}
\providecommand{\shortmonthnamebreton}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (Genver) to 12 (Kerzu)}%
\or Genver%
\or C'hwevrer%
\or Meurzh%
\or Ebrel%
\or Mae%
\or Mezheven%
\or Gouere%
\or Eost%
\or Gwengolo%
\or Here%
\or Du%
\or Kerzu%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (Genver) to 12 (Kerzu)}%
\fi}%
\global\let\shortmonthnamebreton\shortmonthnamebreton
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datebreton{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\ifnum\@day=1\relax 1\/\textsuperscript{a\~n}\else\number\@day\fi
\space a\space viz\space\monthnamebreton[\@month]\space
\number\@year
}}%
\global\let\datebreton\datebreton
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-breton.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-british.def>
%    \end{macrocode}
%\fi
%\subsubsection{british}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-british.def}[2013/09/10]%
%    \end{macrocode}
%\begin{macro}{\datebritish}
%    \begin{macrocode}
\global\let\datebritish\longdate
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\monthnamebritish}
%    \begin{macrocode}
\global\let\monthnamebritish\monthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortmonthnamebritish}
%    \begin{macrocode}
\global\let\shortmonthnamebritish\shortmonthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dayofweeknameidbritish}
%    \begin{macrocode}
\global\let\dayofweeknameidbritish\dayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortdayofweekidbritish}
%    \begin{macrocode}
\global\let\shortdayofweeknameidbritish\shortdayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinaldatebritish}
%    \begin{macrocode}
\global\let\ordinaldatebritish\ordinaldateenglish
%    \end{macrocode}
%\end{macro}
%\iffalse
%    \begin{macrocode}
%</dt-british.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-bulgarian.def>
%    \end{macrocode}
%\fi
%\subsubsection{Bulgarian}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-bulgarian.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamebulgarian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
    \or\cyrya\cyrn\cyru\cyra\cyrr\cyri\or
    \cyrf\cyre\cyrv\cyrr\cyru\cyra\cyrr\cyri\or
    \cyrm\cyra\cyrr\cyrt\or
    \cyra\cyrp\cyrr\cyri\cyrl\or
    \cyrm\cyra\cyrishrt\or
    \cyryu\cyrn\cyri\or
    \cyryu\cyrl\cyri\or
    \cyra\cyrv\cyrg\cyru\cyrs\cyrt\or
    \cyrs\cyre\cyrp\cyrt\cyre\cyrm\cyrv\cyrr\cyri\or
    \cyro\cyrk\cyrt\cyro\cyrm\cyrv\cyrr\cyri\or
    \cyrn\cyro\cyre\cyrm\cyrv\cyrr\cyri\or
    \cyrd\cyre\cyrk\cyre\cyrm\cyrv\cyrr\cyri
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamebulgarian\monthnamebulgarian
%    \end{macrocode}
% Define abbreviated month names. This currently does the full 
% name, because I don't know the abbreviated versions.
%    \begin{macrocode}
\providecommand{\shortmonthnamebulgarian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
    \or\cyrya\cyrn\cyru\cyra\cyrr\cyri\or
    \cyrf\cyre\cyrv\cyrr\cyru\cyra\cyrr\cyri\or
    \cyrm\cyra\cyrr\cyrt\or
    \cyra\cyrp\cyrr\cyri\cyrl\or
    \cyrm\cyra\cyrishrt\or
    \cyryu\cyrn\cyri\or
    \cyryu\cyrl\cyri\or
    \cyra\cyrv\cyrg\cyru\cyrs\cyrt\or
    \cyrs\cyre\cyrp\cyrt\cyre\cyrm\cyrv\cyrr\cyri\or
    \cyro\cyrk\cyrt\cyro\cyrm\cyrv\cyrr\cyri\or
    \cyrn\cyro\cyre\cyrm\cyrv\cyrr\cyri\or
    \cyrd\cyre\cyrk\cyre\cyrm\cyrv\cyrr\cyri
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\shortmonthnamebulgarian\shortmonthnamebulgarian
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datebulgarian{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day~\monthnamebulgarian[\@month]\ \number\@year~\cyrg.}}%
\global\let\datebulgarian\datebulgarian
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-bulgarian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-canadian.def>
%    \end{macrocode}
%\fi
%\subsection{Compatibility with Babel (Language definition files)}
%\subsubsection{canadian}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-canadian.def}[2013/09/10]%
%    \end{macrocode}
%\begin{macro}{\datecanadian}
%    \begin{macrocode}
\global\let\datecanadian\usdate
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\monthnamecanadian}
%    \begin{macrocode}
\global\let\monthnamecanadian\monthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortmonthnamecanadian}
%    \begin{macrocode}
\global\let\shortmonthnamecanadian\shortmonthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dayofweeknameidcanadian}
%    \begin{macrocode}
\global\let\dayofweeknameidcanadian\dayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortdayofweeknamecanadian}
%    \begin{macrocode}
\global\let\shortdayofweeknameidcanadian\shortdayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinaldatecanadian}
%    \begin{macrocode}
\providecommand*{\ordinaldatecanadian}[1]{#1}%
\global\let\ordinaldatecanadian\ordinaldatecanadian
%    \end{macrocode}
%\end{macro}
%\iffalse
%    \begin{macrocode}
%</dt-canadian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-catalan.def>
%    \end{macrocode}
%\fi
%\subsubsection{Catalan}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-catalan.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamecatalan}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (de gener) to 12 (de desembre)}%
\or de gener%
\or de febrer%
\or de mar\c{c}%
\or d'abril%
\or de maig%
\or de juny%
\or de juliol%
\or d'agost%
\or de setembre%
\or d'octubre%
\or de novembre%
\or de desembre%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (de gener) to 12 (de desembre)}%
\fi}%
\global\let\monthnamecatalan\monthnamecatalan
%    \end{macrocode}
% Define abbreviated month names. This currently does the full 
% name, because I don't know the abbreviated versions.
%    \begin{macrocode}
\providecommand{\shortmonthnamecatalan}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (de gener) to 12 (de desembre)}%
\or de gener%
\or de febrer%
\or de mar\c{c}%
\or d'abril%
\or de maig%
\or de juny%
\or de juliol%
\or d'agost%
\or de setembre%
\or d'octubre%
\or de novembre%
\or de desembre%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (de gener) to 12 (de desembre)}%
\fi}%
\global\let\shortmonthnamecatalan\shortmonthnamecatalan
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datecatalan{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day~\monthnamecatalan[\@month]\ de~\number\@year
}}%
\global\let\datecatalan\datecatalan
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-catalan.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-croatian.def>
%    \end{macrocode}
%\fi
%\subsubsection{Croatian}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-croatian.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamecroatian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (sijecnja) to 12 (prosinca)}%
\or sije\v{c}nja%
\or velja\v{c}e%
\or o\v{z}ujka%
\or travnja%
\or svibnja%
\or lipnja%
\or srpnja%
\or kolovoza%
\or rujna%
\or listopada%
\or studenoga%
\or prosinca%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (sijecnja) to 12 (prosinca)}%
\fi}%
\global\let\monthnamecroatian\monthnamecroatian
%    \end{macrocode}
% Define abbreviated month names. This currently does the full 
% name, because I don't know the abbreviated versions.
%    \begin{macrocode}
\providecommand{\shortmonthnamecroatian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (sijecnja) to 12 (prosinca)}%
\or sije\v{c}nja%
\or velja\v{c}e%
\or o\v{z}ujka%
\or travnja%
\or svibnja%
\or lipnja%
\or srpnja%
\or kolovoza%
\or rujna%
\or listopada%
\or studenoga%
\or prosinca%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (sijecnja) to 12 (prosinca)}%
\fi}%
\global\let\shortmonthnamecroatian\shortmonthnamecroatian
%    \end{macrocode}
% Translations provided by Ivan Kokan:
%    \begin{macrocode}
\providecommand*{\dayofweeknameidcroatian}[1]{%
\ifcase#1\relax
\or nedjelja%
\or ponedjeljak%
\or utorak%
\or srijeda%
\or \v{c}etvrtak%
\or petak%
\or subota%
\fi}%
\global\let\dayofweeknameidcroatian\dayofweeknameidcroatian
\providecommand*{\shortdayofweeknameidcroatian}[1]{%
\ifcase#1\relax
\or ned%
\or pon%
\or uto%
\or sri%
\or \v{c}et%
\or pet%
\or sub%
\fi}%
\global\let\shortdayofweeknameidcroatian\shortdayofweeknameidcroatian
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datecroatian{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnamecroatian[\@month]\space \number\@year.}}%
\global\let\datecroatian\datecroatian
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-croatian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-czech.def>
%    \end{macrocode}
%\fi
%\subsubsection{Czech}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-czech.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnameczech}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or ledna%
\or \'unora%
\or b\v{r}ezna%
\or dubna%
\or kv\v{e}tna%
\or \v{c}ervna%
\or \v{c}ervence%
\or srpna%
\or z\'a\v{r}\'{\i}%
\or \v{r}\'{\i}jna%
\or listopadu%
\or prosince%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameczech\monthnameczech
%    \end{macrocode}
% Define abbreviated month names. This currently does the full 
% name, because I don't know the abbreviated versions.
%    \begin{macrocode}
\providecommand{\shortmonthnameczech}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or ledna%
\or \'unora%
\or b\v{r}ezna%
\or dubna%
\or kv\v{e}tna%
\or \v{c}ervna%
\or \v{c}ervence%
\or srpna%
\or z\'a\v{r}\'{\i}%
\or \v{r}\'{\i}jna%
\or listopadu%
\or prosince%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\shortmonthnameczech\shortmonthnameczech
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dateczech{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnameczech[\@month]\space \number\@year}}%
\global\let\dateczech\dateczech
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-czech.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-danish.def>
%    \end{macrocode}
%\fi
%\subsubsection{Danish}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-danish.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamedanish}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or januar%
\or februar%
\or marts%
\or april%
\or maj%
\or juni%
\or juli%
\or august%
\or september%
\or oktober%
\or november%
\or december%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamedanish\monthnamedanish
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datedanish{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnamedanish[\@month]\space \number\@year}}%
\global\let\datedanish\datedanish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-danish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-dutch.def>
%    \end{macrocode}
%\fi
%\subsubsection{Dutch}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-dutch.def}[2015/03/20]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamedutch}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or januari%
\or februari%
\or maart%
\or april%
\or mei%
\or juni%
\or juli%
\or augustus%
\or september%
\or oktober%
\or november%
\or december%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamedutch\monthnamedutch
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datedutch{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day~\monthnamedutch[\@month]\space \number\@year}}%
\global\let\datedutch\datedutch
%    \end{macrocode}
% Day of week name provided by multiple people.
%    \begin{macrocode}
\providecommand*{\dayofweeknameiddutch}[1]{%
\ifcase#1\relax
\or zondag%
\or maandag%
\or dinsdag%
\or woensdag%
\or donderdag%
\or vrijdag%
\or zaterdag%
\fi}

\providecommand*{\shortdayofweeknameiddutch}[1]{%
\ifcase#1\relax
\or zo%
\or ma%
\or di%
\or wo%
\or do%
\or vr%
\or za%
\fi}
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-dutch.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-esperanto.def>
%    \end{macrocode}
%\fi
%\subsubsection{Esperanto}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-esperanto.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnameesperanto}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or januaro%
\or februaro%
\or marto%
\or aprilo%
\or majo%
\or junio%
\or julio%
\or a\u{u}gusto%
\or septembro%
\or oktobro%
\or novembro%
\or decembro%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameesperanto\monthnameesperanto
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dateesperanto{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day{--a}~de~\monthnameesperanto[\@month],\space 
\number\@year}}%
\global\let\dateesperanto\dateesperanto
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-esperanto.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-estonian.def>
%    \end{macrocode}
%\fi
%\subsubsection{Estonian}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-estonian.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnameestonian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or jaanuar%
\or veebruar%
\or m"arts%
\or aprill%
\or mai%
\or juuni%
\or juuli%
\or august%
\or september%
\or oktoober%
\or november%
\or detsember%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameestonian\monthnameestonian
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dateestonian{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.\space\monthnameestonian[\@month]\space 
\number\@year.\space a.}}%
\global\let\dateestonian\dateestonian
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-estonian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-finnish.def>
%    \end{macrocode}
%\fi
%\subsubsection{Finnish}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-finnish.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamefinnish}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or tammikuuta%
\or helmikuuta%
\or maaliskuuta%
\or huhtikuuta%
\or toukokuuta%
\or kes\"akuuta%
\or hein\"akuuta%
\or elokuuta%
\or syyskuuta%
\or lokakuuta%
\or marraskuuta%
\or joulukuuta%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamefinnish\monthnamefinnish
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datefinnish{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnamefinnish[\@month]\space \number\@year}}%
\global\let\datefinnish\datefinnish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-finnish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-french.def>
%    \end{macrocode}
%\fi
%\subsubsection{French}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-french.def}[2013/09/10]%
%    \end{macrocode}
%\begin{macro}{\ordinaldatefrench}
% French:
%    \begin{macrocode}
\providecommand*{\ordinaldatefrench}[1]{%
#1\ifnum#1=1\ier\fi}%
\global\let\ordinaldatefrench\ordinaldatefrench
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ier}
% In case \verb|\ier| hasn't been defined:%
%\changes{v2.47}{27 Oct 2005}{defined if it doesn't
% already exist}
%    \begin{macrocode}
\providecommand*{\ier}{\textsuperscript{er}}%
\global\let\ier\ier
%    \end{macrocode}
%\end{macro}
% Define week day names.
%    \begin{macrocode}
\providecommand{\dayofweeknameidfrench}[1]{%
\ifcase#1\relax
\or dimanche%
\or lundi%
\or mardi%
\or mercredi%
\or jeudi%
\or vendredi%
\or samedi%
\fi}%
\global\let\dayofweeknameidfrench\dayofweeknameidfrench
%    \end{macrocode}
% Define abbreviated week day names (are these correct?)
%    \begin{macrocode}
\providecommand{\shortdayofweeknameidfrench}[1]{%
\ifcase#1\relax
\or dim%
\or lun%
\or mar%
\or mer%
\or jeu%
\or ven%
\or sam%
\fi}%
\global\let\shortdayofweeknameidfrench\shortdayofweeknameidfrench
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamefrench}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (janvier) to 12 (decembre)}%
\or janvier%
\or f\'evrier%
\or mars%
\or avril%
\or mai%
\or juin%
\or juillet%
\or ao\^ut%
\or septembre%
\or octobre%
\or novembre%
\or d\'ecembre%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (janvier) to 12 (decembre)}%
\fi}%
\global\let\monthnamefrench\monthnamefrench
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datefrench{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day\ifnum\@day=1{\ier}\fi\space
\monthnamefrench[\@month]\space \number\@year}}%
\global\let\datefrench\datefrench
%    \end{macrocode}
% Short month names provided by Rapha\"el Pinson
%    \begin{macrocode}
\providecommand{\shortmonthnamefrench}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (jan.) to 12 (dec.)}%
\or jan.%
\or f\'evr.%
\or mars%
\or avr.%
\or mai%
\or juin%
\or juill.%
\or ao\^ut%
\or sept.%
\or oct.%
\or nov.%
\or d\'ec.%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (jan.) to 12 (dec.)}%
\fi}
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-french.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-galician.def>
%    \end{macrocode}
%\fi
%\subsubsection{Galician}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-galician.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamegalician}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or xaneiro%
\or febreiro%
\or marzo%
\or abril%
\or maio%
\or xu\~no%
\or xullo%
\or agosto%
\or setembro%
\or outubro%
\or novembro%
\or decembro%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamegalician\monthnamegalician
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dategalician{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day~de\space\monthnamegalician[\@month]\space
de~\number\@year}}%
\global\let\dategalician\dategalician
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-galician.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-german.def>
%    \end{macrocode}
%\fi
%\subsubsection{German}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-german.def}[2010/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamegerman}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or Januar%
\or Februar%
\or M\"arz%
\or April%
\or Mai%
\or Juni%
\or Juli%
\or August%
\or September%
\or Oktober%
\or November%
\or Dezember%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 (janvier) to 12 (decembre)}%
\fi}%
\global\let\monthnamegerman\monthnamegerman
%    \end{macrocode}
% The following week day names were supplied by Uwe Bieling:
%    \begin{macrocode}
\providecommand{\dayofweeknameidgerman}[1]{%
\ifcase#1\relax
\or Sonntag%
\or Montag%
\or Dienstag%
\or Mittwoch%
\or Donnerstag%
\or Freitag%
\or Samstag%
\fi}%
\global\let\dayofweeknameidgerman\dayofweeknameidgerman
%    \end{macrocode}
%    \begin{macrocode}
\providecommand{\shortdayofweeknameidgerman}[1]{%
\ifcase#1\relax
\or So%
\or Mo%
\or Di%
\or Mi%
\or Do%
\or Fr%
\or Sa%
\fi}%
\global\let\shortdayofweeknameidgerman\shortdayofweeknameidgerman
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dategerman{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnamegerman[\@month]\space\number\@year}}%
\global\let\dategerman\dategerman
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-german.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-greek.def>
%    \end{macrocode}
%\fi
%\subsubsection{Greek}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-greek.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamegreek}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or Ianouar'iou%
\or Febrouar'iou%
\or Mart'iou%
\or April'iou%
\or Ma'"iou%
\or Ioun'iou%
\or Ioul'iou%
\or Augo'ustou%
\or Septembr'iou%
\or Oktwbr'iou%
\or Noembr'iou%
\or Dekembr'iou%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamegreek\monthnamegreek
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dategreek{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day\space\monthnamegreek[\@month]\space\number\@year}}%
\global\let\dategreek\dategreek
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-greek.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-hebrew.def>
%    \end{macrocode}
%\fi
%\subsubsection{Hebrew}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-hebrew.def}[2013/09/10]%
%    \end{macrocode}
% Babel already provides Hebrew month names, so just provide a
% synonym.
%    \begin{macrocode}
\global\let\monthnamehebrew\hebmonth
%    \end{macrocode}
% Redefine declaration to switch to this format. (This uses
% |\hebdate| which is defined by babel.)
%    \begin{macrocode}
\DeclareRobustCommand*\datehebrew{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\hebdate\@day\@month\@year}}%
\global\let\datehebrew\datehebrew
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-hebrew.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-icelandic.def>
%    \end{macrocode}
%\fi
%\subsubsection{Icelandic}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-icelandic.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnameicelandic}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or jan\'uar%
\or febr\'uar%
\or mars%
\or apr\'il%
\or ma\'i%
\or j\'un\'i%
\or j\'ul\'i%
\or \'ag\'ust%
\or september%
\or okt\'ober%
\or n\'ovember%
\or desembe%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameicelandic\monthnameicelandic
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dateicelandic{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnameicelandic[\@month]\space\number\@year}}%
\global\let\dateicelandic\dateicelandic
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-icelandic.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-irish.def>
%    \end{macrocode}
%\fi
%\subsubsection{Irish}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-irish.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnameirish}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or  Ean\'air%
\or Feabhra%
\or M\'arta%
\or Aibre\'an%
\or Bealtaine%
\or Meitheamh%
\or I\'uil%
\or L\'unasa%
\or Me\'an F\'omhair%
\or Deireadh F\'omhair%
\or M\'{\i} na Samhna%
\or M\'{\i} na Nollag%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameirish\monthnameirish
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dateirish{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day\space\monthnameirish[\@month]\space\number\@year}}%
\global\let\dateirish\dateirish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-irish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-italian.def>
%    \end{macrocode}
%\fi
%\subsubsection{Italian}
%    \begin{macrocode}
\ProvidesFile{dt-italian.def}[2015/03/20]%
%    \end{macrocode}
% Translations provided by Giada Ermacora and Marco Coppola
%    \begin{macrocode}
\providecommand{\dayofweeknameiditalian}[1]{%
\ifcase#1\relax
\or domenica%
\or luned\`{\i}%
\or marted\`{\i}%
\or mercoled\`{\i}%
\or gioved\`{\i}%
\or venerd\`{\i}%
\or sabato%
\fi}%
\global\let\dayofweeknameiditalian\dayofweeknameiditalian
%    \end{macrocode}
%    \begin{macrocode}
\providecommand{\shortdayofweeknameiditalian}[1]{%
\ifcase#1\relax
\or dom%
\or lun%
\or mar%
\or mer%
\or gio%
\or ven%
\or sab%
\fi}%
\global\let\shortdayofweeknameiditalian\shortdayofweeknameiditalian
%    \end{macrocode}
%    \begin{macrocode}
\providecommand{\monthnameitalian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{Month numbers should go from 1 (gennaio) to 12 (dicembre)}%
\or gennaio%
\or febbraio%
\or marzo%
\or aprile%
\or maggio%
\or giugno%
\or luglio%
\or agosto%
\or settembre%
\or ottobre%
\or novembre%
\or dicembre%
\else \PackageError{datetime}{Invalid Month number \the\@orgargctr}{Month numbers should go from 1 (gennaio) to 12 (dicembre)}%
\fi}%
\global\let\monthnameitalian\monthnameitalian
%    \end{macrocode}
%    \begin{macrocode}
\providecommand{\shortmonthnameitalian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{Month numbers should go from 1 (gen) to 12 (dic)}%
\or gen%
\or feb%
\or mar%
\or apr%
\or mag%
\or giu%
\or lug%
\or ago%
\or set%
\or ott%
\or nov%
\or dic%
\else%
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{Month numbers should go from 1 (gen) to 12 (dic)}%
\fi}%
\global\let\shortmonthnameitalian\shortmonthnameitalian
%    \end{macrocode}
%    \begin{macrocode}
\DeclareRobustCommand*\dateitalian{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day\space\monthnameitalian[\@month]\space\number\@year}}%
\global\let\dateitalian\dateitalian
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-italian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-latin.def>
%    \end{macrocode}
%\fi
%\subsubsection{Latin}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-latin.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamelatin}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or Ianuarii%
\or Februarii%
\or Martii%
\or Aprilis%
\or Maii%
\or Iunii%
\or Iulii%
\or Augusti%
\or Septembris%
\or Octobris%
\or Novembris%
\or Decembris%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamelatin\monthnamelatin
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datelatin{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\check@mathfonts\fontsize\sf@size\z@\math@fontsfalse\selectfont
\uppercase\expandafter{\romannumeral\@day}%
~\monthnamelatin[\@month]\space
{\uppercase\expandafter{\romannumeral\@year}}}}%
\global\let\datelatin\datelatin
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-latin.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-lsorbian.def>
%    \end{macrocode}
%\fi
%\subsubsection{LSorbian}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-lsorbian.def}[2013/09/10]%
%    \end{macrocode}
% Define new month names.
%    \begin{macrocode}
\providecommand{\monthnamenewlsorbian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or januara%
\or februara%
\or m\v erca%
\or apryla%
\or maja%
\or junija%
\or julija%
\or awgusta%
\or septembra%
\or oktobra%
\or nowembra%
\or decembra%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamenewlsorbian\monthnamenewlsorbian
%    \end{macrocode}
% Define old month names.
%    \begin{macrocode}
\providecommand{\monthnameoldlsorbian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or wjelikego ro\v zka%
\or ma\l ego ro\v zka%
\or nal\v etnika%
\or jat\v sownika%
\or ro\v zownika%
\or sma\v znika%
\or pra\v znika%
\or \v znje\'nca%
\or po\v znje\'nca%
\or winowca%
\or nazymnika%
\or godownika%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameoldlsorbian\monthnameoldlsorbian
%    \end{macrocode}
% Set the default month names.
%    \begin{macrocode}
\global\let\monthnamelsorbian\monthnamenewlsorbian
%    \end{macrocode}
% (Re)Define declaration to switch to new format.
%    \begin{macrocode}
\DeclareRobustCommand*\newdatelsorbian{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnamenewlsorbian[\@month]\space\number\@year}}%
\global\let\newdatelsorbian\newdatelsorbian
%    \end{macrocode}
% (Re)Define declaration to switch to old format.
%    \begin{macrocode}
\DeclareRobustCommand*\olddatelsorbian{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnameoldlsorbian[\@month]\space\number\@year}}%
\global\let\olddatelsorbian\olddatelsorbian
%    \end{macrocode}
% Set the default date format.
%    \begin{macrocode}
\global\let\datelsorbian\newdatelsorbian
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-lsorbian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-magyar.def>
%    \end{macrocode}
%\fi
%\subsubsection{Magyar}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-magyar.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamemagyar}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or janu\'ar%
\or febru\'ar%
\or m\'arcius%
\or \'aprilis%
\or m\'ajus%
\or j\'unius%
\or j\'ulius%
\or augusztus%
\or szeptember%
\or okt\'ober%
\or november%
\or december%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamemagyar\monthnamemagyar
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datemagyar{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@year.~\monthnamemagyar[\@month]\space\number\@day.}}%
\global\let\datemagyar\datemagyar
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-magyar.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-naustrian.def>
%    \end{macrocode}
%\fi
%\subsubsection{NAustrian}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-naustrian.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamenaustrian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or J\"anner%
\or Februar%
\or M\"arz%
\or April%
\or Mai%
\or Juni%
\or Juli%
\or August%
\or September%
\or Oktober%
\or November%
\or Dezember%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamenaustrian\monthnamenaustrian
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datenaustrian{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnamenaustrian[\@month]\space\number\@year}}%
\global\let\datenaustrian\datenaustrian
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-naustrian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-newzealand.def>
%    \end{macrocode}
%\fi
%\subsection{Compatibility with Babel (Language definition files)}
%\subsubsection{newzealand}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-newzealand.def}[2013/09/10]%
%    \end{macrocode}
%\begin{macro}{\datenewzealand}
%    \begin{macrocode}
\global\let\datenewzealand\usdate
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\monthnamenewzealand}
%    \begin{macrocode}
\global\let\monthnamenewzealand\monthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortmonthnamenewzealand}
%    \begin{macrocode}
\global\let\shortmonthnamenewzealand\shortmonthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dayofweeknameidnewzealand}
%    \begin{macrocode}
\global\let\dayofweeknameidnewzealand\dayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortdayofweeknamenewzealand}
%    \begin{macrocode}
\global\let\shortdayofweeknameidnewzealand\shortdayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinaldatenewzealand}
%    \begin{macrocode}
\providecommand*{\ordinaldatenewzealand}[1]{#1}%
\global\let\ordinaldatenewzealand\ordinaldatenewzealand
%    \end{macrocode}
%\end{macro}
%\iffalse
%    \begin{macrocode}
%</dt-newzealand.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-ngerman.def>
%    \end{macrocode}
%\fi
%\subsubsection{NGerman}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-ngerman.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamengerman}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or Januar%
\or Februar%
\or M\"arz%
\or April%
\or Mai%
\or Juni%
\or Juli%
\or August%
\or September%
\or Oktober%
\or November%
\or Dezember%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamengerman\monthnamengerman
%    \end{macrocode}
% The following week day names were supplied by Uwe Bieling:
%    \begin{macrocode}
\providecommand{\dayofweeknameidngerman}[1]{%
\ifcase#1\relax
\or Sonntag%
\or Montag%
\or Dienstag%
\or Mittwoch%
\or Donnerstag%
\or Freitag%
\or Samstag%
\fi}%
\global\let\dayofweeknameidngerman\dayofweeknameidngerman
%    \end{macrocode}
%    \begin{macrocode}
\providecommand{\shortdayofweeknameidngerman}[1]{%
\ifcase#1\relax
\or So%
\or Mo%
\or Di%
\or Mi%
\or Do%
\or Fr%
\or Sa%
\fi}%
\global\let\shortdayofweeknameidngerman\shortdayofweeknameidngerman
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datengerman{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnamengerman[\@month]\space\number\@year}}%
\global\let\datengerman\datengerman
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-ngerman.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-norsk.def>
%    \end{macrocode}
%\fi
%\subsubsection{Norsk}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-norsk.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamenorsk}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or januar%
\or februar%
\or mars%
\or april%
\or mai%
\or juni%
\or juli%
\or august%
\or september%
\or oktober%
\or november%
\or desember%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamenorsk\monthnamenorsk
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datenorsk{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnamenorsk[\@month]\space\number\@year}}%
\global\let\datenorsk\datenorsk
%    \end{macrocode}
% Day of week provided by Tor Inge Birkenes
%    \begin{macrocode}
\providecommand*{\dayofweeknameidnorsk}[1]{%
\ifcase#1\relax
\or S\o{}ndag%
\or Mandag%
\or Tirsdag%
\or Onsdag%
\or Torsdag%
\or Fredag%
\or L\o{}rdag%
\fi}
\providecommand*{\shortdayofweeknameidnorsk}[1]{%
\ifcase#1\relax
\or S\o{}n%
\or Man%
\or Tir%
\or Ons%
\or Tor%
\or Fre%
\or L\o{}r%
\fi}
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-norsk.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-polish.def>
%    \end{macrocode}
%\fi
%\subsubsection{Polish}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-polish.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%\begin{macro}{\monthnamepolish}
%    \begin{macrocode}
\providecommand{\monthnamepolish}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or stycznia%
\or lutego%
\or marca%
\or kwietnia%
\or maja%
\or czerwca%
\or lipca%
\or sierpnia%
\or wrze\'snia%
\or pa\'zdziernika%
\or listopada%
\or grudnia%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}
\global\let\monthnamepolish\monthnamepolish
%    \end{macrocode}
%\end{macro}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datepolish{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day~\monthnamepolish[\@month]\space\number\@year}}%
\global\let\datepolish\datepolish
%    \end{macrocode}
% The week names were provided by Piotr Kempa
%\begin{macro}{\dayofweeknameidpolish}
%    \begin{macrocode}
\providecommand{\dayofweeknameidpolish}[1]{%
\ifcase#1\relax
\or Niedziela%
\or Poniedzia\l ek%
\or Wtorek%
\or \'Sroda%
\or Czwartek%
\or Pi\k atek%
\or Sobota%
\fi}%
\global\let\dayofweeknameidpolish\dayofweeknameidpolish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortdayofweeknameidpolish}
%    \begin{macrocode}
\providecommand{\shortdayofweeknameidpolish}[1]{%
\ifcase#1\relax
\or Ndz.%
\or Pon.%
\or Wt.%
\or \'Sr.%
\or Czw.%
\or Pt.%
\or Sob.%
\fi}%
\global\let\shortdayofweeknameidpolish\shortdayofweeknameidpolish
%    \end{macrocode}
%\end{macro}
%\iffalse
%    \begin{macrocode}
%</dt-polish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-portuges.def>
%    \end{macrocode}
%\fi
%\subsubsection{Portuges}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-portuges.def}[2013/09/10]%
%    \end{macrocode}
% Define week day names.
%    \begin{macrocode}
\providecommand{\dayofweeknameidportuges}[1]{%
\ifcase#1\relax
\or domingo%
\or segunda-feira%
\or ter\c{c}a-feira%
\or quarta-feira%
\or quinta-feira%
\or sexta-feira%
\or sabado%
\fi}%
\global\let\dayofweeknameidportuges\dayofweeknameidportuges
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnameportuges}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or Janeiro%
\or Fevereiro%
\or Mar\c{c}o%
\or Abril%
\or Maio%
\or Junho%
\or Julho%
\or Agosto%
\or Setembro%
\or Outubro%
\or Novembro%
\or Dezembro%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameportuges\monthnameportuges
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dateportuges{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day\space de\space\monthnameportuges[\@month]\space
de\space\number\@year}}%
\global\let\dateportuges\dateportuges
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-portuges.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-romanian.def>
%    \end{macrocode}
%\fi
%\subsubsection{Romanian}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-romanian.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnameromanian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or ianuarie%
\or februarie%
\or martie%
\or aprilie%
\or mai%
\or iunie%
\or iulie%
\or august%
\or septembrie%
\or octombrie%
\or noiembrie%
\or decembrie%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameromanian\monthnameromanian
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dateromanian{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day~\monthnameromanian[\@month]\space\number\@year}}%
\global\let\dateromanian\dateromanian
%    \end{macrocode}
% The following were provided by Daniel Dumitriu:
%    \begin{macrocode}
\providecommand{\dayofweeknameidromanian}[1]{%
\ifcase#1\relax
\or duminic\u{a}%
\or luni%
\or mar\c{t}i%
\or miercuri%
\or joi%
\or vineri%
\or s\^{a}mb\u{a}t\u{a}%
\fi}%
\global\let\dayofweeknameidromanian\dayofweeknameidromanian
%    \end{macrocode}
%
%    \begin{macrocode}
\providecommand{\shortdayofweeknameidromanian}[1]{%
\ifcase#1\relax
\or D%
\or L%
\or Ma%
\or Mi%
\or J%
\or V%
\or S%
\fi}%
\global\let\shortdayofweeknameidromanian\shortdayofweeknameidromanian
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-romanian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-russian.def>
%    \end{macrocode}
%\fi
%\subsubsection{Russian}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-russian.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamerussian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or \cyrya\cyrn\cyrv\cyra\cyrr\cyrya\or
    \cyrf\cyre\cyrv\cyrr\cyra\cyrl\cyrya\or
    \cyrm\cyra\cyrr\cyrt\cyra\or
    \cyra\cyrp\cyrr\cyre\cyrl\cyrya\or
    \cyrm\cyra\cyrya\or
    \cyri\cyryu\cyrn\cyrya\or
    \cyri\cyryu\cyrl\cyrya\or
    \cyra\cyrv\cyrg\cyru\cyrs\cyrt\cyra\or
    \cyrs\cyre\cyrn\cyrt\cyrya\cyrb\cyrr\cyrya\or
    \cyro\cyrk\cyrt\cyrya\cyrb\cyrr\cyrya\or
    \cyrn\cyro\cyrya\cyrb\cyrr\cyrya\or
    \cyrd\cyre\cyrk\cyra\cyrb\cyrr\cyrya%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamerussian\monthnamerussian
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\daterussian{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day~\monthnamerussian[\@month]\ \number\@year~\cyrg.}}%
\global\let\daterussian\daterussian
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-russian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-samin.def>
%    \end{macrocode}
%\fi
%\subsubsection{Samin}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-samin.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamesamin}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or o\dj{}\dj{}ajagem\'anu\or
    guovvam\'anu\or
    njuk\v cam\'anu\or
    cuo\ng{}om\'anu\or
    miessem\'anu\or
    geassem\'anu\or
    suoidnem\'anu\or
    borgem\'anu\or
    \v cak\v cam\'anu\or
    golggotm\'anu\or
    sk\'abmam\'anu\or
    juovlam\'anu%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamesamin\monthnamesamin
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datesamin{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\monthnamesamin[\@month]\space\number\@day.~b.\space
\number\@year}}%
\global\let\datesamin\datesamin
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-samin.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-scottish.def>
%    \end{macrocode}
%\fi
%\subsubsection{Scottish}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-scottish.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamescottish}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or am Faoilteach%
\or an Gearran%
\or am M\`art%
\or an Giblean%
\or an C\`eitean%
\or an t-\`Og mhios%
\or an t-Iuchar%
\or L\`unasdal%
\or an Sultuine%
\or an D\`amhar%
\or an t-Samhainn%
\or an Dubhlachd%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamescottish\monthnamescottish
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datescottish{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day\space\monthnamescottish[\@month]\space \number\@year}}%
\global\let\datescottish\datescottish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-scottish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-serbian.def>
%    \end{macrocode}
%\fi
%\subsubsection{Serbian}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-serbian.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnameserbian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or januar%
\or februar%
\or mart%
\or april%
\or maj%
\or juni%
\or juli%
\or avgust%
\or septembar%
\or oktobar%
\or novembar%
\or decembar%
\else
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameserbian\monthnameserbian
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dateserbian{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnameserbian[\@month]\space \number\@year}}%
\global\let\dateserbian\dateserbian
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-serbian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-slovak.def>
%    \end{macrocode}
%\fi
%\subsubsection{Slovak}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-slovak.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnameslovak}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{Month 
numbers should go from 1 to 12}%
\or janu\'ara%
\or febru\'ara%
\or marca%
\or apr\'{\i}la%
\or m\'aja%
\or j\'una%
\or j\'ula%
\or augusta%
\or septembra%
\or okt\'obra%
\or novembra%
\or decembra%
\else \PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameslovak\monthnameslovak
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dateslovak{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnameslovak[\@month]\space \number\@year}}%
\global\let\dateslovak\dateslovak
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-slovak.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-slovene.def>
%    \end{macrocode}
%\fi
%\subsubsection{Slovene}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-slovene.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnameslovene}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or januar%
\or februar%
\or marec%
\or april%
\or maj%
\or junij%
\or julij%
\or avgust%
\or september%
\or oktober%
\or november%
\or december%
\else \PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameslovene\monthnameslovene
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dateslovene{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnameslovene[\@month]\space \number\@year}}%
\global\let\dateslovene\dateslovene
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-slovene.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-spanish.def>
%    \end{macrocode}
%\fi
%\subsubsection{Spanish}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-spanish.def}[2013/09/10]%
%    \end{macrocode}
% Define week day names.
%    \begin{macrocode}
\providecommand{\dayofweeknameidspanish}[1]{%
\ifcase#1\relax
\or domingo%
\or lunes%
\or martes%
\or mi\'ercoles%
\or jueves%
\or viernes%
\or s\'abado%
\fi}%
\global\let\dayofweeknameidspanish\dayofweeknameidspanish
%    \end{macrocode}
% Define abbreviated week day names (is this correct?)
%    \begin{macrocode}
\providecommand{\shortdayofweeknameidspanish}[1]{%
\ifcase#1\relax
\or dom%
\or lun%
\or mar%
\or mi\'e%
\or jue%
\or vie%
\or s\'ab%
\fi}%
\global\let\shortdayofweeknameidspanish\shortdayofweeknameidspanish
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamespanish}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or enero%
\or febrero%
\or marzo%
\or abril%
\or mayo%
\or junio%
\or julio%
\or agosto%
\or septiembre%
\or octubre%
\or noviembre%
\or diciembre%
\else \PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamespanish\monthnamespanish
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\datespanish{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day~de \monthnamespanish[\@month]\ de~\number\@year}}%
\global\let\datespanish\datespanish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-spanish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-swedish.def>
%    \end{macrocode}
%\fi
%\subsubsection{Swedish}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-swedish.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnameswedish}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or januari%
\or februari%
\or mars%
\or april%
\or maj%
\or juni%
\or juli%
\or augusti%
\or september%
\or oktober%
\or november%
\or december%
\else \PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameswedish\monthnameswedish
%    \end{macrocode}
% (Re)Define declaration to switch to this format 
% (day monthname year).
%    \begin{macrocode}
\DeclareRobustCommand*\dateswedish{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day~\monthnameswedish[\@month]\space\number\@year}}%
\global\let\dateswedish\dateswedish
%    \end{macrocode}
% (Re)Define declaration to switch to this format
% (two-digit numerical).
%    \begin{macrocode}
\DeclareRobustCommand*\datesymd{%
  \renewcommand{\formatdate}[3]{%
  \@day=##1\relax\@month=##2\relax\@year=##3\relax
  \number\@year-\two@digits\@month-\two@digits\@day}%
}%
\global\let\datesymd\datesymd
%    \end{macrocode}
% (Re)Define declaration to switch to this format
% (numerical).
%    \begin{macrocode}
\DeclareRobustCommand*\datesdmy{%
  \renewcommand{\formatdate}[3]{%
  \@day=##1\relax\@month=##2\relax\@year=##3\relax
  \number\@day/\number\@month\space\number\@year}%
}%
\global\let\datesdmy\datesdmy
%    \end{macrocode}
% Day of weekname provided by Johan Sj\"oblom
%    \begin{macrocode}
\providecommand*{\dayofweeknameidswedish}[1]{%
\ifcase#1\relax
\or S\"ondag%
\or M\aa{}ndag%
\or Tisdag%
\or Onsdag%
\or Torsdag%
\or Fredag%
\or L\"ordag%
\fi}
\providecommand*{\shortdayofweeknameidswedish}[1]{%
\ifcase#1\relax
\or S\"on%
\or M\aa{}n%
\or Tis%
\or Ons%
\or Tor%
\or Fre%
\or L\"or%
\fi}
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-swedish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-turkish.def>
%    \end{macrocode}
%\fi
%\subsubsection{Turkish}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-turkish.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnameturkish}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or  Ocak%
\or \c Subat%
\or Mart%
\or Nisan%
\or May\i{}s%
\or Haziran%
\or Temmuz%
\or A\u gustos%
\or Eyl\"ul%
\or Ekim%
\or Kas\i{}m%
\or Aral\i{}k%
\else \PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameturkish\monthnameturkish
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dateturkish{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day~\monthnameturkish[\@month]\space\number\@year}}%
\global\let\dateturkish\dateturkish
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-turkish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-UKenglish.def>
%    \end{macrocode}
%\fi
%\subsubsection{UKenglish}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-UKenglish.def}[2013/09/10]%
%    \end{macrocode}
%\begin{macro}{\dateUKenglish}
%    \begin{macrocode}
\global\let\dateUKenglish\longdate
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\monthnameUKenglish}
%    \begin{macrocode}
\global\let\monthnameUKenglish\monthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortmonthnameUKenglish}
%    \begin{macrocode}
\global\let\shortmonthnameUKenglish\shortmonthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dayofweeknameidUKenglish}
%    \begin{macrocode}
\global\let\dayofweeknameidUKenglish\dayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortdayofweeknameidUKenglish}
%    \begin{macrocode}
\global\let\shortdayofweeknameidUKenglish\shortdayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinaldateUKenglish}
%    \begin{macrocode}
\global\let\ordinaldateUKenglish\ordinaldateenglish
%    \end{macrocode}
%\end{macro}
%\iffalse
%    \begin{macrocode}
%</dt-UKenglish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-ukraineb.def>
%    \end{macrocode}
%\fi
%\subsubsection{Ukraine}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-ukraineb.def}[2013/09/10]%
%    \end{macrocode}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnameukraineb}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or \cyrs\cyrii\cyrch\cyrn\cyrya\or
    \cyrl\cyryu\cyrt\cyro\cyrg\cyro\or
    \cyrb\cyre\cyrr\cyre\cyrz\cyrn\cyrya\or
    \cyrk\cyrv\cyrii\cyrt\cyrn\cyrya\or
    \cyrt\cyrr\cyra\cyrv\cyrn\cyrya\or
    \cyrch\cyre\cyrr\cyrv\cyrn\cyrya\or
    \cyrl\cyri\cyrp\cyrn\cyrya\or
    \cyrs\cyre\cyrr\cyrp\cyrn\cyrya\or
    \cyrv\cyre\cyrr\cyre\cyrs\cyrn\cyrya\or
    \cyrzh\cyro\cyrv\cyrt\cyrn\cyrya\or
    \cyrl\cyri\cyrs\cyrt\cyro\cyrp\cyra\cyrd\cyra\or
    \cyrg\cyrr\cyru\cyrd\cyrn\cyrya%
\else \PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameukraineb\monthnameukraineb
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%    \begin{macrocode}
\DeclareRobustCommand*\dateukraineb{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day~\monthnameukraineb[\@month]\space\number\@year~\cyrr.}}%
\global\let\dateukraineb\dateukraineb
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-ukraineb.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-USenglish.def>
%    \end{macrocode}
%\fi
%\subsubsection{USenglish}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-USenglish.def}[2013/09/10]%
%    \end{macrocode}
%\begin{macro}{\dateUSenglish}
%    \begin{macrocode}
\global\let\dateUSenglish\usdate
%    \end{macrocode}
%\end{macro}
%\begin{macrocode}{\monthnameUSenglish}
%    \begin{macrocode}
\global\let\monthnameUSenglish\monthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\shortmonthnameUSenglish}
%    \begin{macrocode}
\global\let\shortmonthnameUSenglish\shortmonthnameenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\dayofweeknameidUSenglish}
%    \begin{macrocode}
\global\let\dayofweeknameidUSenglish\dayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macrocode}{\shortdayofweeknameidUSenglish}
%    \begin{macrocode}
\global\let\shortdayofweeknameidUSenglish\shortdayofweeknameidenglish
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\ordinaldateUSenglish}
%    \begin{macrocode}
\newcommand*{\ordinaldateUSenglish}[1]{#1}%
\global\let\ordinaldateUSenglish\ordinaldateUSenglish
%    \end{macrocode}
%\end{macro}
%\iffalse
%    \begin{macrocode}
%</dt-USenglish.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-usorbian.def>
%    \end{macrocode}
%\fi
%\subsubsection{USorbian}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-usorbian.def}[2013/09/10]%
%    \end{macrocode}
% Define (new) month names.
%    \begin{macrocode}
\providecommand{\monthnamenewusorbian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or januara%
\or februara%
\or m\v erca%
\or apryla%
\or meje%
\or junija%
\or julija%
\or awgusta%
\or septembra%
\or oktobra%
\or nowembra%
\or decembra%
\else \PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamenewusorbian\monthnamenewusorbian
%    \end{macrocode}
% Define (old) month names.
%    \begin{macrocode}
\providecommand{\monthnameoldusorbian}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or wulkeho r\'o\v zka%
\or ma\l eho r\'o\v zka%
\or nal\v etnika%
\or jutrownika%
\or r\'o\v zownika%
\or  sma\v znika%
\or pra\v znika%
\or \v znjenca%
\or po\v znjenca%
\or winowca%
\or nazymnika%
\or hodownika%
\else \PackageError{datetime}{Invalid Month number \the\@orgargctr}{Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnameoldusorbian\monthnameoldusorbian
%    \end{macrocode}
% Set up default
%    \begin{macrocode}
\global\let\monthnameusorbian\monthnamenewusorbian
%    \end{macrocode}
% (Re)Define declaration to switch to (new) format.
%    \begin{macrocode}
\DeclareRobustCommand*\newdateusorbian{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnamenewusorbian[\@month]\space\number\@year}}%
\global\let\newdateusorbian\newdateusorbian
%    \end{macrocode}
% (Re)Define declaration to switch to (old) format.
%    \begin{macrocode}
\DeclareRobustCommand*\olddateusorbian{%
\renewcommand{\formatdate}[3]{%
\@day=##1\relax\@month=##2\relax\@year=##3\relax
\number\@day.~\monthnameoldusorbian[\@month]\space\number\@year}}%
\global\let\olddateusorbian\olddateusorbian
%    \end{macrocode}
% Set up default
%    \begin{macrocode}
\global\let\dateusorbian\newdateusorbian
%    \end{macrocode}
%\iffalse
%    \begin{macrocode}
%</dt-usorbian.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-welsh.def>
%    \end{macrocode}
%\fi
%\subsubsection{Welsh}
% Identify file
%    \begin{macrocode}
\ProvidesFile{dt-welsh.def}[2013/09/10]%
%    \end{macrocode}
%\begin{macro}{\ordinaldatewelsh}
% Welsh version:
%    \begin{macrocode}
\providecommand*{\ordinaldatewelsh}[1]{%
#1\ifnum#1=1\/\textsuperscript{a\~n}\fi}%
\global\let\ordinaldatewelsh\ordinaldatewelsh
%    \end{macrocode}
%\end{macro}
% Define month names.
%    \begin{macrocode}
\providecommand{\monthnamewelsh}[1][\month]{%
\@orgargctr=#1\relax
\ifcase\@orgargctr
\PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\or Ionawr%
\or Chwefror%
\or Mawrth%
\or Ebrill%
\or Mai%
\or Mehefin%
\or Gorffennaf%
\or Awst%
\or Medi%
\or Hydref%
\or Tachwedd%
\or Rhagfyr%
\else \PackageError{datetime}{Invalid Month number \the\@orgargctr}{%
Month numbers should go from 1 to 12}%
\fi}%
\global\let\monthnamewelsh\monthnamewelsh
%    \end{macrocode}
% (Re)Define declaration to switch to this format.
%\changes{5.60}{2014-09-25}{removed `a viz'}
%    \begin{macrocode}
\DeclareRobustCommand*\datewelsh{%
\renewcommand{\formatdate}[3]{%
  \@day=##1\relax\@month=##2\relax\@year=##3\relax
  \ifnum\@day=1\relax
    1\/$^{\mathrm{a\tilde{n}}}$%
  \else
    \number\@day
  \fi 
  \space 
  \monthnamewelsh[\@month]\space\number\@year}%
}%
\global\let\datewelsh\datewelsh
%    \end{macrocode}
% \subsection{LaTeX2HTML Perl Script}
%\iffalse
%    \begin{macrocode}
%</dt-welsh.def>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-lang.tex>
%    \end{macrocode}
%\fi
%\iffalse
\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[french,spanish,english]{babel}
\usepackage{datetime} % Date will be language-dependent
%\usepackage[iso]{datetime} % Date will be displayed the same for all languages

\begin{document}
English: \today

\selectlanguage{french}
French: \today

\selectlanguage{spanish}
Spanish: \today

\begin{otherlanguage}{french}
French: \today
\end{otherlanguage}

\today
\end{document}
%\fi
%\iffalse
%    \begin{macrocode}
%</dt-lang.tex>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*dt-sampl.tex>
%    \end{macrocode}
%\fi
%\iffalse
\documentclass[a4paper]{article}

\usepackage{ifpdf}
\usepackage{datetime}


\ifpdf
\pdfinfo{
  /CreationDate (D:20040501215500Z)
  /ModDate (D:\pdfcreationdate)
}
\fi

\padzeroes[8]

\newdateformat{dashdate}{\twodigit{\THEDAY}-\twodigit{\THEMONTH}-\THEYEAR}
\newdateformat{usvardate}{\monthname[\THEMONTH]~\ordinaldate{\THEDAY}, \THEYEAR}
\newdateformat{mydate}{\ifshowdow \dayofweekname{\THEDAY}{\THEMONTH}{\THEYEAR} \fi
\THEDAY\ \monthname[\THEMONTH], \THEYEAR}
\newdateformat{yyyymmdd}{\THEYEAR\twodigit{\THEMONTH}\twodigit{\THEDAY}}
\newdateformat{ukvardate}{\THEDAY\ \monthname[\THEMONTH]\ \THEYEAR}

\newtimeformat{dottime}{\twodigit{\THEHOUR}.\twodigit{\THEMINUTE}}
\newtimeformat{dashtime12}{\THEHOURXII-\twodigit{\THEMINUTE}}
\newtimeformat{hhmm}{\twodigit{\THEHOUR}\twodigit{\THEMINUTE}}

\begin{document}

\section{Date Formats}
Default: \today.

\begin{tabular}{ll}
\bfseries Declaration & \bfseries\verb|\today|\\
\verb|\longdate| & \longdate\today\\
\verb|\shortdate| & \shortdate\today\\
\verb|\yyyymmdddate| & \yyyymmdddate\today\\
\verb|\ddmmyyyydate| & \ddmmyyyydate\today\\
\verb|\dmyyyydate| & \dmyyyydate\today\\
\verb|\ddmmyydate| & \ddmmyydate\today\\
\verb|\dmyydate| & \dmyydate\today\\
\verb|\textdate| & \textdate\today\\
\verb|\usdate| & \usdate\today\\
\verb|\mmddyyyydate| & \mmddyyyydate\today\\
\verb|\mdyyyydate| & \mdyyyydate\today\\
\verb|\mmddyydate| & \mmddyydate\today\\
\verb|\mdyydate| & \mdyydate\today
\end{tabular}

\section{Time Formats}
Default: \currenttime.

\begin{tabular}{@{\ttfamily}ll}
\bfseries\rmfamily Format & \bfseries \verb|\currenttime|\\
hhmmsstime & \settimeformat{hhmmsstime}\currenttime\\
xxivtime & \settimeformat{xxivtime}\currenttime\\
ampmtime & \settimeformat{ampmtime}\currenttime\\
oclock & \settimeformat{oclock}\currenttime
\end{tabular}

\section{Specific Date:}

\begin{tabular}{ll}
\bfseries Format & \bfseries \verb|\formatdate{1}{3}{2009}|\\
\verb|\longdate| & \longdate\formatdate{1}{3}{2000}\\
\verb|\shortdate| & \shortdate\formatdate{1}{3}{2000}\\
\verb|\yyyymmdddate| & \yyyymmdddate\formatdate{1}{3}{2000}\\
\verb|\ddmmyyyydate| & \ddmmyyyydate\formatdate{1}{3}{2000}\\
\verb|\dmyyyydate| & \dmyyyydate\formatdate{1}{3}{2000}\\
\verb|\ddmmyydate| & \ddmmyydate\formatdate{1}{3}{2000}\\
\verb|\dmyydate| & \dmyydate\formatdate{1}{3}{2000}\\
\verb|\textdate| & \textdate\formatdate{1}{3}{2000}\\
\verb|\usdate| & \usdate\formatdate{1}{3}{2000}\\
\verb|\mmddyyyydate| & \mmddyyyydate\formatdate{1}{3}{2000}\\
\verb|\mdyyyydate| & \mdyyyydate\formatdate{1}{3}{2000}\\
\verb|\mmddyydate| & \mmddyydate\formatdate{1}{3}{2000}\\
\verb|\mdyydate| & \mdyydate\formatdate{1}{3}{2000}
\end{tabular}

\section{Specific Time}

\begin{tabular}{@{\ttfamily}ll}
\bfseries\rmfamily Format & \bfseries \verb|\formattime{15}{45}{00}|\\
hhmmsstime & \settimeformat{hhmmsstime}\formattime{15}{45}{00}\\
xxivtime & \settimeformat{xxivtime}\formattime{15}{45}{00}\\
ampmtime & \settimeformat{ampmtime}\formattime{15}{45}{00}\\
oclock & \settimeformat{oclock}\formattime{15}{45}{00}
\end{tabular}

\vskip\baselineskip\noindent
\begin{tabular}{@{\ttfamily}ll}
\bfseries\rmfamily Format & \bfseries \verb|\formattime{0}{0}{0}|\\
hhmmsstime & \settimeformat{hhmmsstime}\formattime{0}{0}{0}\\
xxivtime & \settimeformat{xxivtime}\formattime{0}{0}{0}\\
ampmtime & \settimeformat{ampmtime}\formattime{0}{0}{0}\\
oclock & \settimeformat{oclock}\formattime{0}{0}{0}
\end{tabular}

\vskip\baselineskip\noindent
\begin{tabular}{@{\ttfamily}ll}
\bfseries\rmfamily Format & \bfseries \verb|\formattime{12}{0}{0}|\\
hhmmsstime & \settimeformat{hhmmsstime}\formattime{12}{0}{0}\\
xxivtime & \settimeformat{xxivtime}\formattime{12}{0}{0}\\
ampmtime & \settimeformat{ampmtime}\formattime{12}{0}{0}\\
oclock & \settimeformat{oclock}\formattime{12}{0}{0}
\end{tabular}

\section{Defining New Dates}

\begin{tabular}{ll}
\verb|\dashdate| & \dashdate\today\\
\verb|\usvardate| & \usvardate\today\\
\verb|\ukvardate| & \ukvardate\today\\
\verb|\mydate| & \mydate\today\\
\verb|\yyyymmdd| & \yyyymmdd\today\\
\verb|\dashdate| & \dashdate\formatdate{8}{3}{2000}\\
\verb|\usvardate| & \usvardate\formatdate{8}{3}{2000}\\
\verb|\mydate| & \mydate\formatdate{8}{3}{2000}\\
\verb|\yyyymmdd| & \yyyymmdd\formatdate{8}{3}{2000}
\end{tabular}

\section{Defining New Times}

\begin{tabular}{@{\ttfamily}ll}
\bfseries\rmfamily Format & \bfseries \verb|\currenttime|\\
dottime & \settimeformat{dottime}\currenttime\\
dashtime12 & \settimeformat{dashtime12}\currenttime\\
hhmm & \settimeformat{hhmm}\currenttime
\end{tabular}

\end{document}
%\fi
%\iffalse
%    \begin{macrocode}
%</dt-sampl.tex>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%<*datetime.perl>
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
# File        : datetime.perl
# Author      : Nicola Talbot
# Date        : 17 Nov 2009
# Version     : 1.04
#
# This is a LaTeX2HTML style implementing the datetime package, and
# is distributed as part of that package.
# Copyright 2007 Nicola L.C. Talbot
# This work may be distributed and/or modified under the
# conditions of the LaTeX Project Public License, either version 1.3
# of this license of (at your option) any later version.
# The latest version of this license is in
#   http://www.latex-project.org/lppl.txt
# and version 1.3 or later is part of all distributions of LaTeX
# version 2005/12/01 or later.
#
# This work has the LPPL maintenance status `maintained'.
#
# The Current Maintainer of this work is Nicola Talbot.

# set up default values for internal counters.

($global{SECONDS},$global{MINUTE},$global{HOUR},$global{DAY},$global{MONTH},$global{YEAR})=localtime(time);
$global{YEAR} += 1900;
$global{MONTH}++;

package main;

&do_require_package('fmtcount');

sub do_cmd_ordinaldate{
   &do_cmd_ordinalnum(@_);
}

# define package options

sub do_datetime_long{
   &do_cmd_longdate(@_);
}

sub do_datetime_short{
   &do_cmd_shortdate(@_);
}

sub do_datetime_text{
   &do_cmd_textdate(@_);
}

sub do_datetime_yyyymmdd{
   &do_cmd_yyyymmdddate(@_);
}

sub do_datetime_ddmmyyyy{
   &do_cmd_ddmmyyyydate(@_);
}

sub do_datetime_dmyyyy{
   &do_cmd_dmyyyydate(@_);
}

sub do_datetime_ddmmyy{
   &do_cmd_ddmmyydate(@_);
}

sub do_datetime_dmyy{
   &do_cmd_dmyyyydate(@_);
}

sub do_datetime_us{
   &do_cmd_usdate(@_);
}

sub do_datetime_mmddyyyy{
   &do_cmd_mmddyyyydate(@_);
}

sub do_datetime_mdyyyy{
   &do_cmd_mdyyyydate(@_);
}

sub do_datetime_mmddyy{
   &do_cmd_mmddyydate(@_);
}

sub do_datetime_mdyy{
   &do_cmd_mdyyyydate(@_);
}

sub do_datetime_raise{
   local($tmp)="";

   $tmp .= 'sub do_cmd_fmtord{';
   $tmp .= 'local($_) = @_;';
   $tmp .= 'local($num) = &missing_braces unless ((s/$next_pair_pr_rx//o)&&($num=$2));';
   $tmp .= 'join("", "<SUP>",$num,"</SUP>",$_);';
   $tmp .='}';

   eval($tmp);
}

sub do_datetime_level{
   local($tmp)="";

   $tmp .= 'sub do_cmd_fmtord{';
   $tmp .= 'local($_) = @_;';
   $tmp .= 'local($num) = &missing_braces unless ((s/$next_pair_pr_rx//o)&&($num=$2));';
   $tmp .= 'join("", $num,$_);';
   $tmp .='}';

   eval($tmp);
}

sub do_datetime_dayofweek{
   &do_cmd_showdowtrue(@_);
}

sub do_datetime_nodayofweek{
   &do_cmd_showdowfalse(@_);
}

sub do_datetime_hhmmss{
  &set_timeformat_hhmmsstime
}

sub do_datetime_24hr{
  &set_timeformat_xxivtime
}

&do_datetime_24hr;

sub do_datetime_12hr{
  &set_timeformat_ampmtime
}

sub do_datetime_oclock{
  &set_timeformat_oclock
}

sub do_datetime_iso{
  &set_timeformat_hhmmsstime;
  &do_cmd_yyyymmdddate;
  eval('sub do_cmd_dateseparator{join(\'\', \'-\', $_[0]);}');
  eval('sub do_cmd_timeseparator{join(\'\', \':\', $_[0]);}');
}

# babel stuff (Month will already be redefined by babel, so only need to change $dateformat)

sub do_datetime_austrian{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateaustrian{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateaustrian(@_);
}

if (defined &austrian_today)
{
   &do_datetime_austrian(@_);
}

sub do_datetime_bahasa{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datebahasa{';
   $tmp .= '  $dateformat = "THEDAY MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datebahasa(@_);
}

if (defined &bahasa_today)
{
   &do_datetime_bahasa(@_);
}

sub do_datetime_basque{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datebasque{';
   $tmp .= '  $dateformat = "THEYEAR.eko MONTHNAME[THEMONTH] THEDAY";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datebasque(@_);
}

if (defined &basque_today)
{
   &do_datetime_basque(@_);
}

sub do_datetime_breton{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datebreton{';
   $tmp .= '  $dateformat = "{ORDINALDATE{DAY}}\\ a viz MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   $tmp = 'sub do_cmd_ordinaldate{';
   $tmp .= 'local($_) = @_;';
   $tmp .= 'local($num) = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($num=$2));';
   $tmp .= 'local($before) = $num;';
   
   $tmp .= 'if ($num == 1)';
   $tmp .= '{ $before .= \'a\~n\'; }';

   $tmp .= '$before . $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datebreton(@_);
}

if (defined &breton_today)
{
   &do_datetime_breton(@_);
}

sub do_datetime_bulgarian{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datebulgarian{';
   $tmp .= '  $dateformat = "THEDAY MONTHNAME[THEMONTH] THEYEAR \\cyrg.";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datebulgarian(@_);
}

if (defined &bulgarian_today)
{
   &do_datetime_bulgarian(@_);
}

sub do_datetime_catalan{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datecatalan{';
   $tmp .= '  $dateformat = "THEDAY MONTHNAME[THEMONTH] de THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datecatalan(@_);
}

if (defined &catalan_today)
{
   &do_datetime_catalan(@_);
}

sub do_datetime_croatian{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datecroatian{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR.";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datecroatian(@_);
}

if (defined &croatian_today)
{
   &do_datetime_croatian(@_);
}

sub do_datetime_czech{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateczech{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateczech(@_);
}

if (defined &czech_today)
{
   &do_datetime_czech(@_);
}

sub do_datetime_danish{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datedanish{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datedanish(@_);
}

if (defined &danish_today)
{
   &do_datetime_danish(@_);
}

sub do_datetime_dutch{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datedutch{';
   $tmp .= '  $dateformat = "THEDAY MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datedutch(@_);
}

if (defined &dutch_today)
{
   &do_datetime_dutch(@_);
}

sub do_datetime_esperanto{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateesperanto{';
   $tmp .= '  $dateformat = "THEDAY--a de MONTHNAME[THEMONTH], THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateesperanto(@_);
}

if (defined &esperanto_today)
{
   &do_datetime_esperanto(@_);
}

sub do_datetime_estonian{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateestonian{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR. a.";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateestonian(@_);
}

if (defined &estonian_today)
{
   &do_datetime_estonian(@_);
}

sub do_datetime_finnish{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datefinnish{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datefinnish(@_);
}

if (defined &finnish_today)
{
   &do_datetime_finnish(@_);
}

sub do_datetime_french{
   local($tmp) = "";

   eval($tmp);
   $tmp .= 'sub do_cmd_datefrench{';
   $tmp .= '  $dateformat = "{ORDINALDATE{DAY}}\\ MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   $tmp = 'sub do_cmd_ordinaldate{';
   $tmp .= 'local($_) = @_;';
   $tmp .= 'local($num) = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($num=$2));';
   $tmp .= 'local($before) = $num;';
   
   $tmp .= 'if ($num == 1)';
   $tmp .= '{ $before .= \'\ier\'; }';

   $tmp .= '$before . $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datefrench(@_);
}

if (defined &french_today)
{
   &do_datetime_french(@_);
}

sub do_datetime_galician{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dategalician{';
   $tmp .= '  $dateformat = "THEDAY de MONTHNAME[THEMONTH] de THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dategalician(@_);
}

if (defined &galician_today)
{
   &do_datetime_galician(@_);
}

sub do_datetime_german{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dategerman{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dategerman(@_);
}

if (defined &german_today)
{
   &do_datetime_german(@_);
}

sub do_datetime_greek{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dategreek{';
   $tmp .= '  $dateformat = "THEDAY MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dategreek(@_);
}

if (defined &greek_today)
{
   &do_datetime_greek(@_);
}

sub do_datetime_icelandic{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateicelandic{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateicelandic(@_);
}

if (defined &icelandic_today)
{
   &do_datetime_icelandic(@_);
}

sub do_datetime_irish{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateirish{';
   $tmp .= '  $dateformat = "THEDAY MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateirish(@_);
}

if (defined &irish_today)
{
   &do_datetime_irish(@_);
}

sub do_datetime_italian{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateitalian{';
   $tmp .= '  $dateformat = "THEDAY MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateitalian(@_);
}

if (defined &italian_today)
{
   &do_datetime_italian(@_);
}

sub do_datetime_latin{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datelatin{';
   $tmp .= '  $dateformat = "ROMANNUMERALU{THEDAY} MONTHNAME[THEMONTH] ROMANNUMERALU{THEYEAR}";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datelatin(@_);
}

if (defined &latin_today)
{
   &do_datetime_latin(@_);
}

sub do_datetime_lsorbian{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datelsorbian{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datelsorbian(@_);
}

if (defined &lsorbian_today)
{
   &do_datetime_lsorbian(@_);
}

sub do_datetime_magyar{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datemagyar{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR.";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datemagyar(@_);
}

if (defined &magyar_today)
{
   &do_datetime_magyar(@_);
}

sub do_datetime_naustrian{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datenaustrian{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datenaustrian(@_);
}

if (defined &naustrian_today)
{
   &do_datetime_naustrian(@_);
}

sub do_datetime_ngerman{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datengerman{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datengerman(@_);
}

if (defined &ngerman_today)
{
   &do_datetime_ngerman(@_);
}

sub do_datetime_norsk{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datenorsk{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datenorsk(@_);
}

if (defined &norsk_today)
{
   &do_datetime_norsk(@_);
}

sub do_datetime_polish{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datenorsk{';
   $tmp .= '  $dateformat = "THEDAY MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datenorsk(@_);
}

if (defined &polish_today)
{
   &do_datetime_polish(@_);
}

sub do_datetime_portuges{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateportuges{';
   $tmp .= '  $dateformat = "THEDAY de MONTHNAME[THEMONTH] de THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateportuges(@_);
}

if (defined &portuges_today)
{
   &do_datetime_portuges(@_);
}

sub do_datetime_romanian{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateromanian{';
   $tmp .= '  $dateformat = "THEDAY MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateromanian(@_);
}

if (defined &romanian_today)
{
   &do_datetime_romanian(@_);
}

sub do_datetime_russian{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_daterussian{';
   $tmp .= '  $dateformat = "THEDAY MONTHNAME[THEMONTH] THEYEAR \\\\cyrg.";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_daterussian(@_);
}

if (defined &russian_today)
{
   &do_datetime_russian(@_);
}

sub do_datetime_samin{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datesamin{';
   $tmp .= '  $dateformat = "MONTHNAME[THEMONTH] THEDAY.~b. THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datesamin(@_);
}

if (defined &samin_today)
{
   &do_datetime_samin(@_);
}

sub do_datetime_scottish{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datescottish{';
   $tmp .= '  $dateformat = "THEDAY MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datescottish(@_);
}

if (defined &scottish_today)
{
   &do_datetime_scottish(@_);
}

sub do_datetime_serbian{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateserbian{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateserbian(@_);
}

if (defined &serbian_today)
{
   &do_datetime_serbian(@_);
}

sub do_datetime_slovak{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateslovak{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateslovak(@_);
}

if (defined &slovak_today)
{
   &do_datetime_slovak(@_);
}

sub do_datetime_slovene{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateslovene{';
   $tmp .= '  $dateformat = "THEDAY. MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateslovene(@_);
}

if (defined &slovene_today)
{
   &do_datetime_slovene(@_);
}

sub do_datetime_spanish{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datespanish{';
   $tmp .= '  $dateformat = "THEDAY~de MONTHNAME[THEMONTH] de~THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datespanish(@_);
}

if (defined &spanish_today)
{
   &do_datetime_spanish(@_);
}

sub do_datetime_swedish{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateswedish{';
   $tmp .= '  $dateformat = "THEDAY~MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   $tmp = "";
   $tmp .= 'sub do_cmd_datesymd{';
   $tmp .= '  $dateformat = "THEYEAR-TWODIGIT{THEMONTH}-TWODIGIT{THEDAY}";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   $tmp = "";
   $tmp .= 'sub do_cmd_datesdmy{';
   $tmp .= '  $dateformat = "THEDAY/THEMONTH THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateswedish(@_);
}

if (defined &swedish_today)
{
   &do_datetime_swedish(@_);
}

sub do_datetime_turkish{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateturkish{';
   $tmp .= '  $dateformat = "THEDAY~MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateturkish(@_);
}

if (defined &turkish_today)
{
   &do_datetime_turkish(@_);
}

sub do_datetime_ukraineb{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateukraineb{';
   $tmp .= '  $dateformat = "THEDAY~MONTHNAME[THEMONTH] THEYEAR~\\\\cyrr.";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateukraineb(@_);
}

if (defined &ukraineb_today)
{
   &do_datetime_ukraineb(@_);
}

sub do_datetime_usorbian{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_dateusorbian{';
   $tmp .= '  $dateformat = "THEDAY.~MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_dateusorbian(@_);
}

if (defined &usorbian_today)
{
   &do_datetime_usorbian(@_);
}

sub do_datetime_welsh{
   local($tmp) = "";

   $tmp .= 'sub do_cmd_datewelsh{';
   $tmp .= '  $dateformat = "{ORDINALDATE{DAY}}\\ a viz MONTHNAME[THEMONTH] THEYEAR";';
   $tmp .= '   $_[0];';
   $tmp .= '}';

   eval($tmp);

   $tmp = 'sub do_cmd_ordinaldate{';
   $tmp .= 'local($_) = @_;';
   $tmp .= 'local($num) = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($num=$2));';
   $tmp .= 'local($before) = $num;';
   
   $tmp .= 'if ($num == 1)';
   $tmp .= '{ $before .= \'a\~n\'; }';

   $tmp .= '$before . $_[0];';
   $tmp .= '}';

   eval($tmp);

   &do_cmd_datewelsh(@_);
}

if (defined &welsh_today)
{
   &do_datetime_welsh(@_);
}

# As far as I know, LaTeX2HTML doesn't implement TeX conditionals.
# $showdow corresponds to LaTeX boolean variable showdow
$showdow = 1;

sub get_monthname{
   local($month) = @_;

   if ($month eq 'THEMONTH' or $month eq '\THEMONTH')
   {
      # this is a cludge to help newdateformat work

      'MONTHNAME[THEMONTH]';
   }
   else
   {
      if ($month eq '')
      {
         local($today) = &get_date();
         $today =~ m|(\d+)/0?(\d+)/|;
         $month = $1;
      }

      $Month[$month];
   }
}

sub do_cmd_monthname{
   local($_) = @_;
   local($month,$pat) = &get_next_optional_argument;

   local($monthname) = &get_monthname($month);
   join('',$monthname,$_);
}

sub get_shortmonthname{
   local($month) = @_;

   if ($month eq 'THEMONTH' or $month eq '\THEMONTH')
   {
      'SHORTMONTHNAME[THEMONTH]';
   }
   else
   {
      substr(&get_monthname($month), 0, 3);
   }
}

sub do_cmd_shortmonthname{
   local($_) = @_;
   local($month,$pat) = &get_next_optional_argument;

   local($monthname) = &get_shortmonthname($month);

   join('',$monthname,$_);
}

sub is_leap_year{
   local($year) = @_;
   local($isleapyear) = 0;

   if (($year%400) == 0)
   {
      # year mod 400 = 0 => leap year

      $isleapyear = 1;
   }
   elsif (($year%100) == 0)
   {
      # year mod 100 = 0 and year mod 400 != 0 => not a leap year

      $isleapyear = 0;
   }
   elsif (($year%4) == 0)
   {
      # year mod 4 = 0 and year mod 100 != 0 => leap year

      $isleapyear = 1;
   }

   $isleapyear;
}

sub get_day_of_year{
   local($day,$month,$year) = @_;
   local($dayofyear) = 0;

   SWITCH: {
      if ($month == 2) {$dayofyear += 31; last SWITCH; }
      if ($month == 3) {$dayofyear += 59; last SWITCH; }
      if ($month == 4) {$dayofyear += 90; last SWITCH; }
      if ($month == 5) {$dayofyear += 120; last SWITCH; }
      if ($month == 6) {$dayofyear += 151; last SWITCH; }
      if ($month == 7) {$dayofyear += 181; last SWITCH; }
      if ($month == 8) {$dayofyear += 212; last SWITCH; }
      if ($month == 9) {$dayofyear += 243; last SWITCH; }
      if ($month == 10) {$dayofyear += 273; last SWITCH; }
      if ($month == 11) {$dayofyear += 304; last SWITCH; }
      if ($month == 12) {$dayofyear += 334; last SWITCH; }
   }

   if ($month > 2 && &is_leap_year($year))
   {
      $dayofyear += 1;
   }

   $dayofyear += $day;
   local($_)=$dayofyear;
}

sub get_day_of_week{
   local($day,$month,$year) = @_;
   local($dayofyear) = &get_day_of_year($day,$month,$year);
   local($_) = (((($year-1901)%28)*1.25 + 2)%7 + $dayofyear - 1)%7 + 1;
}

sub get_day_of_weekname_english{
   local($dow) = @_;

   local(@DayOfWeek) = ('Sunday', 
                        'Monday', 
                        'Tuesday', 
                        'Wednesday', 
                        'Thursday', 
                        'Friday', 
                        'Saturday');

   if ($dow <= 0 || $dow > 7)
   {
      &write_warnings("Invalid day of week number: $dow");
   }
   else
   {
      $DayOfWeek[$dow-1];
   }
}

sub get_day_of_weekname_french{
   local($dow) = @_;

   local(@DayOfWeek) = ('dimanche',
                        'lundi', 
                        'mardi', 
                        'mercredi', 
                        'jeudi', 
                        'vendredi', 
                        'samedi');

   if ($dow <= 0 || $dow > 7)
   {
      &write_warnings("Invalid day of week number: $dow");
   }
   else
   {
      $DayOfWeek[$dow-1];
   }
}

sub get_day_of_weekname_spanish{
   local($dow) = @_;

   local(@DayOfWeek) = ('domingo',
                        'lunes', 
                        'martes', 
                        'mi\\\'ercoles', 
                        'jueves', 
                        'viernes', 
                        's\\\'abado');

   if ($dow <= 0 || $dow > 7)
   {
      &write_warnings("Invalid day of week number: $dow");
   }
   else
   {
      $DayOfWeek[$dow-1];
   }
}

sub get_day_of_weekname_portuges{
   local($dow) = @_;

   local(@DayOfWeek) = ('domingo',
                        'segunda-feira', 
                        'ter\c{c}a-feira', 
                        'quarta-feira', 
                        'quinta-feira',
                        'sexta-feira', 
                        'sabado');

   if ($dow <= 0 || $dow > 7)
   {
      &write_warnings("Invalid day of week number: $dow");
   }
   else
   {
      $DayOfWeek[$dow-1];
   }
}

sub get_day_of_weekname_german{
   local($dow) = @_;

   local(@DayOfWeek) = ('Sonntag',
                        'Montag', 
                        'Dienstag', 
                        'Mittwoch', 
                        'Donnerstag', 
                        'Freitag', 
                        'Samstag');

   if ($dow <= 0 || $dow > 7)
   {
      &write_warnings("Invalid day of week number: $dow");
   }
   else
   {
      $DayOfWeek[$dow-1];
   }
}

sub get_day_of_weekname_ngerman{
   local($dow) = @_;

   local(@DayOfWeek) = ('Sonntag',
                        'Montag', 
                        'Dienstag', 
                        'Mittwoch', 
                        'Donnerstag', 
                        'Freitag', 
                        'Samstag');

   if ($dow <= 0 || $dow > 7)
   {
      &write_warnings("Invalid day of week number: $dow");
   }
   else
   {
      $DayOfWeek[$dow-1];
   }
}

sub get_day_of_weekname{
   local($dow)=@_;
   local($dowsub);

   $dowsub = "get_day_of_weekname_$default_language";

   if (defined ($dowsub))
   {
      &$dowsub($dow);
   }
   else
   {
      &get_day_of_weekname_english($dow);
   }
}

sub get_short_day_of_weekname_english{
   local($dow) = @_;

   local(@DayOfWeek) = ('Sun', 
                        'Mon', 
                        'Tue', 
                        'Wed', 
                        'Thu', 
                        'Fri', 
                        'Sat');

   if ($dow <= 0 || $dow > 7)
   {
      &write_warnings("Invalid day of week number: $dow");
   }
   else
   {
      $DayOfWeek[$dow-1];
   }
}

sub get_short_day_of_weekname_german{
   local($dow) = @_;

   local(@DayOfWeek) = ('So', 
                        'Mo', 
                        'Di', 
                        'Mi', 
                        'Do', 
                        'Fr', 
                        'Sa');

   if ($dow <= 0 || $dow > 7)
   {
      &write_warnings("Invalid day of week number: $dow");
   }
   else
   {
      $DayOfWeek[$dow-1];
   }
}

sub get_short_day_of_weekname_ngerman{
   local($dow) = @_;

   local(@DayOfWeek) = ('So', 
                        'Mo', 
                        'Di', 
                        'Mi', 
                        'Do', 
                        'Fr', 
                        'Sa');

   if ($dow <= 0 || $dow > 7)
   {
      &write_warnings("Invalid day of week number: $dow");
   }
   else
   {
      $DayOfWeek[$dow-1];
   }
}

sub get_short_day_of_weekname{
   local($dow)=@_;
   local($dowsub);

   $dowsub = "get_short_day_of_weekname_$default_language";

   if (defined ($dowsub))
   {
      &$dowsub($dow);
   }
   else
   {
      substr(&get_day_of_weekname($dow),0,3);
   }
}

sub do_cmd_dayofweeknameid{
   local($_) = @_;
   local($dow);

   $dow = &missing_braces unless ((s/$next_pair_pr_rx//o)&&($dow=$2));

   join('',&get_day_of_weekname($dow), $_);
}

sub do_cmd_dayofweekname{
   local($_) = @_;
   local($day,$month,$year);
   # read 1st argument
   $day = &missing_braces unless ((s/$next_pair_pr_rx//o)&&($day=$2));
   # read 2nd argument
   $month = &missing_braces unless ((s/$next_pair_pr_rx//o)&&($month=$2));
   # read 3rd argument
   $year = &missing_braces unless ((s/$next_pair_pr_rx//o)&&($year=$2));

   if ($day eq 'THEDAY' or $day eq '\THEDAY')
   {
      # this is a cludge to help newdateformat work

      join('', '{DOW}', $_);
   }
   else
   {
      local($dow) = &get_day_of_week($day,$month,$year);

      join('',&get_day_of_weekname($dow), $_);
   }
}

sub do_cmd_shortdayofweekname{
   local($_) = @_;
   local($day,$month,$year);
   # read 1st argument
   $day = &missing_braces unless ((s/$next_pair_pr_rx//o)&&($day=$2));
   # read 2nd argument
   $month = &missing_braces unless ((s/$next_pair_pr_rx//o)&&($month=$2));
   # read 3rd argument
   $year = &missing_braces unless ((s/$next_pair_pr_rx//o)&&($year=$2));

   local($dow) = &get_day_of_week($day,$month,$year);

   join('',&get_short_day_of_weekname($dow), $_);
}

sub do_cmd_thisdayofweekname{
   local($dow) = &get_day_of_week($global{DAY}, $global{MONTH}, $global{YEAR});

   join('',$DayOfWeek[$dow], $_);
}

sub do_cmd_thisshortdayofweekname{
   local($dow) = &get_day_of_week($global{DAY}, $global{MONTH}, $global{YEAR});

   join('',&get_short_day_of_weekname($dow), $_);
}

$dateformat = "\\ifshowdow{DOW}\\fi {ORDINALDATE{DAY}}\\ MONTHNAME[THEMONTH], THEYEAR";

sub format_date{
   local($day,$month,$year) = @_;

   local($str) = $dateformat;

   $str =~ s/THEDAY/$day/g;
   $str =~ s/THEMONTH/$month/g;
   $str =~ s/THEYEAR/$year/g;

   $str =~ s/TWODIGIT{([\d]+)}/&get_twodigit($1)/eg;
   $str =~ s/ROMANNUMERAL{([\d]+)}/&froman($1)/eg;
   $str =~ s/ROMANNUMERALU{([\d]+)}/uc(&froman($1))/eg;
   $str =~ s/TRUNCATE{([\d]+)}/&get_twodigit($1%100)/eg;
   $str =~ s/SHORTMONTHNAME\[([\d]+)\]/&get_shortmonthname($1)/eg;
   $str =~ s/MONTHNAME\[([\d]+)\]/&get_monthname($1)/eg;

   local($X) = ++$global{'max_id'};
   local($Y) = ++$global{'max_id'};
   local($Z) = ++$global{'max_id'};
   $str =~ s/{DOW}/\\dayofweekname${OP}$X${CP}$day${OP}$X${CP}${OP}$Y${CP}$month${OP}$Y${CP}${OP}$Z${CP}$year${OP}$Z${CP}/g;
   $str =~ s/{SDOW}/\\shortdayofweekname${OP}$X${CP}$day${OP}$X${CP}${OP}$Y${CP}$month${OP}$Y${CP}${OP}$Z${CP}$year${OP}$Z${CP}/g;

   local($br_id) = ++$global{'max_id'};
   $suffix = &get_ordinal_suffix($day);
   $str =~ s/{ORDINAL{DAY}}/$day\\fmtord${OP}$br_id${CP}$suffix${OP}$br_id${CP}/g;

   $br_id = ++$global{'max_id'};
   $suffix = &get_ordinal_suffix($month);
   $str =~ s/{ORDINAL{MONTH}}/$month\\fmtord${OP}$br_id${CP}$suffix${OP}$br_id${CP}/g;

   $br_id = ++$global{'max_id'};
   $suffix = &get_ordinal_suffix($year);
   $str =~ s/{ORDINAL{YEAR}}/$year\\fmtord${OP}$br_id${CP}$suffix${OP}$br_id${CP}/g;

   local($br_id) = ++$global{'max_id'};
   $str =~ s/{ORDINALDATE{DAY}}/\\ordinaldate${OP}$br_id${CP}$day${OP}$br_id${CP}/g;

   $str =~ s/{NNUMBERSTRING{DAY}}/&get_Numberstring($day)/eg;
   $str =~ s/{NNUMBERSTRING{MONTH}}/&get_Numberstring($month)/eg;
   $str =~ s/{NNUMBERSTRING{YEAR}}/&get_Numberstring($year)/eg;

   $str =~ s/{OORDINALSTRING{DAY}}/&get_Ordinalstring($day)/eg;
   $str =~ s/{OORDINALSTRING{MONTH}}/&get_Ordinalstring($month)/eg;
   $str =~ s/{OORDINALSTRING{YEAR}}/&get_Ordinalstring($year)/eg;

   $str =~ s/{CAPNUMBERSTRING{DAY}}/uc(&get_numberstring($day))/eg;
   $str =~ s/{CAPNUMBERSTRING{MONTH}}/uc(&get_numberstring($month))/eg;
   $str =~ s/{CAPNUMBERSTRING{YEAR}}/uc(&get_numberstring($year))/eg;

   $str =~ s/{CAPORDINALSTRING{DAY}}/uc(&get_ordinalstring($day))/eg;
   $str =~ s/{CAPORDINALSTRING{MONTH}}/uc(&get_ordinalstring($month))/eg;
   $str =~ s/{CAPORDINALSTRING{YEAR}}/uc(&get_ordinalstring($year))/eg;

   $str =~ s/{NUMBERSTRING{DAY}}/&get_numberstring($day)/eg;
   $str =~ s/{NUMBERSTRING{MONTH}}/&get_numberstring($month)/eg;
   $str =~ s/{NUMBERSTRING{YEAR}}/&get_numberstring($year)/eg;

   $str =~ s/{ORDINALSTRING{DAY}}/&get_ordinalstring($day)/eg;
   $str =~ s/{ORDINALSTRING{MONTH}}/&get_ordinalstring($month)/eg;
   $str =~ s/{ORDINALSTRING{YEAR}}/&get_ordinalstring($year)/eg;

   $str;
}

sub do_cmd_formatdate{
   local($day,$month,$year);
   # read 1st argument
   $day = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($day=$2));
   # read 2nd argument
   $month = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($month=$2));
   # read 3rd argument
   $year = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($year=$2));

   join('', &format_date($day,$month,$year), $_[0]);
}

sub do_cmd_today{
   join('', &format_date($global{DAY},$global{MONTH},$global{YEAR}), $_[0]);
}

sub do_cmd_day{
   join('', $global{DAY}, $_[0]);
}

sub do_cmd_month{
   join('', $global{MONTH}, $_[0]);
}

sub do_cmd_year{
   join('', $global{YEAR}, $_[0]);
}

sub do_cmd_showdowtrue{
   local($_) = @_;
   $showdow = 1;
   $_[0];
}

sub do_cmd_showdowfalse{
   local($_) = @_;
   $showdow = 0;
   $_[0];
}

# This is a bit primative, it doesn't allow for
# nested conditionals

sub do_cmd_ifshowdow{
   local($_) = @_;
   local($ifbit,$elsebit);

   $_[0] =~s/(.*)\\fi//;

   $ifbit = $1;

   $ifbit =~s/(.*)\\else(.*)/\1/g;

   $elsebit = $2;

   if ($showdow)
   {
      join('', $ifbit, $_[0]);
   }
   else
   {
      join('', $elsebit, $_[0]);
   }
}

sub do_cmd_dateseparator{
   join('', '/', $_[0]);
}

sub do_cmd_longdate{
   $dateformat = "\\ifshowdow{DOW}\\fi {ORDINALDATE{DAY}}\\ MONTHNAME[THEMONTH], THEYEAR";

   $_[0];
}

sub do_cmd_shortdate{
   $dateformat = "\\ifshowdow{SDOW}\\fi {ORDINALDATE{DAY}}\\ SHORTMONTHNAME[THEMONTH], THEYEAR";

   $_[0];
}

sub do_cmd_yyyymmdddate{
   $dateformat = "THEYEAR\\dateseparator TWODIGIT{THEMONTH}\\dateseparator TWODIGIT{THEDAY}";

   $_[0];
}

sub do_cmd_ddmmyyyydate{
   $dateformat = "TWODIGIT{THEDAY}\\dateseparator TWODIGIT{THEMONTH}\\dateseparator THEYEAR";

   $_[0];
}

sub do_cmd_dmyyyydate{
   $dateformat = "THEDAY\\dateseparator THEMONTH\\dateseparator THEYEAR";

   $_[0];
}

sub do_cmd_dmyydate{
   $dateformat = "THEDAY\\dateseparator THEMONTH\\dateseparator TRUNCATE{THEYEAR}";

   $_[0];
}

sub do_cmd_ddmmyydate{
   $dateformat = "TWODIGIT{THEDAY}\\dateseparator TWODIGIT{THEMONTH}\\dateseparator TRUNCATE{THEYEAR}";

   $_[0];
}

sub do_cmd_textdate{
   $dateformat = "\\ifshowdow{DOW} the\\fi {OORDINALSTRING{DAY}} of MONTHNAME[THEMONTH], {NNUMBERSTRING{YEAR}}";

   $_[0];
}

sub do_cmd_usdate{
   $dateformat = "MONTHNAME[THEMONTH] THEDAY, THEYEAR";

   $_[0];
}

sub do_cmd_mmddyyyydate{
   $dateformat = "TWODIGIT{THEMONTH}\\dateseparator TWODIGIT{THEDAY}\\dateseparator THEYEAR";

   $_[0];
}

sub do_cmd_mdyyyydate{
   $dateformat = "THEMONTH\\dateseparator THEDAY\\dateseparator THEYEAR";

   $_[0];
}

sub do_cmd_mmddyydate{
   $dateformat = "TWODIGIT{THEMONTH}\\dateseparator TWODIGIT{THEDAY}\\dateseparator TRUNCATE{THEYEAR}";

   $_[0];
}

sub do_cmd_mdyydate{
   $dateformat = "THEMONTH\\dateseparator THEDAY\\dateseparator TRUNCATE{THEYEAR}";

   $_[0];
}

sub do_cmd_THEYEAR{
   join('', 'THEYEAR', $_[0]);
}

sub do_cmd_THEMONTH{
   join('', 'THEMONTH', $_[0]);
}

sub do_cmd_THEDAY{
   join('', 'THEDAY', $_[0]);
}

sub do_cmd_newdateformat{
   local($_) = @_;
   local($cmd,$cmdbody);
   local($ntmp);

   $cmd = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($cmd=$2));
   $cmdbody = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($cmdbody=$2));

   $ntmp = 'sub do_cmd_' . $cmd . '{';
   $ntmp .= '$dateformat = "' . $cmdbody . '";';

   $ntmp .= '$_[0];';
   $ntmp .= '}';

   eval($ntmp);

   join('', $_[0]);
}

sub do_cmd_pdfdate{
   local($_) = @_;

   local($timestring) = sprintf "%d%02d%02d%02d%02d%02d", 
                        $global{YEAR}, $global{MONTH}, $global{DAY}, $global{HOUR}, $global{MINUTE}, $global{SECONDS};

   join('', $timestring, $_[0]);
}

 %userdates = ();

sub do_cmd_newdate{
   local($_)=@_;
   local($datename,$mon,$day,$year);

   $datename = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($datename=$2));

   $day = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($day=$2));

   $mon = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($mon =$2));

   $year = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($year =$2));


   $userdates{$datename}{day} = $day;
   $userdates{$datename}{month} = $mon;
   $userdates{$datename}{year} = $year;

   join('', $_[0]);
}

sub do_cmd_displaydate{
   local($_)=@_;
   local($datename);
   local($cmd,$br_id);

   $datename = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($datename=$2));

   $br_id = ++$global{'max_id'};
   $cmd = "$OP$br_id$CP" . $userdates{$datename}{day} ."$OP$br_id$CP";
   $br_id = ++$global{'max_id'};
   $cmd .= "$OP$br_id$CP" . $userdates{$datename}{month} ."$OP$br_id$CP";
   $br_id = ++$global{'max_id'};
   $cmd .= "$OP$br_id$CP" . $userdates{$datename}{year} ."$OP$br_id$CP";

   join('', '\formatdate', $cmd,  $_[0]);
}

sub do_cmd_getdateyear{
   local($_)=@_;
   local($datename);

   $datename = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($datename=$2));

   join('', $userdates{$datename}{year}, $_[0]);
}

sub do_cmd_getdatemonth{
   local($_)=@_;
   local($datename);

   $datename = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($datename=$2));

   join('', $userdates{$datename}{month}, $_[0]);
}

sub do_cmd_getdateday{
   local($_)=@_;
   local($datename);

   $datename = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($datename=$2));

   join('', $userdates{$datename}{day}, $_[0]);
}

# time commands

sub do_cmd_timeseparator{
   join('', ':', $_[0]);
}

sub do_cmd_noon{
   local($_) = @_;

   join('', "Noon", $_[0]);
}

sub do_cmd_midnight{
   local($_) = @_;

   join('', "Midnight", $_[0]);
}

sub do_cmd_amname{
   local($_) = @_;

   join('', "am", $_[0]);
}

sub do_cmd_pmname{
   local($_) = @_;

   join('', "pm", $_[0]);
}

sub do_cmd_amstring{
   local($_) = @_;

   join('', "in the morning", $_[0]);
}

sub do_cmd_pmstring{
   local($_) = @_;

   join('', "in the afternoon", $_[0]);
}

sub do_cmd_halfpast{
   local($_) = @_;

   join('', "Half past", $_[0]);
}

sub do_cmd_quarterpast{
   local($_) = @_;

   join('', "Quarter past", $_[0]);
}

sub do_cmd_quarterto{
   local($_) = @_;

   join('', "Quarter to", $_[0]);
}

sub do_cmd_oclockstring{
   local($_) = @_;

   join('', "O'Clock", $_[0]);
}

sub do_cmd_amorpmname{
   if ($global{HOUR}>12)
   {
      &do_cmd_pmname;
   }
   else
   {
      &do_cmd_amname;
   }
}

sub do_cmd_amorpmstring{
   if ($global{HOUR}>12)
   {
      &do_cmd_pmstring;
   }
   else
   {
      &do_cmd_amstring;
   }
}

sub set_timeformat_hhmmsstime{
  $timeformat = "TWODIGIT{THEHOUR}\\timeseparator TWODIGIT{THEMINUTE}"
  . "\\timeseparator TWODIGIT{THESECOND}";
}

sub set_timeformat_xxivtime{
  $timeformat = "TWODIGIT{THEHOUR}\\timeseparator TWODIGIT{THEMINUTE}";
}

sub format_xxivtime{
   local($hour,$min)=@_;

   sprintf "%02d\\timeseparator %02d", $hour, $min;
}

sub do_cmd_xxivtime{

   join('', &format_xxivtime($global{HOUR},$global{MINUTE}), $_[0]);
}

sub format_ampmtime{
   local($hour,$min)=@_;
   local($timestring);
   local($hourxii)  = ($hour == 12 ? 12 : ($hour)%12);

   $timestring = sprintf "%d\\timeseparator %02d", $hourxii, $min;

   $timestring .= ($hour < 12 ?
               "\\amname " : (($hour eq 12 and $min eq 0) ? " \\noon" :"\\pmname "));

   $timestring
}

sub do_cmd_ampmtime{
   join('', &format_ampmtime($global{HOUR},$global{MINUTE}), $_[0]);
}

sub do_cmd_timeformat_at_ampmtime{
   local($hour,$min,$sec);
   # read 1st argument
   $hour = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($day=$2));
   # read 2nd argument
   $min = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($month=$2));
   # read 3rd argument
   $sec = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($year=$2));

   join('', &format_ampmtime($hour, $min), $_[0]);
}

sub do_cmd_timeformatATampmtime{&do_cmd_timeformat_at_ampmtime}

sub set_timeformat_ampmtime{
  $timeformat = "TWODIGIT{THEHOURXII}\\timeseparator TWODIGIT{THEMINUTE}AMORPMNAME";
}

sub format_oclock{
   local($hour,$min)=@_;

   local($hourxii)  = ($hour == 12 ? 12 : ($hour)%12);
   local($tohour) = ($hour == 11 ? 12 :($hour+1)%12);
   local($tominute) = ($min == 0? 0 : 60 - $min);

   local($timestring);

   if ($hour == 0 && $min == 0)
   {
      $timestring = "\\midnight";
   }
   elsif ($hour == 12 && $min == 0)
   {
      $timestring = "\\noon";
   }
   else
   {
      if ($min == 0)
      {
         $timestring = &get_Numberstring($hourxii) . " \\oclockstring";
      }
      elsif ($min == 15)
      {
         $timestring = "\\quarterpast\\ " .  &get_Numberstring($hourxii);
      }
      elsif ($min == 30)
      {
         $timestring = "\\halfpast\\ " .  &get_Numberstring($hourxii);
      }
      elsif ($min == 45)
      {
         $timestring = "\\quarterto\\ " .  &get_Numberstring($tohour);
      }
      elsif ($min < 30)
      {
         $timestring = get_Numberstring($min);

         $timestring .= ($min == 1 ? " minute" : " minutes") . " past ";

         $timestring .= get_Numberstring($hourxii);
      }
      else
      {
         $timestring = get_Numberstring($tominute);

         $timestring .= ($min == 1 ? " minute" : " minutes") . " to ";

         $timestring .= get_Numberstring($tohour);
      }

      $timestring .= ($hour < 12 ? " \\amstring" : " \\pmstring");
   }

   $timestring
}

sub do_cmd_oclock{
   local($_) = @_;

   join('', &format_oclock($global{HOUR},$global{MINUTE}), $_[0]);
}

sub do_cmd_timeformat_at_oclock{
   local($hour,$min,$sec);
   # read 1st argument
   $hour = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($day=$2));
   # read 2nd argument
   $min = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($month=$2));
   # read 3rd argument
   $sec = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($year=$2));

   join('', &format_oclock($hour, $min), $_[0]);
}

sub do_cmd_timeformatAToclock{&do_cmd_timeformat_at_oclock}

sub set_timeformat_oclock{
  $timeformat="OCLOCK";
}

sub do_cmd_formattime{
   local($_) = @_;
   local($hour,$min,$sec);

   # read 1st argument
   $hour = &missing_braces unless
     (s/$next_pair_pr_rx/$hour=$2;''/eo);
   # read 2nd argument
   $min = &missing_braces unless
     (s/$next_pair_pr_rx/$min=$2;''/eo);
   # read 3rd argument
   $sec = &missing_braces unless
     (s/$next_pair_pr_rx/$sec=$2;''/eo);

   join('', &format_time($hour,$min,$sec), $_);
}

sub do_cmd_currenttime{
   join('', &format_time($global{HOUR},$global{MINUTE},$global{SECONDS}), $_[0]);
}

sub format_time{
   local($hour,$min,$sec) = @_;

   local($str) = $timeformat;

   local($hourxii)  = ($hour == 12 ? 12 : ($hour)%12);
   local($tohour) = ($hour == 11 ? 12 :($hour+1)%12);
   local($tominute) = ($min == 0? 0 : 60 - $min);
   local($amorpmname) = ($hour < 12 ? '\amname' :
     ($hour == 12 ? ' \noon' : '\pmname'));

   $str =~ s/THEHOURXII/$hourxii/g;
   $str =~ s/THEHOUR/$hour/g;
   $str =~ s/THEMINUTE/$min/g;
   $str =~ s/THESECOND/$sec/g;
   $str =~ s/THETOHOUR/$tohour/g;
   $str =~ s/THETOMINUTE/$tominute/g;
   $str =~ s/AMORPMNAME/$amorpmname/g;

   $str =~ s/TWODIGIT{([\d]+)}/&get_twodigit($1)/eg;
   $str =~ s/ROMANNUMERAL{([\d]+)}/&froman($1)/eg;
   $str =~ s/ROMANNUMERALU{([\d]+)}/uc(&froman($1))/eg;

   $str =~ s/OCLOCK/&format_oclock($hour,$min)/eg;

   $str;
}

sub do_cmd_settimeformat{
   local($_) = @_;
   local($cmd);

   $cmd = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($cmd=$2));

   eval('&set_timeformat_'.$cmd);

   $_[0];
}

sub do_cmd_newtimeformat{
   local($_) = @_;
   local($cmd,$cmdbody);

   $cmd = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($cmd=$2));
   $cmdbody = &missing_braces unless ($_[0]=~(s/$next_pair_pr_rx//o)&&($cmdbody=$2));

   $tmp = 'sub do_cmd_'.$cmd.'{&do_cmd_timeformat_at_'.$cmd.';}';
   eval($tmp);

   $tmp = 'sub set_timeformat_'.$cmd.'{';
   $tmp .= '$timeformat = "'.$cmdbody .'";';
   $tmp .= '}';
   eval($tmp);

   $tmp = 'sub do_cmd_timeformat_at_'.$cmd.'{';
   $tmp .= 'local($_)=@_;';
   $tmp .= 'local($hour,$min,$sec);';
   $tmp .= '$hour=&missing_braces unless ';
   $tmp .= '((s/$next_pair_pr_rx//o)&&($hour=$2));';
   $tmp .= '$min=&missing_braces unless ';
   $tmp .= '((s/$next_pair_pr_rx//o)&&($min=$2));';
   $tmp .= '$sec=&missing_braces unless ';
   $tmp .= '((s/$next_pair_pr_rx//o)&&($sec=$2));';
   $tmp .= '&set_timeformat_'.$cmd.';';
   $tmp .= '&format_time($hour, $min, $sec).$_';
   $tmp .= "}";

   eval($tmp);

   join('', $_[0]);
}

sub do_cmd_THEHOUR{
   local($_) = @_;

   join('', $global{HOUR}, $_[0]);
}

sub do_cmd_THEMINUTE{
   local($_) = @_;

   join('', $global{MINUTE}, $_[0]);
}

sub do_cmd_THESECOND{
   local($_) = @_;

   join('', $global{SECONDS}, $_[0]);
}

sub do_cmd_THETOHOUR{
   local($_) = @_;

   join('', $global{TOHOUR}, $_[0]);
}

sub do_cmd_THETOMINUTE{
   local($_) = @_;

   join('', $global{TOMINUTE}, $_[0]);
}

sub do_cmd_THEHOURXII{
   local($_) = @_;

   join('', $global{HOURXII}, $_[0]);
}

1;
%    \end{macrocode}
%\fi
%\iffalse
%    \begin{macrocode}
%</datetime.perl>
%    \end{macrocode}
%\fi
%\Finale
\endinput
